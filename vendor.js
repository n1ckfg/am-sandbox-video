function e(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
        var i = Object.getOwnPropertySymbols(e);
        t && (i = i.filter((function(t) {
            return Object.getOwnPropertyDescriptor(e, t).enumerable
        }
        ))),
        n.push.apply(n, i)
    }
    return n
}
function t(t) {
    for (var n = 1; n < arguments.length; n++) {
        var i = null != arguments[n] ? arguments[n] : {};
        n % 2 ? e(Object(i), !0).forEach((function(e) {
            r(t, e, i[e])
        }
        )) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(i)) : e(Object(i)).forEach((function(e) {
            Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(i, e))
        }
        ))
    }
    return t
}
function n(e, t, n, i, r, s, a) {
    try {
        var o = e[s](a)
          , l = o.value
    } catch (e) {
        return void n(e)
    }
    o.done ? t(l) : Promise.resolve(l).then(i, r)
}
function i(e) {
    return function() {
        var t = this
          , i = arguments;
        return new Promise((function(r, s) {
            var a = e.apply(t, i);
            function o(e) {
                n(a, r, s, o, l, "next", e)
            }
            function l(e) {
                n(a, r, s, o, l, "throw", e)
            }
            o(void 0)
        }
        ))
    }
}
function r(e, t, n) {
    return (t = function(e) {
        var t = function(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var n = e[Symbol.toPrimitive];
            if (void 0 !== n) {
                var i = n.call(e, t || "default");
                if ("object" != typeof i)
                    return i;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }(e, "string");
        return "symbol" == typeof t ? t : String(t)
    }(t))in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : e[t] = n,
    e
}
function s(e, t) {
    if (null == e)
        return {};
    var n, i, r = function(e, t) {
        if (null == e)
            return {};
        var n, i, r = {}, s = Object.keys(e);
        for (i = 0; i < s.length; i++)
            n = s[i],
            t.indexOf(n) >= 0 || (r[n] = e[n]);
        return r
    }(e, t);
    if (Object.getOwnPropertySymbols) {
        var s = Object.getOwnPropertySymbols(e);
        for (i = 0; i < s.length; i++)
            n = s[i],
            t.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(e, n) && (r[n] = e[n])
    }
    return r
}
function a(e) {
    throw new TypeError('"' + e + '" is read-only')
}
var o = 1
  , l = "map-container"
  , c = 17
  , h = ['<a target="_top" rel="nofollow noopener noreferrer" href="https://openstreetmap.org" title="data from openstreetmap">osm</a>', '<a target="_top" rel="nofollow noopener noreferrer" href="https://leafletjs.com" title="leaflet.js map library">leaflet</a>', '<a target="_top" rel="nofollow noopener noreferrer" href="https://stamen.com" title="tile design by stamen.com">stamen</a>'].join("<br>")
  , u = 5e12
  , d = [38, 38]
  , p = [d[0] / 2, d[1] / 2]
  , m = [0, d[1] / 2 * -1]
  , f = "map/marker"
  , g = {
    location: {
        iconUrl(e) {
            var t = e > 0 ? e : 1;
            return e > 9 && (t = "9-plus"),
            "".concat(f, "/location-").concat(t, ".svg")
        },
        iconSize: d,
        iconAnchor: p,
        popupAnchor: m
    },
    city: {
        iconUrl: e=>"".concat(f, "/cities/").concat(e, ".svg"),
        iconSize: d,
        iconAnchor: p,
        popupAnchor: m
    },
    artifact: {
        iconUrl: "".concat(f, "/object.svg"),
        iconSize: d,
        iconAnchor: p,
        popupAnchor: m
    }
}
  , v = {
    strings: {
        title: "Click to locate yourself.",
        metersUnit: "meters",
        feetUnit: "feet",
        popup: "You are within {distance} {unit} from this point",
        outsideMapBoundsMsg: "\nIt seems like your Device has no gps sensors, or you declined our request to use gps.\n"
    },
    locateOptions: {
        watch: !0,
        enableHighAccuracy: !0
    }
}
  , x = {
    fov: 60,
    near: .01,
    far: 500
}
  , y = {
    maxDistance: 60,
    minDistance: 1,
    maxPolarAngle: Math.PI / 1.9,
    enablePan: !1
}
  , _ = {
    ambientColor: 16777215,
    ambientIntensity: .5,
    directionalColor: 16777215,
    directionalIntensity: 2.5,
    directionalPosition: [15, 30, 7]
}
  , b = .2
  , w = 7e3
  , S = [100, 60, 40]
  , T = "three-running"
  , A = {
    x: 0,
    y: 1.5,
    z: 5
}
  , E = function(e) {
    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "at this location.";
    return 0 === e ? e = "are no artifacts" : 1 === e ? e = "is 1 artifact" : e > 1 && (e = "are ".concat(e, " artifacts")),
    "There ".concat(e, " ").concat(t)
}
  , C = 1e4
  , L = "Zoom to location"
  , R = "Visit City"
  , P = "three-audio"
  , I = "three-video"
  , D = "three-media"
  , O = "three-canvas"
  , N = "three-container"
  , z = "hud"
  , U = "hud-exit-button"
  , F = 1e4
  , k = (e,t)=>"function" == typeof k[t] ? k[t](e) : typeof e === t;
k.fn = e=>"function" == typeof e,
k.str = e=>"string" == typeof e,
k.obj = e=>"object" == typeof e,
k.arr = e=>Array.isArray(e),
k.bool = e=>"boolean" == typeof e,
k.num = e=>e === +e;
var G = window;
G.D = document,
G.B = G.D.body,
G.M = Math,
G.NAV = G.navigator,
G.UA = G.NAV.userAgent.toLowerCase() || "",
G.URL = G.URL || G.webkitURL,
G.pxRatio = G.devicePixelRatio,
G.store = new class {
    constructor(e) {
        var {W: t, type: n="session"} = e;
        try {
            var i = t["".concat(n, "Storage")]
              , r = "random-".concat(M.random());
            i.setItem(r, r),
            i.removeItem(r),
            this.store = i
        } catch (e) {
            this.store = {}
        }
    }
    setItem(e, t) {
        var n = ["setItem", "getItem", "removeItem"]
          , i = n.indexOf(e);
        if (i > -1)
            throw new Error("can not overwrite store.".concat(n[i], ", it's a builtin"));
        var r = JSON.stringify(t);
        return this.store[e] = r,
        !0
    }
    getItem(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0;
        return this.store.hasOwnProperty(e) ? JSON.parse(this.store[e]) : t
    }
    removeItem(e) {
        k.fn(this.store.removeItem) ? this.store.removeItem(e) : delete this.store[e]
    }
    clear() {
        k.fn(this.store.clear) ? this.store.clear() : this.store = {}
    }
}
({
    W: G,
    type: "session"
});
var H = G.UA
  , V = H.includes("mac") && "ontouchend"in G.D
  , W = ["ipad", "iphone", "ipod"].some((e=>H.includes(e)))
  , j = W || V
  , X = !j && H.includes("macintosh")
  , q = H.includes("applewebkit") && H.includes("safari") && !H.includes("crios")
  , Y = H.includes("firefox") && H.includes("gecko") && H.includes("mozilla") && !H.includes("seamonkey")
  , Z = (()=>{
    var e;
    if (H.includes("chrome/") ? e = H.split("chrome/")[1] : H.includes("samsungbrowser/") && (e = H.split("samsungbrowser/")[1]),
    e) {
        e = e.split(".")[0];
        var t = parseInt(e, 10);
        if (k.num(t))
            return t
    }
}
)()
  , J = k.num(Z)
  , K = H.includes("android")
  , Q = j && H.includes("webxrviewer")
  , $ = Object.freeze({
    __proto__: null,
    ios13: V,
    iDevice: W,
    ios: j,
    macos: X,
    safari: q,
    firefox: Y,
    firefoxVersion: ()=>{
        H.includes("firefox/") && H.split("firefox/")[1]
    }
    ,
    version: Z,
    chrome: J,
    android: K,
    webxrviewer: Q
});
const ee = "144"
  , te = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2,
    ROTATE: 0,
    DOLLY: 1,
    PAN: 2
}
  , ne = {
    ROTATE: 0,
    PAN: 1,
    DOLLY_PAN: 2,
    DOLLY_ROTATE: 3
}
  , ie = 2
  , re = 0
  , se = 1
  , ae = 2
  , oe = 1
  , le = 2
  , ce = 100
  , he = 4
  , ue = 300
  , de = 301
  , pe = 302
  , me = 303
  , fe = 304
  , ge = 306
  , ve = 1e3
  , xe = 1001
  , ye = 1002
  , _e = 1003
  , be = 1004
  , Me = 1005
  , we = 1006
  , Se = 1007
  , Te = 1008
  , Ae = 1009
  , Ee = 1012
  , Ce = 1014
  , Le = 1015
  , Re = 1016
  , Pe = 1020
  , Ie = 1023
  , De = 1026
  , Oe = 1027
  , Ne = 33776
  , ze = 33777
  , Ue = 33778
  , Fe = 33779
  , Be = 35840
  , ke = 35841
  , Ge = 35842
  , He = 35843
  , Ve = 37492
  , We = 37496
  , je = 37808
  , Xe = 37809
  , qe = 37810
  , Ye = 37811
  , Ze = 37812
  , Je = 37813
  , Ke = 37814
  , Qe = 37815
  , $e = 37816
  , et = 37817
  , tt = 37818
  , nt = 37819
  , it = 37820
  , rt = 37821
  , st = 36492
  , at = 2200
  , ot = 2300
  , lt = 2301
  , ct = 2302
  , ht = 2400
  , ut = 2401
  , dt = 2402
  , pt = 2500
  , mt = 2501
  , ft = 3e3
  , gt = 3001
  , vt = "srgb"
  , xt = "srgb-linear"
  , yt = 7680
  , _t = 35044
  , bt = "300 es"
  , Mt = 1035;
class wt {
    addEventListener(e, t) {
        void 0 === this._listeners && (this._listeners = {});
        const n = this._listeners;
        void 0 === n[e] && (n[e] = []),
        -1 === n[e].indexOf(t) && n[e].push(t)
    }
    hasEventListener(e, t) {
        if (void 0 === this._listeners)
            return !1;
        const n = this._listeners;
        return void 0 !== n[e] && -1 !== n[e].indexOf(t)
    }
    removeEventListener(e, t) {
        if (void 0 === this._listeners)
            return;
        const n = this._listeners[e];
        if (void 0 !== n) {
            const e = n.indexOf(t);
            -1 !== e && n.splice(e, 1)
        }
    }
    dispatchEvent(e) {
        if (void 0 === this._listeners)
            return;
        const t = this._listeners[e.type];
        if (void 0 !== t) {
            e.target = this;
            const n = t.slice(0);
            for (let t = 0, i = n.length; t < i; t++)
                n[t].call(this, e);
            e.target = null
        }
    }
}
const St = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let Tt = 1234567;
const At = Math.PI / 180
  , Et = 180 / Math.PI;
function Ct() {
    const e = 4294967295 * Math.random() | 0
      , t = 4294967295 * Math.random() | 0
      , n = 4294967295 * Math.random() | 0
      , i = 4294967295 * Math.random() | 0;
    return (St[255 & e] + St[e >> 8 & 255] + St[e >> 16 & 255] + St[e >> 24 & 255] + "-" + St[255 & t] + St[t >> 8 & 255] + "-" + St[t >> 16 & 15 | 64] + St[t >> 24 & 255] + "-" + St[63 & n | 128] + St[n >> 8 & 255] + "-" + St[n >> 16 & 255] + St[n >> 24 & 255] + St[255 & i] + St[i >> 8 & 255] + St[i >> 16 & 255] + St[i >> 24 & 255]).toLowerCase()
}
function Lt(e, t, n) {
    return Math.max(t, Math.min(n, e))
}
function Rt(e, t) {
    return (e % t + t) % t
}
function Pt(e, t, n) {
    return (1 - n) * e + n * t
}
function It(e) {
    return 0 == (e & e - 1) && 0 !== e
}
function Dt(e) {
    return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
}
function Ot(e) {
    return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
}
function Nt(e, t) {
    switch (t.constructor) {
    case Float32Array:
        return e;
    case Uint16Array:
        return e / 65535;
    case Uint8Array:
        return e / 255;
    case Int16Array:
        return Math.max(e / 32767, -1);
    case Int8Array:
        return Math.max(e / 127, -1);
    default:
        throw new Error("Invalid component type.")
    }
}
function zt(e, t) {
    switch (t.constructor) {
    case Float32Array:
        return e;
    case Uint16Array:
        return Math.round(65535 * e);
    case Uint8Array:
        return Math.round(255 * e);
    case Int16Array:
        return Math.round(32767 * e);
    case Int8Array:
        return Math.round(127 * e);
    default:
        throw new Error("Invalid component type.")
    }
}
var Ut = Object.freeze({
    __proto__: null,
    DEG2RAD: At,
    RAD2DEG: Et,
    generateUUID: Ct,
    clamp: Lt,
    euclideanModulo: Rt,
    mapLinear: function(e, t, n, i, r) {
        return i + (e - t) * (r - i) / (n - t)
    },
    inverseLerp: function(e, t, n) {
        return e !== t ? (n - e) / (t - e) : 0
    },
    lerp: Pt,
    damp: function(e, t, n, i) {
        return Pt(e, t, 1 - Math.exp(-n * i))
    },
    pingpong: function(e, t=1) {
        return t - Math.abs(Rt(e, 2 * t) - t)
    },
    smoothstep: function(e, t, n) {
        return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e)
    },
    smootherstep: function(e, t, n) {
        return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10)
    },
    randInt: function(e, t) {
        return e + Math.floor(Math.random() * (t - e + 1))
    },
    randFloat: function(e, t) {
        return e + Math.random() * (t - e)
    },
    randFloatSpread: function(e) {
        return e * (.5 - Math.random())
    },
    seededRandom: function(e) {
        void 0 !== e && (Tt = e);
        let t = Tt += 1831565813;
        return t = Math.imul(t ^ t >>> 15, 1 | t),
        t ^= t + Math.imul(t ^ t >>> 7, 61 | t),
        ((t ^ t >>> 14) >>> 0) / 4294967296
    },
    degToRad: function(e) {
        return e * At
    },
    radToDeg: function(e) {
        return e * Et
    },
    isPowerOfTwo: It,
    ceilPowerOfTwo: Dt,
    floorPowerOfTwo: Ot,
    setQuaternionFromProperEuler: function(e, t, n, i, r) {
        const s = Math.cos
          , a = Math.sin
          , o = s(n / 2)
          , l = a(n / 2)
          , c = s((t + i) / 2)
          , h = a((t + i) / 2)
          , u = s((t - i) / 2)
          , d = a((t - i) / 2)
          , p = s((i - t) / 2)
          , m = a((i - t) / 2);
        switch (r) {
        case "XYX":
            e.set(o * h, l * u, l * d, o * c);
            break;
        case "YZY":
            e.set(l * d, o * h, l * u, o * c);
            break;
        case "ZXZ":
            e.set(l * u, l * d, o * h, o * c);
            break;
        case "XZX":
            e.set(o * h, l * m, l * p, o * c);
            break;
        case "YXY":
            e.set(l * p, o * h, l * m, o * c);
            break;
        case "ZYZ":
            e.set(l * m, l * p, o * h, o * c);
            break;
        default:
            console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
        }
    },
    normalize: zt,
    denormalize: Nt
});
class Ft {
    constructor(e=0, t=0) {
        Ft.prototype.isVector2 = !0,
        this.x = e,
        this.y = t
    }
    get width() {
        return this.x
    }
    set width(e) {
        this.x = e
    }
    get height() {
        return this.y
    }
    set height(e) {
        this.y = e
    }
    set(e, t) {
        return this.x = e,
        this.y = t,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    applyMatrix3(e) {
        const t = this.x
          , n = this.y
          , i = e.elements;
        return this.x = i[0] * t + i[3] * n + i[6],
        this.y = i[1] * t + i[4] * n + i[7],
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this
    }
    clampLength(e, t) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this
    }
    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y
    }
    cross(e) {
        return this.x * e.y - this.y * e.x
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x
          , n = this.y - e.y;
        return t * t + n * n
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this
    }
    lerpVectors(e, t, n) {
        return this.x = e.x + (t.x - e.x) * n,
        this.y = e.y + (t.y - e.y) * n,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this
    }
    rotateAround(e, t) {
        const n = Math.cos(t)
          , i = Math.sin(t)
          , r = this.x - e.x
          , s = this.y - e.y;
        return this.x = r * n - s * i + e.x,
        this.y = r * i + s * n + e.y,
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y
    }
}
class Bt {
    constructor() {
        Bt.prototype.isMatrix3 = !0,
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]
    }
    set(e, t, n, i, r, s, a, o, l) {
        const c = this.elements;
        return c[0] = e,
        c[1] = i,
        c[2] = a,
        c[3] = t,
        c[4] = r,
        c[5] = o,
        c[6] = n,
        c[7] = s,
        c[8] = l,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
        this
    }
    copy(e) {
        const t = this.elements
          , n = e.elements;
        return t[0] = n[0],
        t[1] = n[1],
        t[2] = n[2],
        t[3] = n[3],
        t[4] = n[4],
        t[5] = n[5],
        t[6] = n[6],
        t[7] = n[7],
        t[8] = n[8],
        this
    }
    extractBasis(e, t, n) {
        return e.setFromMatrix3Column(this, 0),
        t.setFromMatrix3Column(this, 1),
        n.setFromMatrix3Column(this, 2),
        this
    }
    setFromMatrix4(e) {
        const t = e.elements;
        return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const n = e.elements
          , i = t.elements
          , r = this.elements
          , s = n[0]
          , a = n[3]
          , o = n[6]
          , l = n[1]
          , c = n[4]
          , h = n[7]
          , u = n[2]
          , d = n[5]
          , p = n[8]
          , m = i[0]
          , f = i[3]
          , g = i[6]
          , v = i[1]
          , x = i[4]
          , y = i[7]
          , _ = i[2]
          , b = i[5]
          , M = i[8];
        return r[0] = s * m + a * v + o * _,
        r[3] = s * f + a * x + o * b,
        r[6] = s * g + a * y + o * M,
        r[1] = l * m + c * v + h * _,
        r[4] = l * f + c * x + h * b,
        r[7] = l * g + c * y + h * M,
        r[2] = u * m + d * v + p * _,
        r[5] = u * f + d * x + p * b,
        r[8] = u * g + d * y + p * M,
        this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e,
        t[3] *= e,
        t[6] *= e,
        t[1] *= e,
        t[4] *= e,
        t[7] *= e,
        t[2] *= e,
        t[5] *= e,
        t[8] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , t = e[0]
          , n = e[1]
          , i = e[2]
          , r = e[3]
          , s = e[4]
          , a = e[5]
          , o = e[6]
          , l = e[7]
          , c = e[8];
        return t * s * c - t * a * l - n * r * c + n * a * o + i * r * l - i * s * o
    }
    invert() {
        const e = this.elements
          , t = e[0]
          , n = e[1]
          , i = e[2]
          , r = e[3]
          , s = e[4]
          , a = e[5]
          , o = e[6]
          , l = e[7]
          , c = e[8]
          , h = c * s - a * l
          , u = a * o - c * r
          , d = l * r - s * o
          , p = t * h + n * u + i * d;
        if (0 === p)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const m = 1 / p;
        return e[0] = h * m,
        e[1] = (i * l - c * n) * m,
        e[2] = (a * n - i * s) * m,
        e[3] = u * m,
        e[4] = (c * t - i * o) * m,
        e[5] = (i * r - a * t) * m,
        e[6] = d * m,
        e[7] = (n * o - l * t) * m,
        e[8] = (s * t - n * r) * m,
        this
    }
    transpose() {
        let e;
        const t = this.elements;
        return e = t[1],
        t[1] = t[3],
        t[3] = e,
        e = t[2],
        t[2] = t[6],
        t[6] = e,
        e = t[5],
        t[5] = t[7],
        t[7] = e,
        this
    }
    getNormalMatrix(e) {
        return this.setFromMatrix4(e).invert().transpose()
    }
    transposeIntoArray(e) {
        const t = this.elements;
        return e[0] = t[0],
        e[1] = t[3],
        e[2] = t[6],
        e[3] = t[1],
        e[4] = t[4],
        e[5] = t[7],
        e[6] = t[2],
        e[7] = t[5],
        e[8] = t[8],
        this
    }
    setUvTransform(e, t, n, i, r, s, a) {
        const o = Math.cos(r)
          , l = Math.sin(r);
        return this.set(n * o, n * l, -n * (o * s + l * a) + s + e, -i * l, i * o, -i * (-l * s + o * a) + a + t, 0, 0, 1),
        this
    }
    scale(e, t) {
        const n = this.elements;
        return n[0] *= e,
        n[3] *= e,
        n[6] *= e,
        n[1] *= t,
        n[4] *= t,
        n[7] *= t,
        this
    }
    rotate(e) {
        const t = Math.cos(e)
          , n = Math.sin(e)
          , i = this.elements
          , r = i[0]
          , s = i[3]
          , a = i[6]
          , o = i[1]
          , l = i[4]
          , c = i[7];
        return i[0] = t * r + n * o,
        i[3] = t * s + n * l,
        i[6] = t * a + n * c,
        i[1] = -n * r + t * o,
        i[4] = -n * s + t * l,
        i[7] = -n * a + t * c,
        this
    }
    translate(e, t) {
        const n = this.elements;
        return n[0] += e * n[2],
        n[3] += e * n[5],
        n[6] += e * n[8],
        n[1] += t * n[2],
        n[4] += t * n[5],
        n[7] += t * n[8],
        this
    }
    equals(e) {
        const t = this.elements
          , n = e.elements;
        for (let e = 0; e < 9; e++)
            if (t[e] !== n[e])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let n = 0; n < 9; n++)
            this.elements[n] = e[n + t];
        return this
    }
    toArray(e=[], t=0) {
        const n = this.elements;
        return e[t] = n[0],
        e[t + 1] = n[1],
        e[t + 2] = n[2],
        e[t + 3] = n[3],
        e[t + 4] = n[4],
        e[t + 5] = n[5],
        e[t + 6] = n[6],
        e[t + 7] = n[7],
        e[t + 8] = n[8],
        e
    }
    clone() {
        return (new this.constructor).fromArray(this.elements)
    }
}
function kt(e) {
    for (let t = e.length - 1; t >= 0; --t)
        if (e[t] >= 65535)
            return !0;
    return !1
}
const Gt = {
    Int8Array: Int8Array,
    Uint8Array: Uint8Array,
    Uint8ClampedArray: Uint8ClampedArray,
    Int16Array: Int16Array,
    Uint16Array: Uint16Array,
    Int32Array: Int32Array,
    Uint32Array: Uint32Array,
    Float32Array: Float32Array,
    Float64Array: Float64Array
};
function Ht(e, t) {
    return new Gt[e](t)
}
function Vt(e) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", e)
}
function Wt(e) {
    return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
}
function jt(e) {
    return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
}
const Xt = {
    [vt]: {
        [xt]: Wt
    },
    [xt]: {
        [vt]: jt
    }
}
  , qt = {
    legacyMode: !0,
    get workingColorSpace() {
        return xt
    },
    set workingColorSpace(e) {
        console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")
    },
    convert: function(e, t, n) {
        if (this.legacyMode || t === n || !t || !n)
            return e;
        if (Xt[t] && void 0 !== Xt[t][n]) {
            const i = Xt[t][n];
            return e.r = i(e.r),
            e.g = i(e.g),
            e.b = i(e.b),
            e
        }
        throw new Error("Unsupported color space conversion.")
    },
    fromWorkingColorSpace: function(e, t) {
        return this.convert(e, this.workingColorSpace, t)
    },
    toWorkingColorSpace: function(e, t) {
        return this.convert(e, t, this.workingColorSpace)
    }
}
  , Yt = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
}
  , Zt = {
    r: 0,
    g: 0,
    b: 0
}
  , Jt = {
    h: 0,
    s: 0,
    l: 0
}
  , Kt = {
    h: 0,
    s: 0,
    l: 0
};
function Qt(e, t, n) {
    return n < 0 && (n += 1),
    n > 1 && (n -= 1),
    n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e
}
function $t(e, t) {
    return t.r = e.r,
    t.g = e.g,
    t.b = e.b,
    t
}
class en {
    constructor(e, t, n) {
        return this.isColor = !0,
        this.r = 1,
        this.g = 1,
        this.b = 1,
        void 0 === t && void 0 === n ? this.set(e) : this.setRGB(e, t, n)
    }
    set(e) {
        return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e),
        this
    }
    setScalar(e) {
        return this.r = e,
        this.g = e,
        this.b = e,
        this
    }
    setHex(e, t=vt) {
        return e = Math.floor(e),
        this.r = (e >> 16 & 255) / 255,
        this.g = (e >> 8 & 255) / 255,
        this.b = (255 & e) / 255,
        qt.toWorkingColorSpace(this, t),
        this
    }
    setRGB(e, t, n, i=xt) {
        return this.r = e,
        this.g = t,
        this.b = n,
        qt.toWorkingColorSpace(this, i),
        this
    }
    setHSL(e, t, n, i=xt) {
        if (e = Rt(e, 1),
        t = Lt(t, 0, 1),
        n = Lt(n, 0, 1),
        0 === t)
            this.r = this.g = this.b = n;
        else {
            const i = n <= .5 ? n * (1 + t) : n + t - n * t
              , r = 2 * n - i;
            this.r = Qt(r, i, e + 1 / 3),
            this.g = Qt(r, i, e),
            this.b = Qt(r, i, e - 1 / 3)
        }
        return qt.toWorkingColorSpace(this, i),
        this
    }
    setStyle(e, t=vt) {
        function n(t) {
            void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
        }
        let i;
        if (i = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
            let e;
            const r = i[1]
              , s = i[2];
            switch (r) {
            case "rgb":
            case "rgba":
                if (e = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))
                    return this.r = Math.min(255, parseInt(e[1], 10)) / 255,
                    this.g = Math.min(255, parseInt(e[2], 10)) / 255,
                    this.b = Math.min(255, parseInt(e[3], 10)) / 255,
                    qt.toWorkingColorSpace(this, t),
                    n(e[4]),
                    this;
                if (e = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))
                    return this.r = Math.min(100, parseInt(e[1], 10)) / 100,
                    this.g = Math.min(100, parseInt(e[2], 10)) / 100,
                    this.b = Math.min(100, parseInt(e[3], 10)) / 100,
                    qt.toWorkingColorSpace(this, t),
                    n(e[4]),
                    this;
                break;
            case "hsl":
            case "hsla":
                if (e = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) {
                    const i = parseFloat(e[1]) / 360
                      , r = parseFloat(e[2]) / 100
                      , s = parseFloat(e[3]) / 100;
                    return n(e[4]),
                    this.setHSL(i, r, s, t)
                }
            }
        } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
            const e = i[1]
              , n = e.length;
            if (3 === n)
                return this.r = parseInt(e.charAt(0) + e.charAt(0), 16) / 255,
                this.g = parseInt(e.charAt(1) + e.charAt(1), 16) / 255,
                this.b = parseInt(e.charAt(2) + e.charAt(2), 16) / 255,
                qt.toWorkingColorSpace(this, t),
                this;
            if (6 === n)
                return this.r = parseInt(e.charAt(0) + e.charAt(1), 16) / 255,
                this.g = parseInt(e.charAt(2) + e.charAt(3), 16) / 255,
                this.b = parseInt(e.charAt(4) + e.charAt(5), 16) / 255,
                qt.toWorkingColorSpace(this, t),
                this
        }
        return e && e.length > 0 ? this.setColorName(e, t) : this
    }
    setColorName(e, t=vt) {
        const n = Yt[e.toLowerCase()];
        return void 0 !== n ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e),
        this
    }
    clone() {
        return new this.constructor(this.r,this.g,this.b)
    }
    copy(e) {
        return this.r = e.r,
        this.g = e.g,
        this.b = e.b,
        this
    }
    copySRGBToLinear(e) {
        return this.r = Wt(e.r),
        this.g = Wt(e.g),
        this.b = Wt(e.b),
        this
    }
    copyLinearToSRGB(e) {
        return this.r = jt(e.r),
        this.g = jt(e.g),
        this.b = jt(e.b),
        this
    }
    convertSRGBToLinear() {
        return this.copySRGBToLinear(this),
        this
    }
    convertLinearToSRGB() {
        return this.copyLinearToSRGB(this),
        this
    }
    getHex(e=vt) {
        return qt.fromWorkingColorSpace($t(this, Zt), e),
        Lt(255 * Zt.r, 0, 255) << 16 ^ Lt(255 * Zt.g, 0, 255) << 8 ^ Lt(255 * Zt.b, 0, 255) << 0
    }
    getHexString(e=vt) {
        return ("000000" + this.getHex(e).toString(16)).slice(-6)
    }
    getHSL(e, t=xt) {
        qt.fromWorkingColorSpace($t(this, Zt), t);
        const n = Zt.r
          , i = Zt.g
          , r = Zt.b
          , s = Math.max(n, i, r)
          , a = Math.min(n, i, r);
        let o, l;
        const c = (a + s) / 2;
        if (a === s)
            o = 0,
            l = 0;
        else {
            const e = s - a;
            switch (l = c <= .5 ? e / (s + a) : e / (2 - s - a),
            s) {
            case n:
                o = (i - r) / e + (i < r ? 6 : 0);
                break;
            case i:
                o = (r - n) / e + 2;
                break;
            case r:
                o = (n - i) / e + 4
            }
            o /= 6
        }
        return e.h = o,
        e.s = l,
        e.l = c,
        e
    }
    getRGB(e, t=xt) {
        return qt.fromWorkingColorSpace($t(this, Zt), t),
        e.r = Zt.r,
        e.g = Zt.g,
        e.b = Zt.b,
        e
    }
    getStyle(e=vt) {
        return qt.fromWorkingColorSpace($t(this, Zt), e),
        e !== vt ? `color(${e} ${Zt.r} ${Zt.g} ${Zt.b})` : `rgb(${255 * Zt.r | 0},${255 * Zt.g | 0},${255 * Zt.b | 0})`
    }
    offsetHSL(e, t, n) {
        return this.getHSL(Jt),
        Jt.h += e,
        Jt.s += t,
        Jt.l += n,
        this.setHSL(Jt.h, Jt.s, Jt.l),
        this
    }
    add(e) {
        return this.r += e.r,
        this.g += e.g,
        this.b += e.b,
        this
    }
    addColors(e, t) {
        return this.r = e.r + t.r,
        this.g = e.g + t.g,
        this.b = e.b + t.b,
        this
    }
    addScalar(e) {
        return this.r += e,
        this.g += e,
        this.b += e,
        this
    }
    sub(e) {
        return this.r = Math.max(0, this.r - e.r),
        this.g = Math.max(0, this.g - e.g),
        this.b = Math.max(0, this.b - e.b),
        this
    }
    multiply(e) {
        return this.r *= e.r,
        this.g *= e.g,
        this.b *= e.b,
        this
    }
    multiplyScalar(e) {
        return this.r *= e,
        this.g *= e,
        this.b *= e,
        this
    }
    lerp(e, t) {
        return this.r += (e.r - this.r) * t,
        this.g += (e.g - this.g) * t,
        this.b += (e.b - this.b) * t,
        this
    }
    lerpColors(e, t, n) {
        return this.r = e.r + (t.r - e.r) * n,
        this.g = e.g + (t.g - e.g) * n,
        this.b = e.b + (t.b - e.b) * n,
        this
    }
    lerpHSL(e, t) {
        this.getHSL(Jt),
        e.getHSL(Kt);
        const n = Pt(Jt.h, Kt.h, t)
          , i = Pt(Jt.s, Kt.s, t)
          , r = Pt(Jt.l, Kt.l, t);
        return this.setHSL(n, i, r),
        this
    }
    equals(e) {
        return e.r === this.r && e.g === this.g && e.b === this.b
    }
    fromArray(e, t=0) {
        return this.r = e[t],
        this.g = e[t + 1],
        this.b = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.r,
        e[t + 1] = this.g,
        e[t + 2] = this.b,
        e
    }
    fromBufferAttribute(e, t) {
        return this.r = e.getX(t),
        this.g = e.getY(t),
        this.b = e.getZ(t),
        this
    }
    toJSON() {
        return this.getHex()
    }
    *[Symbol.iterator]() {
        yield this.r,
        yield this.g,
        yield this.b
    }
}
let tn;
en.NAMES = Yt;
class nn {
    static getDataURL(e) {
        if (/^data:/i.test(e.src))
            return e.src;
        if ("undefined" == typeof HTMLCanvasElement)
            return e.src;
        let t;
        if (e instanceof HTMLCanvasElement)
            t = e;
        else {
            void 0 === tn && (tn = Vt("canvas")),
            tn.width = e.width,
            tn.height = e.height;
            const n = tn.getContext("2d");
            e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height),
            t = tn
        }
        return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e),
        t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
    }
    static sRGBToLinear(e) {
        if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
            const t = Vt("canvas");
            t.width = e.width,
            t.height = e.height;
            const n = t.getContext("2d");
            n.drawImage(e, 0, 0, e.width, e.height);
            const i = n.getImageData(0, 0, e.width, e.height)
              , r = i.data;
            for (let e = 0; e < r.length; e++)
                r[e] = 255 * Wt(r[e] / 255);
            return n.putImageData(i, 0, 0),
            t
        }
        if (e.data) {
            const t = e.data.slice(0);
            for (let e = 0; e < t.length; e++)
                t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[e] = Math.floor(255 * Wt(t[e] / 255)) : t[e] = Wt(t[e]);
            return {
                data: t,
                width: e.width,
                height: e.height
            }
        }
        return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
        e
    }
}
class rn {
    constructor(e=null) {
        this.isSource = !0,
        this.uuid = Ct(),
        this.data = e,
        this.version = 0
    }
    set needsUpdate(e) {
        !0 === e && this.version++
    }
    toJSON(e) {
        const t = void 0 === e || "string" == typeof e;
        if (!t && void 0 !== e.images[this.uuid])
            return e.images[this.uuid];
        const n = {
            uuid: this.uuid,
            url: ""
        }
          , i = this.data;
        if (null !== i) {
            let e;
            if (Array.isArray(i)) {
                e = [];
                for (let t = 0, n = i.length; t < n; t++)
                    i[t].isDataTexture ? e.push(sn(i[t].image)) : e.push(sn(i[t]))
            } else
                e = sn(i);
            n.url = e
        }
        return t || (e.images[this.uuid] = n),
        n
    }
}
function sn(e) {
    return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? nn.getDataURL(e) : e.data ? {
        data: Array.from(e.data),
        width: e.width,
        height: e.height,
        type: e.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."),
    {})
}
let an = 0;
class on extends wt {
    constructor(e=on.DEFAULT_IMAGE, t=on.DEFAULT_MAPPING, n=1001, i=1001, r=1006, s=1008, a=1023, o=1009, l=1, c=3e3) {
        super(),
        this.isTexture = !0,
        Object.defineProperty(this, "id", {
            value: an++
        }),
        this.uuid = Ct(),
        this.name = "",
        this.source = new rn(e),
        this.mipmaps = [],
        this.mapping = t,
        this.wrapS = n,
        this.wrapT = i,
        this.magFilter = r,
        this.minFilter = s,
        this.anisotropy = l,
        this.format = a,
        this.internalFormat = null,
        this.type = o,
        this.offset = new Ft(0,0),
        this.repeat = new Ft(1,1),
        this.center = new Ft(0,0),
        this.rotation = 0,
        this.matrixAutoUpdate = !0,
        this.matrix = new Bt,
        this.generateMipmaps = !0,
        this.premultiplyAlpha = !1,
        this.flipY = !0,
        this.unpackAlignment = 4,
        this.encoding = c,
        this.userData = {},
        this.version = 0,
        this.onUpdate = null,
        this.isRenderTargetTexture = !1,
        this.needsPMREMUpdate = !1
    }
    get image() {
        return this.source.data
    }
    set image(e) {
        this.source.data = e
    }
    updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
    }
    clone() {
        return (new this.constructor).copy(this)
    }
    copy(e) {
        return this.name = e.name,
        this.source = e.source,
        this.mipmaps = e.mipmaps.slice(0),
        this.mapping = e.mapping,
        this.wrapS = e.wrapS,
        this.wrapT = e.wrapT,
        this.magFilter = e.magFilter,
        this.minFilter = e.minFilter,
        this.anisotropy = e.anisotropy,
        this.format = e.format,
        this.internalFormat = e.internalFormat,
        this.type = e.type,
        this.offset.copy(e.offset),
        this.repeat.copy(e.repeat),
        this.center.copy(e.center),
        this.rotation = e.rotation,
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrix.copy(e.matrix),
        this.generateMipmaps = e.generateMipmaps,
        this.premultiplyAlpha = e.premultiplyAlpha,
        this.flipY = e.flipY,
        this.unpackAlignment = e.unpackAlignment,
        this.encoding = e.encoding,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this.needsUpdate = !0,
        this
    }
    toJSON(e) {
        const t = void 0 === e || "string" == typeof e;
        if (!t && void 0 !== e.textures[this.uuid])
            return e.textures[this.uuid];
        const n = {
            metadata: {
                version: 4.5,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        return "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData),
        t || (e.textures[this.uuid] = n),
        n
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    transformUv(e) {
        if (this.mapping !== ue)
            return e;
        if (e.applyMatrix3(this.matrix),
        e.x < 0 || e.x > 1)
            switch (this.wrapS) {
            case ve:
                e.x = e.x - Math.floor(e.x);
                break;
            case xe:
                e.x = e.x < 0 ? 0 : 1;
                break;
            case ye:
                1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
            }
        if (e.y < 0 || e.y > 1)
            switch (this.wrapT) {
            case ve:
                e.y = e.y - Math.floor(e.y);
                break;
            case xe:
                e.y = e.y < 0 ? 0 : 1;
                break;
            case ye:
                1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
            }
        return this.flipY && (e.y = 1 - e.y),
        e
    }
    set needsUpdate(e) {
        !0 === e && (this.version++,
        this.source.needsUpdate = !0)
    }
}
on.DEFAULT_IMAGE = null,
on.DEFAULT_MAPPING = ue;
class ln {
    constructor(e=0, t=0, n=0, i=1) {
        ln.prototype.isVector4 = !0,
        this.x = e,
        this.y = t,
        this.z = n,
        this.w = i
    }
    get width() {
        return this.z
    }
    set width(e) {
        this.z = e
    }
    get height() {
        return this.w
    }
    set height(e) {
        this.w = e
    }
    set(e, t, n, i) {
        return this.x = e,
        this.y = t,
        this.z = n,
        this.w = i,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this.w = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setW(e) {
        return this.w = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        case 3:
            this.w = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        case 3:
            return this.w;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z,this.w)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this.w = void 0 !== e.w ? e.w : 1,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this.w += e.w,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this.w += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this.w = e.w + t.w,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this.w += e.w * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this.w -= e.w,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this.w -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this.w = e.w - t.w,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this.w *= e.w,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this.w *= e,
        this
    }
    applyMatrix4(e) {
        const t = this.x
          , n = this.y
          , i = this.z
          , r = this.w
          , s = e.elements;
        return this.x = s[0] * t + s[4] * n + s[8] * i + s[12] * r,
        this.y = s[1] * t + s[5] * n + s[9] * i + s[13] * r,
        this.z = s[2] * t + s[6] * n + s[10] * i + s[14] * r,
        this.w = s[3] * t + s[7] * n + s[11] * i + s[15] * r,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    setAxisAngleFromQuaternion(e) {
        this.w = 2 * Math.acos(e.w);
        const t = Math.sqrt(1 - e.w * e.w);
        return t < 1e-4 ? (this.x = 1,
        this.y = 0,
        this.z = 0) : (this.x = e.x / t,
        this.y = e.y / t,
        this.z = e.z / t),
        this
    }
    setAxisAngleFromRotationMatrix(e) {
        let t, n, i, r;
        const s = .01
          , a = .1
          , o = e.elements
          , l = o[0]
          , c = o[4]
          , h = o[8]
          , u = o[1]
          , d = o[5]
          , p = o[9]
          , m = o[2]
          , f = o[6]
          , g = o[10];
        if (Math.abs(c - u) < s && Math.abs(h - m) < s && Math.abs(p - f) < s) {
            if (Math.abs(c + u) < a && Math.abs(h + m) < a && Math.abs(p + f) < a && Math.abs(l + d + g - 3) < a)
                return this.set(1, 0, 0, 0),
                this;
            t = Math.PI;
            const e = (l + 1) / 2
              , o = (d + 1) / 2
              , v = (g + 1) / 2
              , x = (c + u) / 4
              , y = (h + m) / 4
              , _ = (p + f) / 4;
            return e > o && e > v ? e < s ? (n = 0,
            i = .707106781,
            r = .707106781) : (n = Math.sqrt(e),
            i = x / n,
            r = y / n) : o > v ? o < s ? (n = .707106781,
            i = 0,
            r = .707106781) : (i = Math.sqrt(o),
            n = x / i,
            r = _ / i) : v < s ? (n = .707106781,
            i = .707106781,
            r = 0) : (r = Math.sqrt(v),
            n = y / r,
            i = _ / r),
            this.set(n, i, r, t),
            this
        }
        let v = Math.sqrt((f - p) * (f - p) + (h - m) * (h - m) + (u - c) * (u - c));
        return Math.abs(v) < .001 && (v = 1),
        this.x = (f - p) / v,
        this.y = (h - m) / v,
        this.z = (u - c) / v,
        this.w = Math.acos((l + d + g - 1) / 2),
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this.w = Math.min(this.w, e.w),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this.w = Math.max(this.w, e.w),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this.z = Math.max(e.z, Math.min(t.z, this.z)),
        this.w = Math.max(e.w, Math.min(t.w, this.w)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this.z = Math.max(e, Math.min(t, this.z)),
        this.w = Math.max(e, Math.min(t, this.w)),
        this
    }
    clampLength(e, t) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this.w = Math.floor(this.w),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this.w = Math.ceil(this.w),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this.w = Math.round(this.w),
        this
    }
    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
        this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this.w = -this.w,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this.w += (e.w - this.w) * t,
        this
    }
    lerpVectors(e, t, n) {
        return this.x = e.x + (t.x - e.x) * n,
        this.y = e.y + (t.y - e.y) * n,
        this.z = e.z + (t.z - e.z) * n,
        this.w = e.w + (t.w - e.w) * n,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this.w = e[t + 3],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e[t + 3] = this.w,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this.w = e.getW(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this.w = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z,
        yield this.w
    }
}
class cn extends wt {
    constructor(e, t, n={}) {
        super(),
        this.isWebGLRenderTarget = !0,
        this.width = e,
        this.height = t,
        this.depth = 1,
        this.scissor = new ln(0,0,e,t),
        this.scissorTest = !1,
        this.viewport = new ln(0,0,e,t);
        const i = {
            width: e,
            height: t,
            depth: 1
        };
        this.texture = new on(i,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),
        this.texture.isRenderTargetTexture = !0,
        this.texture.flipY = !1,
        this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps,
        this.texture.internalFormat = void 0 !== n.internalFormat ? n.internalFormat : null,
        this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : we,
        this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer,
        this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer,
        this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null,
        this.samples = void 0 !== n.samples ? n.samples : 0
    }
    setSize(e, t, n=1) {
        this.width === e && this.height === t && this.depth === n || (this.width = e,
        this.height = t,
        this.depth = n,
        this.texture.image.width = e,
        this.texture.image.height = t,
        this.texture.image.depth = n,
        this.dispose()),
        this.viewport.set(0, 0, e, t),
        this.scissor.set(0, 0, e, t)
    }
    clone() {
        return (new this.constructor).copy(this)
    }
    copy(e) {
        this.width = e.width,
        this.height = e.height,
        this.depth = e.depth,
        this.viewport.copy(e.viewport),
        this.texture = e.texture.clone(),
        this.texture.isRenderTargetTexture = !0;
        const t = Object.assign({}, e.texture.image);
        return this.texture.source = new rn(t),
        this.depthBuffer = e.depthBuffer,
        this.stencilBuffer = e.stencilBuffer,
        null !== e.depthTexture && (this.depthTexture = e.depthTexture.clone()),
        this.samples = e.samples,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
class hn extends on {
    constructor(e=null, t=1, n=1, i=1) {
        super(null),
        this.isDataArrayTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: n,
            depth: i
        },
        this.magFilter = _e,
        this.minFilter = _e,
        this.wrapR = xe,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
class un extends on {
    constructor(e=null, t=1, n=1, i=1) {
        super(null),
        this.isData3DTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: n,
            depth: i
        },
        this.magFilter = _e,
        this.minFilter = _e,
        this.wrapR = xe,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
class dn {
    constructor(e=0, t=0, n=0, i=1) {
        this.isQuaternion = !0,
        this._x = e,
        this._y = t,
        this._z = n,
        this._w = i
    }
    static slerpFlat(e, t, n, i, r, s, a) {
        let o = n[i + 0]
          , l = n[i + 1]
          , c = n[i + 2]
          , h = n[i + 3];
        const u = r[s + 0]
          , d = r[s + 1]
          , p = r[s + 2]
          , m = r[s + 3];
        if (0 === a)
            return e[t + 0] = o,
            e[t + 1] = l,
            e[t + 2] = c,
            void (e[t + 3] = h);
        if (1 === a)
            return e[t + 0] = u,
            e[t + 1] = d,
            e[t + 2] = p,
            void (e[t + 3] = m);
        if (h !== m || o !== u || l !== d || c !== p) {
            let e = 1 - a;
            const t = o * u + l * d + c * p + h * m
              , n = t >= 0 ? 1 : -1
              , i = 1 - t * t;
            if (i > Number.EPSILON) {
                const r = Math.sqrt(i)
                  , s = Math.atan2(r, t * n);
                e = Math.sin(e * s) / r,
                a = Math.sin(a * s) / r
            }
            const r = a * n;
            if (o = o * e + u * r,
            l = l * e + d * r,
            c = c * e + p * r,
            h = h * e + m * r,
            e === 1 - a) {
                const e = 1 / Math.sqrt(o * o + l * l + c * c + h * h);
                o *= e,
                l *= e,
                c *= e,
                h *= e
            }
        }
        e[t] = o,
        e[t + 1] = l,
        e[t + 2] = c,
        e[t + 3] = h
    }
    static multiplyQuaternionsFlat(e, t, n, i, r, s) {
        const a = n[i]
          , o = n[i + 1]
          , l = n[i + 2]
          , c = n[i + 3]
          , h = r[s]
          , u = r[s + 1]
          , d = r[s + 2]
          , p = r[s + 3];
        return e[t] = a * p + c * h + o * d - l * u,
        e[t + 1] = o * p + c * u + l * h - a * d,
        e[t + 2] = l * p + c * d + a * u - o * h,
        e[t + 3] = c * p - a * h - o * u - l * d,
        e
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get w() {
        return this._w
    }
    set w(e) {
        this._w = e,
        this._onChangeCallback()
    }
    set(e, t, n, i) {
        return this._x = e,
        this._y = t,
        this._z = n,
        this._w = i,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._w)
    }
    copy(e) {
        return this._x = e.x,
        this._y = e.y,
        this._z = e.z,
        this._w = e.w,
        this._onChangeCallback(),
        this
    }
    setFromEuler(e, t) {
        const n = e._x
          , i = e._y
          , r = e._z
          , s = e._order
          , a = Math.cos
          , o = Math.sin
          , l = a(n / 2)
          , c = a(i / 2)
          , h = a(r / 2)
          , u = o(n / 2)
          , d = o(i / 2)
          , p = o(r / 2);
        switch (s) {
        case "XYZ":
            this._x = u * c * h + l * d * p,
            this._y = l * d * h - u * c * p,
            this._z = l * c * p + u * d * h,
            this._w = l * c * h - u * d * p;
            break;
        case "YXZ":
            this._x = u * c * h + l * d * p,
            this._y = l * d * h - u * c * p,
            this._z = l * c * p - u * d * h,
            this._w = l * c * h + u * d * p;
            break;
        case "ZXY":
            this._x = u * c * h - l * d * p,
            this._y = l * d * h + u * c * p,
            this._z = l * c * p + u * d * h,
            this._w = l * c * h - u * d * p;
            break;
        case "ZYX":
            this._x = u * c * h - l * d * p,
            this._y = l * d * h + u * c * p,
            this._z = l * c * p - u * d * h,
            this._w = l * c * h + u * d * p;
            break;
        case "YZX":
            this._x = u * c * h + l * d * p,
            this._y = l * d * h + u * c * p,
            this._z = l * c * p - u * d * h,
            this._w = l * c * h - u * d * p;
            break;
        case "XZY":
            this._x = u * c * h - l * d * p,
            this._y = l * d * h - u * c * p,
            this._z = l * c * p + u * d * h,
            this._w = l * c * h + u * d * p;
            break;
        default:
            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s)
        }
        return !1 !== t && this._onChangeCallback(),
        this
    }
    setFromAxisAngle(e, t) {
        const n = t / 2
          , i = Math.sin(n);
        return this._x = e.x * i,
        this._y = e.y * i,
        this._z = e.z * i,
        this._w = Math.cos(n),
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e) {
        const t = e.elements
          , n = t[0]
          , i = t[4]
          , r = t[8]
          , s = t[1]
          , a = t[5]
          , o = t[9]
          , l = t[2]
          , c = t[6]
          , h = t[10]
          , u = n + a + h;
        if (u > 0) {
            const e = .5 / Math.sqrt(u + 1);
            this._w = .25 / e,
            this._x = (c - o) * e,
            this._y = (r - l) * e,
            this._z = (s - i) * e
        } else if (n > a && n > h) {
            const e = 2 * Math.sqrt(1 + n - a - h);
            this._w = (c - o) / e,
            this._x = .25 * e,
            this._y = (i + s) / e,
            this._z = (r + l) / e
        } else if (a > h) {
            const e = 2 * Math.sqrt(1 + a - n - h);
            this._w = (r - l) / e,
            this._x = (i + s) / e,
            this._y = .25 * e,
            this._z = (o + c) / e
        } else {
            const e = 2 * Math.sqrt(1 + h - n - a);
            this._w = (s - i) / e,
            this._x = (r + l) / e,
            this._y = (o + c) / e,
            this._z = .25 * e
        }
        return this._onChangeCallback(),
        this
    }
    setFromUnitVectors(e, t) {
        let n = e.dot(t) + 1;
        return n < Number.EPSILON ? (n = 0,
        Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
        this._y = e.x,
        this._z = 0,
        this._w = n) : (this._x = 0,
        this._y = -e.z,
        this._z = e.y,
        this._w = n)) : (this._x = e.y * t.z - e.z * t.y,
        this._y = e.z * t.x - e.x * t.z,
        this._z = e.x * t.y - e.y * t.x,
        this._w = n),
        this.normalize()
    }
    angleTo(e) {
        return 2 * Math.acos(Math.abs(Lt(this.dot(e), -1, 1)))
    }
    rotateTowards(e, t) {
        const n = this.angleTo(e);
        if (0 === n)
            return this;
        const i = Math.min(1, t / n);
        return this.slerp(e, i),
        this
    }
    identity() {
        return this.set(0, 0, 0, 1)
    }
    invert() {
        return this.conjugate()
    }
    conjugate() {
        return this._x *= -1,
        this._y *= -1,
        this._z *= -1,
        this._onChangeCallback(),
        this
    }
    dot(e) {
        return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    }
    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    }
    normalize() {
        let e = this.length();
        return 0 === e ? (this._x = 0,
        this._y = 0,
        this._z = 0,
        this._w = 1) : (e = 1 / e,
        this._x = this._x * e,
        this._y = this._y * e,
        this._z = this._z * e,
        this._w = this._w * e),
        this._onChangeCallback(),
        this
    }
    multiply(e) {
        return this.multiplyQuaternions(this, e)
    }
    premultiply(e) {
        return this.multiplyQuaternions(e, this)
    }
    multiplyQuaternions(e, t) {
        const n = e._x
          , i = e._y
          , r = e._z
          , s = e._w
          , a = t._x
          , o = t._y
          , l = t._z
          , c = t._w;
        return this._x = n * c + s * a + i * l - r * o,
        this._y = i * c + s * o + r * a - n * l,
        this._z = r * c + s * l + n * o - i * a,
        this._w = s * c - n * a - i * o - r * l,
        this._onChangeCallback(),
        this
    }
    slerp(e, t) {
        if (0 === t)
            return this;
        if (1 === t)
            return this.copy(e);
        const n = this._x
          , i = this._y
          , r = this._z
          , s = this._w;
        let a = s * e._w + n * e._x + i * e._y + r * e._z;
        if (a < 0 ? (this._w = -e._w,
        this._x = -e._x,
        this._y = -e._y,
        this._z = -e._z,
        a = -a) : this.copy(e),
        a >= 1)
            return this._w = s,
            this._x = n,
            this._y = i,
            this._z = r,
            this;
        const o = 1 - a * a;
        if (o <= Number.EPSILON) {
            const e = 1 - t;
            return this._w = e * s + t * this._w,
            this._x = e * n + t * this._x,
            this._y = e * i + t * this._y,
            this._z = e * r + t * this._z,
            this.normalize(),
            this._onChangeCallback(),
            this
        }
        const l = Math.sqrt(o)
          , c = Math.atan2(l, a)
          , h = Math.sin((1 - t) * c) / l
          , u = Math.sin(t * c) / l;
        return this._w = s * h + this._w * u,
        this._x = n * h + this._x * u,
        this._y = i * h + this._y * u,
        this._z = r * h + this._z * u,
        this._onChangeCallback(),
        this
    }
    slerpQuaternions(e, t, n) {
        return this.copy(e).slerp(t, n)
    }
    random() {
        const e = Math.random()
          , t = Math.sqrt(1 - e)
          , n = Math.sqrt(e)
          , i = 2 * Math.PI * Math.random()
          , r = 2 * Math.PI * Math.random();
        return this.set(t * Math.cos(i), n * Math.sin(r), n * Math.cos(r), t * Math.sin(i))
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
    }
    fromArray(e, t=0) {
        return this._x = e[t],
        this._y = e[t + 1],
        this._z = e[t + 2],
        this._w = e[t + 3],
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._w,
        e
    }
    fromBufferAttribute(e, t) {
        return this._x = e.getX(t),
        this._y = e.getY(t),
        this._z = e.getZ(t),
        this._w = e.getW(t),
        this
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._w
    }
}
class pn {
    constructor(e=0, t=0, n=0) {
        pn.prototype.isVector3 = !0,
        this.x = e,
        this.y = t,
        this.z = n
    }
    set(e, t, n) {
        return void 0 === n && (n = this.z),
        this.x = e,
        this.y = t,
        this.z = n,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this
    }
    multiplyVectors(e, t) {
        return this.x = e.x * t.x,
        this.y = e.y * t.y,
        this.z = e.z * t.z,
        this
    }
    applyEuler(e) {
        return this.applyQuaternion(fn.setFromEuler(e))
    }
    applyAxisAngle(e, t) {
        return this.applyQuaternion(fn.setFromAxisAngle(e, t))
    }
    applyMatrix3(e) {
        const t = this.x
          , n = this.y
          , i = this.z
          , r = e.elements;
        return this.x = r[0] * t + r[3] * n + r[6] * i,
        this.y = r[1] * t + r[4] * n + r[7] * i,
        this.z = r[2] * t + r[5] * n + r[8] * i,
        this
    }
    applyNormalMatrix(e) {
        return this.applyMatrix3(e).normalize()
    }
    applyMatrix4(e) {
        const t = this.x
          , n = this.y
          , i = this.z
          , r = e.elements
          , s = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
        return this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * s,
        this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * s,
        this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * s,
        this
    }
    applyQuaternion(e) {
        const t = this.x
          , n = this.y
          , i = this.z
          , r = e.x
          , s = e.y
          , a = e.z
          , o = e.w
          , l = o * t + s * i - a * n
          , c = o * n + a * t - r * i
          , h = o * i + r * n - s * t
          , u = -r * t - s * n - a * i;
        return this.x = l * o + u * -r + c * -a - h * -s,
        this.y = c * o + u * -s + h * -r - l * -a,
        this.z = h * o + u * -a + l * -s - c * -r,
        this
    }
    project(e) {
        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
    }
    unproject(e) {
        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
    }
    transformDirection(e) {
        const t = this.x
          , n = this.y
          , i = this.z
          , r = e.elements;
        return this.x = r[0] * t + r[4] * n + r[8] * i,
        this.y = r[1] * t + r[5] * n + r[9] * i,
        this.z = r[2] * t + r[6] * n + r[10] * i,
        this.normalize()
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this.z /= e.z,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this.z = Math.max(e.z, Math.min(t.z, this.z)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this.z = Math.max(e, Math.min(t, this.z)),
        this
    }
    clampLength(e, t) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this
    }
    roundToZero() {
        return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this
    }
    lerpVectors(e, t, n) {
        return this.x = e.x + (t.x - e.x) * n,
        this.y = e.y + (t.y - e.y) * n,
        this.z = e.z + (t.z - e.z) * n,
        this
    }
    cross(e) {
        return this.crossVectors(this, e)
    }
    crossVectors(e, t) {
        const n = e.x
          , i = e.y
          , r = e.z
          , s = t.x
          , a = t.y
          , o = t.z;
        return this.x = i * o - r * a,
        this.y = r * s - n * o,
        this.z = n * a - i * s,
        this
    }
    projectOnVector(e) {
        const t = e.lengthSq();
        if (0 === t)
            return this.set(0, 0, 0);
        const n = e.dot(this) / t;
        return this.copy(e).multiplyScalar(n)
    }
    projectOnPlane(e) {
        return mn.copy(this).projectOnVector(e),
        this.sub(mn)
    }
    reflect(e) {
        return this.sub(mn.copy(e).multiplyScalar(2 * this.dot(e)))
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (0 === t)
            return Math.PI / 2;
        const n = this.dot(e) / t;
        return Math.acos(Lt(n, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x
          , n = this.y - e.y
          , i = this.z - e.z;
        return t * t + n * n + i * i
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    }
    setFromSpherical(e) {
        return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
    }
    setFromSphericalCoords(e, t, n) {
        const i = Math.sin(t) * e;
        return this.x = i * Math.sin(n),
        this.y = Math.cos(t) * e,
        this.z = i * Math.cos(n),
        this
    }
    setFromCylindrical(e) {
        return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
    }
    setFromCylindricalCoords(e, t, n) {
        return this.x = e * Math.sin(t),
        this.y = n,
        this.z = e * Math.cos(t),
        this
    }
    setFromMatrixPosition(e) {
        const t = e.elements;
        return this.x = t[12],
        this.y = t[13],
        this.z = t[14],
        this
    }
    setFromMatrixScale(e) {
        const t = this.setFromMatrixColumn(e, 0).length()
          , n = this.setFromMatrixColumn(e, 1).length()
          , i = this.setFromMatrixColumn(e, 2).length();
        return this.x = t,
        this.y = n,
        this.z = i,
        this
    }
    setFromMatrixColumn(e, t) {
        return this.fromArray(e.elements, 4 * t)
    }
    setFromMatrix3Column(e, t) {
        return this.fromArray(e.elements, 3 * t)
    }
    setFromEuler(e) {
        return this.x = e._x,
        this.y = e._y,
        this.z = e._z,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this
    }
    randomDirection() {
        const e = 2 * (Math.random() - .5)
          , t = Math.random() * Math.PI * 2
          , n = Math.sqrt(1 - e ** 2);
        return this.x = n * Math.cos(t),
        this.y = n * Math.sin(t),
        this.z = e,
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z
    }
}
const mn = new pn
  , fn = new dn;
class gn {
    constructor(e=new pn(Infinity,Infinity,Infinity), t=new pn(-Infinity,-Infinity,-Infinity)) {
        this.isBox3 = !0,
        this.min = e,
        this.max = t
    }
    set(e, t) {
        return this.min.copy(e),
        this.max.copy(t),
        this
    }
    setFromArray(e) {
        let t = Infinity
          , n = Infinity
          , i = Infinity
          , r = -Infinity
          , s = -Infinity
          , a = -Infinity;
        for (let o = 0, l = e.length; o < l; o += 3) {
            const l = e[o]
              , c = e[o + 1]
              , h = e[o + 2];
            l < t && (t = l),
            c < n && (n = c),
            h < i && (i = h),
            l > r && (r = l),
            c > s && (s = c),
            h > a && (a = h)
        }
        return this.min.set(t, n, i),
        this.max.set(r, s, a),
        this
    }
    setFromBufferAttribute(e) {
        let t = Infinity
          , n = Infinity
          , i = Infinity
          , r = -Infinity
          , s = -Infinity
          , a = -Infinity;
        for (let o = 0, l = e.count; o < l; o++) {
            const l = e.getX(o)
              , c = e.getY(o)
              , h = e.getZ(o);
            l < t && (t = l),
            c < n && (n = c),
            h < i && (i = h),
            l > r && (r = l),
            c > s && (s = c),
            h > a && (a = h)
        }
        return this.min.set(t, n, i),
        this.max.set(r, s, a),
        this
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, n = e.length; t < n; t++)
            this.expandByPoint(e[t]);
        return this
    }
    setFromCenterAndSize(e, t) {
        const n = xn.copy(t).multiplyScalar(.5);
        return this.min.copy(e).sub(n),
        this.max.copy(e).add(n),
        this
    }
    setFromObject(e, t=!1) {
        return this.makeEmpty(),
        this.expandByObject(e, t)
    }
    clone() {
        return (new this.constructor).copy(this)
    }
    copy(e) {
        return this.min.copy(e.min),
        this.max.copy(e.max),
        this
    }
    makeEmpty() {
        return this.min.x = this.min.y = this.min.z = Infinity,
        this.max.x = this.max.y = this.max.z = -Infinity,
        this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e) {
        return this.min.min(e),
        this.max.max(e),
        this
    }
    expandByVector(e) {
        return this.min.sub(e),
        this.max.add(e),
        this
    }
    expandByScalar(e) {
        return this.min.addScalar(-e),
        this.max.addScalar(e),
        this
    }
    expandByObject(e, t=!1) {
        e.updateWorldMatrix(!1, !1);
        const n = e.geometry;
        if (void 0 !== n)
            if (t && null != n.attributes && void 0 !== n.attributes.position) {
                const t = n.attributes.position;
                for (let n = 0, i = t.count; n < i; n++)
                    xn.fromBufferAttribute(t, n).applyMatrix4(e.matrixWorld),
                    this.expandByPoint(xn)
            } else
                null === n.boundingBox && n.computeBoundingBox(),
                yn.copy(n.boundingBox),
                yn.applyMatrix4(e.matrixWorld),
                this.union(yn);
        const i = e.children;
        for (let e = 0, n = i.length; e < n; e++)
            this.expandByObject(i[e], t);
        return this
    }
    containsPoint(e) {
        return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
    }
    getParameter(e, t) {
        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
    }
    intersectsBox(e) {
        return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
    }
    intersectsSphere(e) {
        return this.clampPoint(e.center, xn),
        xn.distanceToSquared(e.center) <= e.radius * e.radius
    }
    intersectsPlane(e) {
        let t, n;
        return e.normal.x > 0 ? (t = e.normal.x * this.min.x,
        n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x,
        n = e.normal.x * this.min.x),
        e.normal.y > 0 ? (t += e.normal.y * this.min.y,
        n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y,
        n += e.normal.y * this.min.y),
        e.normal.z > 0 ? (t += e.normal.z * this.min.z,
        n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z,
        n += e.normal.z * this.min.z),
        t <= -e.constant && n >= -e.constant
    }
    intersectsTriangle(e) {
        if (this.isEmpty())
            return !1;
        this.getCenter(An),
        En.subVectors(this.max, An),
        _n.subVectors(e.a, An),
        bn.subVectors(e.b, An),
        Mn.subVectors(e.c, An),
        wn.subVectors(bn, _n),
        Sn.subVectors(Mn, bn),
        Tn.subVectors(_n, Mn);
        let t = [0, -wn.z, wn.y, 0, -Sn.z, Sn.y, 0, -Tn.z, Tn.y, wn.z, 0, -wn.x, Sn.z, 0, -Sn.x, Tn.z, 0, -Tn.x, -wn.y, wn.x, 0, -Sn.y, Sn.x, 0, -Tn.y, Tn.x, 0];
        return !!Rn(t, _n, bn, Mn, En) && (t = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        !!Rn(t, _n, bn, Mn, En) && (Cn.crossVectors(wn, Sn),
        t = [Cn.x, Cn.y, Cn.z],
        Rn(t, _n, bn, Mn, En)))
    }
    clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e) {
        return xn.copy(e).clamp(this.min, this.max).sub(e).length()
    }
    getBoundingSphere(e) {
        return this.getCenter(e.center),
        e.radius = .5 * this.getSize(xn).length(),
        e
    }
    intersect(e) {
        return this.min.max(e.min),
        this.max.min(e.max),
        this.isEmpty() && this.makeEmpty(),
        this
    }
    union(e) {
        return this.min.min(e.min),
        this.max.max(e.max),
        this
    }
    applyMatrix4(e) {
        return this.isEmpty() || (vn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        vn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        vn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        vn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        vn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        vn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        vn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        vn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(vn)),
        this
    }
    translate(e) {
        return this.min.add(e),
        this.max.add(e),
        this
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
}
const vn = [new pn, new pn, new pn, new pn, new pn, new pn, new pn, new pn]
  , xn = new pn
  , yn = new gn
  , _n = new pn
  , bn = new pn
  , Mn = new pn
  , wn = new pn
  , Sn = new pn
  , Tn = new pn
  , An = new pn
  , En = new pn
  , Cn = new pn
  , Ln = new pn;
function Rn(e, t, n, i, r) {
    for (let s = 0, a = e.length - 3; s <= a; s += 3) {
        Ln.fromArray(e, s);
        const a = r.x * Math.abs(Ln.x) + r.y * Math.abs(Ln.y) + r.z * Math.abs(Ln.z)
          , o = t.dot(Ln)
          , l = n.dot(Ln)
          , c = i.dot(Ln);
        if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > a)
            return !1
    }
    return !0
}
const Pn = new gn
  , In = new pn
  , Dn = new pn
  , On = new pn;
class Nn {
    constructor(e=new pn, t=-1) {
        this.center = e,
        this.radius = t
    }
    set(e, t) {
        return this.center.copy(e),
        this.radius = t,
        this
    }
    setFromPoints(e, t) {
        const n = this.center;
        void 0 !== t ? n.copy(t) : Pn.setFromPoints(e).getCenter(n);
        let i = 0;
        for (let t = 0, r = e.length; t < r; t++)
            i = Math.max(i, n.distanceToSquared(e[t]));
        return this.radius = Math.sqrt(i),
        this
    }
    copy(e) {
        return this.center.copy(e.center),
        this.radius = e.radius,
        this
    }
    isEmpty() {
        return this.radius < 0
    }
    makeEmpty() {
        return this.center.set(0, 0, 0),
        this.radius = -1,
        this
    }
    containsPoint(e) {
        return e.distanceToSquared(this.center) <= this.radius * this.radius
    }
    distanceToPoint(e) {
        return e.distanceTo(this.center) - this.radius
    }
    intersectsSphere(e) {
        const t = this.radius + e.radius;
        return e.center.distanceToSquared(this.center) <= t * t
    }
    intersectsBox(e) {
        return e.intersectsSphere(this)
    }
    intersectsPlane(e) {
        return Math.abs(e.distanceToPoint(this.center)) <= this.radius
    }
    clampPoint(e, t) {
        const n = this.center.distanceToSquared(e);
        return t.copy(e),
        n > this.radius * this.radius && (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
        t
    }
    getBoundingBox(e) {
        return this.isEmpty() ? (e.makeEmpty(),
        e) : (e.set(this.center, this.center),
        e.expandByScalar(this.radius),
        e)
    }
    applyMatrix4(e) {
        return this.center.applyMatrix4(e),
        this.radius = this.radius * e.getMaxScaleOnAxis(),
        this
    }
    translate(e) {
        return this.center.add(e),
        this
    }
    expandByPoint(e) {
        On.subVectors(e, this.center);
        const t = On.lengthSq();
        if (t > this.radius * this.radius) {
            const e = Math.sqrt(t)
              , n = .5 * (e - this.radius);
            this.center.add(On.multiplyScalar(n / e)),
            this.radius += n
        }
        return this
    }
    union(e) {
        return !0 === this.center.equals(e.center) ? Dn.set(0, 0, 1).multiplyScalar(e.radius) : Dn.subVectors(e.center, this.center).normalize().multiplyScalar(e.radius),
        this.expandByPoint(In.copy(e.center).add(Dn)),
        this.expandByPoint(In.copy(e.center).sub(Dn)),
        this
    }
    equals(e) {
        return e.center.equals(this.center) && e.radius === this.radius
    }
    clone() {
        return (new this.constructor).copy(this)
    }
}
const zn = new pn
  , Un = new pn
  , Fn = new pn
  , Bn = new pn
  , kn = new pn
  , Gn = new pn
  , Hn = new pn;
class Vn {
    constructor(e=new pn, t=new pn(0,0,-1)) {
        this.origin = e,
        this.direction = t
    }
    set(e, t) {
        return this.origin.copy(e),
        this.direction.copy(t),
        this
    }
    copy(e) {
        return this.origin.copy(e.origin),
        this.direction.copy(e.direction),
        this
    }
    at(e, t) {
        return t.copy(this.direction).multiplyScalar(e).add(this.origin)
    }
    lookAt(e) {
        return this.direction.copy(e).sub(this.origin).normalize(),
        this
    }
    recast(e) {
        return this.origin.copy(this.at(e, zn)),
        this
    }
    closestPointToPoint(e, t) {
        t.subVectors(e, this.origin);
        const n = t.dot(this.direction);
        return n < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(n).add(this.origin)
    }
    distanceToPoint(e) {
        return Math.sqrt(this.distanceSqToPoint(e))
    }
    distanceSqToPoint(e) {
        const t = zn.subVectors(e, this.origin).dot(this.direction);
        return t < 0 ? this.origin.distanceToSquared(e) : (zn.copy(this.direction).multiplyScalar(t).add(this.origin),
        zn.distanceToSquared(e))
    }
    distanceSqToSegment(e, t, n, i) {
        Un.copy(e).add(t).multiplyScalar(.5),
        Fn.copy(t).sub(e).normalize(),
        Bn.copy(this.origin).sub(Un);
        const r = .5 * e.distanceTo(t)
          , s = -this.direction.dot(Fn)
          , a = Bn.dot(this.direction)
          , o = -Bn.dot(Fn)
          , l = Bn.lengthSq()
          , c = Math.abs(1 - s * s);
        let h, u, d, p;
        if (c > 0)
            if (h = s * o - a,
            u = s * a - o,
            p = r * c,
            h >= 0)
                if (u >= -p)
                    if (u <= p) {
                        const e = 1 / c;
                        h *= e,
                        u *= e,
                        d = h * (h + s * u + 2 * a) + u * (s * h + u + 2 * o) + l
                    } else
                        u = r,
                        h = Math.max(0, -(s * u + a)),
                        d = -h * h + u * (u + 2 * o) + l;
                else
                    u = -r,
                    h = Math.max(0, -(s * u + a)),
                    d = -h * h + u * (u + 2 * o) + l;
            else
                u <= -p ? (h = Math.max(0, -(-s * r + a)),
                u = h > 0 ? -r : Math.min(Math.max(-r, -o), r),
                d = -h * h + u * (u + 2 * o) + l) : u <= p ? (h = 0,
                u = Math.min(Math.max(-r, -o), r),
                d = u * (u + 2 * o) + l) : (h = Math.max(0, -(s * r + a)),
                u = h > 0 ? r : Math.min(Math.max(-r, -o), r),
                d = -h * h + u * (u + 2 * o) + l);
        else
            u = s > 0 ? -r : r,
            h = Math.max(0, -(s * u + a)),
            d = -h * h + u * (u + 2 * o) + l;
        return n && n.copy(this.direction).multiplyScalar(h).add(this.origin),
        i && i.copy(Fn).multiplyScalar(u).add(Un),
        d
    }
    intersectSphere(e, t) {
        zn.subVectors(e.center, this.origin);
        const n = zn.dot(this.direction)
          , i = zn.dot(zn) - n * n
          , r = e.radius * e.radius;
        if (i > r)
            return null;
        const s = Math.sqrt(r - i)
          , a = n - s
          , o = n + s;
        return a < 0 && o < 0 ? null : a < 0 ? this.at(o, t) : this.at(a, t)
    }
    intersectsSphere(e) {
        return this.distanceSqToPoint(e.center) <= e.radius * e.radius
    }
    distanceToPlane(e) {
        const t = e.normal.dot(this.direction);
        if (0 === t)
            return 0 === e.distanceToPoint(this.origin) ? 0 : null;
        const n = -(this.origin.dot(e.normal) + e.constant) / t;
        return n >= 0 ? n : null
    }
    intersectPlane(e, t) {
        const n = this.distanceToPlane(e);
        return null === n ? null : this.at(n, t)
    }
    intersectsPlane(e) {
        const t = e.distanceToPoint(this.origin);
        if (0 === t)
            return !0;
        return e.normal.dot(this.direction) * t < 0
    }
    intersectBox(e, t) {
        let n, i, r, s, a, o;
        const l = 1 / this.direction.x
          , c = 1 / this.direction.y
          , h = 1 / this.direction.z
          , u = this.origin;
        return l >= 0 ? (n = (e.min.x - u.x) * l,
        i = (e.max.x - u.x) * l) : (n = (e.max.x - u.x) * l,
        i = (e.min.x - u.x) * l),
        c >= 0 ? (r = (e.min.y - u.y) * c,
        s = (e.max.y - u.y) * c) : (r = (e.max.y - u.y) * c,
        s = (e.min.y - u.y) * c),
        n > s || r > i ? null : ((r > n || n != n) && (n = r),
        (s < i || i != i) && (i = s),
        h >= 0 ? (a = (e.min.z - u.z) * h,
        o = (e.max.z - u.z) * h) : (a = (e.max.z - u.z) * h,
        o = (e.min.z - u.z) * h),
        n > o || a > i ? null : ((a > n || n != n) && (n = a),
        (o < i || i != i) && (i = o),
        i < 0 ? null : this.at(n >= 0 ? n : i, t)))
    }
    intersectsBox(e) {
        return null !== this.intersectBox(e, zn)
    }
    intersectTriangle(e, t, n, i, r) {
        kn.subVectors(t, e),
        Gn.subVectors(n, e),
        Hn.crossVectors(kn, Gn);
        let s, a = this.direction.dot(Hn);
        if (a > 0) {
            if (i)
                return null;
            s = 1
        } else {
            if (!(a < 0))
                return null;
            s = -1,
            a = -a
        }
        Bn.subVectors(this.origin, e);
        const o = s * this.direction.dot(Gn.crossVectors(Bn, Gn));
        if (o < 0)
            return null;
        const l = s * this.direction.dot(kn.cross(Bn));
        if (l < 0)
            return null;
        if (o + l > a)
            return null;
        const c = -s * Bn.dot(Hn);
        return c < 0 ? null : this.at(c / a, r)
    }
    applyMatrix4(e) {
        return this.origin.applyMatrix4(e),
        this.direction.transformDirection(e),
        this
    }
    equals(e) {
        return e.origin.equals(this.origin) && e.direction.equals(this.direction)
    }
    clone() {
        return (new this.constructor).copy(this)
    }
}
class Wn {
    constructor() {
        Wn.prototype.isMatrix4 = !0,
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
    }
    set(e, t, n, i, r, s, a, o, l, c, h, u, d, p, m, f) {
        const g = this.elements;
        return g[0] = e,
        g[4] = t,
        g[8] = n,
        g[12] = i,
        g[1] = r,
        g[5] = s,
        g[9] = a,
        g[13] = o,
        g[2] = l,
        g[6] = c,
        g[10] = h,
        g[14] = u,
        g[3] = d,
        g[7] = p,
        g[11] = m,
        g[15] = f,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    clone() {
        return (new Wn).fromArray(this.elements)
    }
    copy(e) {
        const t = this.elements
          , n = e.elements;
        return t[0] = n[0],
        t[1] = n[1],
        t[2] = n[2],
        t[3] = n[3],
        t[4] = n[4],
        t[5] = n[5],
        t[6] = n[6],
        t[7] = n[7],
        t[8] = n[8],
        t[9] = n[9],
        t[10] = n[10],
        t[11] = n[11],
        t[12] = n[12],
        t[13] = n[13],
        t[14] = n[14],
        t[15] = n[15],
        this
    }
    copyPosition(e) {
        const t = this.elements
          , n = e.elements;
        return t[12] = n[12],
        t[13] = n[13],
        t[14] = n[14],
        this
    }
    setFromMatrix3(e) {
        const t = e.elements;
        return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1),
        this
    }
    extractBasis(e, t, n) {
        return e.setFromMatrixColumn(this, 0),
        t.setFromMatrixColumn(this, 1),
        n.setFromMatrixColumn(this, 2),
        this
    }
    makeBasis(e, t, n) {
        return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1),
        this
    }
    extractRotation(e) {
        const t = this.elements
          , n = e.elements
          , i = 1 / jn.setFromMatrixColumn(e, 0).length()
          , r = 1 / jn.setFromMatrixColumn(e, 1).length()
          , s = 1 / jn.setFromMatrixColumn(e, 2).length();
        return t[0] = n[0] * i,
        t[1] = n[1] * i,
        t[2] = n[2] * i,
        t[3] = 0,
        t[4] = n[4] * r,
        t[5] = n[5] * r,
        t[6] = n[6] * r,
        t[7] = 0,
        t[8] = n[8] * s,
        t[9] = n[9] * s,
        t[10] = n[10] * s,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromEuler(e) {
        const t = this.elements
          , n = e.x
          , i = e.y
          , r = e.z
          , s = Math.cos(n)
          , a = Math.sin(n)
          , o = Math.cos(i)
          , l = Math.sin(i)
          , c = Math.cos(r)
          , h = Math.sin(r);
        if ("XYZ" === e.order) {
            const e = s * c
              , n = s * h
              , i = a * c
              , r = a * h;
            t[0] = o * c,
            t[4] = -o * h,
            t[8] = l,
            t[1] = n + i * l,
            t[5] = e - r * l,
            t[9] = -a * o,
            t[2] = r - e * l,
            t[6] = i + n * l,
            t[10] = s * o
        } else if ("YXZ" === e.order) {
            const e = o * c
              , n = o * h
              , i = l * c
              , r = l * h;
            t[0] = e + r * a,
            t[4] = i * a - n,
            t[8] = s * l,
            t[1] = s * h,
            t[5] = s * c,
            t[9] = -a,
            t[2] = n * a - i,
            t[6] = r + e * a,
            t[10] = s * o
        } else if ("ZXY" === e.order) {
            const e = o * c
              , n = o * h
              , i = l * c
              , r = l * h;
            t[0] = e - r * a,
            t[4] = -s * h,
            t[8] = i + n * a,
            t[1] = n + i * a,
            t[5] = s * c,
            t[9] = r - e * a,
            t[2] = -s * l,
            t[6] = a,
            t[10] = s * o
        } else if ("ZYX" === e.order) {
            const e = s * c
              , n = s * h
              , i = a * c
              , r = a * h;
            t[0] = o * c,
            t[4] = i * l - n,
            t[8] = e * l + r,
            t[1] = o * h,
            t[5] = r * l + e,
            t[9] = n * l - i,
            t[2] = -l,
            t[6] = a * o,
            t[10] = s * o
        } else if ("YZX" === e.order) {
            const e = s * o
              , n = s * l
              , i = a * o
              , r = a * l;
            t[0] = o * c,
            t[4] = r - e * h,
            t[8] = i * h + n,
            t[1] = h,
            t[5] = s * c,
            t[9] = -a * c,
            t[2] = -l * c,
            t[6] = n * h + i,
            t[10] = e - r * h
        } else if ("XZY" === e.order) {
            const e = s * o
              , n = s * l
              , i = a * o
              , r = a * l;
            t[0] = o * c,
            t[4] = -h,
            t[8] = l * c,
            t[1] = e * h + r,
            t[5] = s * c,
            t[9] = n * h - i,
            t[2] = i * h - n,
            t[6] = a * c,
            t[10] = r * h + e
        }
        return t[3] = 0,
        t[7] = 0,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromQuaternion(e) {
        return this.compose(qn, e, Yn)
    }
    lookAt(e, t, n) {
        const i = this.elements;
        return Kn.subVectors(e, t),
        0 === Kn.lengthSq() && (Kn.z = 1),
        Kn.normalize(),
        Zn.crossVectors(n, Kn),
        0 === Zn.lengthSq() && (1 === Math.abs(n.z) ? Kn.x += 1e-4 : Kn.z += 1e-4,
        Kn.normalize(),
        Zn.crossVectors(n, Kn)),
        Zn.normalize(),
        Jn.crossVectors(Kn, Zn),
        i[0] = Zn.x,
        i[4] = Jn.x,
        i[8] = Kn.x,
        i[1] = Zn.y,
        i[5] = Jn.y,
        i[9] = Kn.y,
        i[2] = Zn.z,
        i[6] = Jn.z,
        i[10] = Kn.z,
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const n = e.elements
          , i = t.elements
          , r = this.elements
          , s = n[0]
          , a = n[4]
          , o = n[8]
          , l = n[12]
          , c = n[1]
          , h = n[5]
          , u = n[9]
          , d = n[13]
          , p = n[2]
          , m = n[6]
          , f = n[10]
          , g = n[14]
          , v = n[3]
          , x = n[7]
          , y = n[11]
          , _ = n[15]
          , b = i[0]
          , M = i[4]
          , w = i[8]
          , S = i[12]
          , T = i[1]
          , A = i[5]
          , E = i[9]
          , C = i[13]
          , L = i[2]
          , R = i[6]
          , P = i[10]
          , I = i[14]
          , D = i[3]
          , O = i[7]
          , N = i[11]
          , z = i[15];
        return r[0] = s * b + a * T + o * L + l * D,
        r[4] = s * M + a * A + o * R + l * O,
        r[8] = s * w + a * E + o * P + l * N,
        r[12] = s * S + a * C + o * I + l * z,
        r[1] = c * b + h * T + u * L + d * D,
        r[5] = c * M + h * A + u * R + d * O,
        r[9] = c * w + h * E + u * P + d * N,
        r[13] = c * S + h * C + u * I + d * z,
        r[2] = p * b + m * T + f * L + g * D,
        r[6] = p * M + m * A + f * R + g * O,
        r[10] = p * w + m * E + f * P + g * N,
        r[14] = p * S + m * C + f * I + g * z,
        r[3] = v * b + x * T + y * L + _ * D,
        r[7] = v * M + x * A + y * R + _ * O,
        r[11] = v * w + x * E + y * P + _ * N,
        r[15] = v * S + x * C + y * I + _ * z,
        this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e,
        t[4] *= e,
        t[8] *= e,
        t[12] *= e,
        t[1] *= e,
        t[5] *= e,
        t[9] *= e,
        t[13] *= e,
        t[2] *= e,
        t[6] *= e,
        t[10] *= e,
        t[14] *= e,
        t[3] *= e,
        t[7] *= e,
        t[11] *= e,
        t[15] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , t = e[0]
          , n = e[4]
          , i = e[8]
          , r = e[12]
          , s = e[1]
          , a = e[5]
          , o = e[9]
          , l = e[13]
          , c = e[2]
          , h = e[6]
          , u = e[10]
          , d = e[14];
        return e[3] * (+r * o * h - i * l * h - r * a * u + n * l * u + i * a * d - n * o * d) + e[7] * (+t * o * d - t * l * u + r * s * u - i * s * d + i * l * c - r * o * c) + e[11] * (+t * l * h - t * a * d - r * s * h + n * s * d + r * a * c - n * l * c) + e[15] * (-i * a * c - t * o * h + t * a * u + i * s * h - n * s * u + n * o * c)
    }
    transpose() {
        const e = this.elements;
        let t;
        return t = e[1],
        e[1] = e[4],
        e[4] = t,
        t = e[2],
        e[2] = e[8],
        e[8] = t,
        t = e[6],
        e[6] = e[9],
        e[9] = t,
        t = e[3],
        e[3] = e[12],
        e[12] = t,
        t = e[7],
        e[7] = e[13],
        e[13] = t,
        t = e[11],
        e[11] = e[14],
        e[14] = t,
        this
    }
    setPosition(e, t, n) {
        const i = this.elements;
        return e.isVector3 ? (i[12] = e.x,
        i[13] = e.y,
        i[14] = e.z) : (i[12] = e,
        i[13] = t,
        i[14] = n),
        this
    }
    invert() {
        const e = this.elements
          , t = e[0]
          , n = e[1]
          , i = e[2]
          , r = e[3]
          , s = e[4]
          , a = e[5]
          , o = e[6]
          , l = e[7]
          , c = e[8]
          , h = e[9]
          , u = e[10]
          , d = e[11]
          , p = e[12]
          , m = e[13]
          , f = e[14]
          , g = e[15]
          , v = h * f * l - m * u * l + m * o * d - a * f * d - h * o * g + a * u * g
          , x = p * u * l - c * f * l - p * o * d + s * f * d + c * o * g - s * u * g
          , y = c * m * l - p * h * l + p * a * d - s * m * d - c * a * g + s * h * g
          , _ = p * h * o - c * m * o - p * a * u + s * m * u + c * a * f - s * h * f
          , b = t * v + n * x + i * y + r * _;
        if (0 === b)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const M = 1 / b;
        return e[0] = v * M,
        e[1] = (m * u * r - h * f * r - m * i * d + n * f * d + h * i * g - n * u * g) * M,
        e[2] = (a * f * r - m * o * r + m * i * l - n * f * l - a * i * g + n * o * g) * M,
        e[3] = (h * o * r - a * u * r - h * i * l + n * u * l + a * i * d - n * o * d) * M,
        e[4] = x * M,
        e[5] = (c * f * r - p * u * r + p * i * d - t * f * d - c * i * g + t * u * g) * M,
        e[6] = (p * o * r - s * f * r - p * i * l + t * f * l + s * i * g - t * o * g) * M,
        e[7] = (s * u * r - c * o * r + c * i * l - t * u * l - s * i * d + t * o * d) * M,
        e[8] = y * M,
        e[9] = (p * h * r - c * m * r - p * n * d + t * m * d + c * n * g - t * h * g) * M,
        e[10] = (s * m * r - p * a * r + p * n * l - t * m * l - s * n * g + t * a * g) * M,
        e[11] = (c * a * r - s * h * r - c * n * l + t * h * l + s * n * d - t * a * d) * M,
        e[12] = _ * M,
        e[13] = (c * m * i - p * h * i + p * n * u - t * m * u - c * n * f + t * h * f) * M,
        e[14] = (p * a * i - s * m * i - p * n * o + t * m * o + s * n * f - t * a * f) * M,
        e[15] = (s * h * i - c * a * i + c * n * o - t * h * o - s * n * u + t * a * u) * M,
        this
    }
    scale(e) {
        const t = this.elements
          , n = e.x
          , i = e.y
          , r = e.z;
        return t[0] *= n,
        t[4] *= i,
        t[8] *= r,
        t[1] *= n,
        t[5] *= i,
        t[9] *= r,
        t[2] *= n,
        t[6] *= i,
        t[10] *= r,
        t[3] *= n,
        t[7] *= i,
        t[11] *= r,
        this
    }
    getMaxScaleOnAxis() {
        const e = this.elements
          , t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]
          , n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]
          , i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
        return Math.sqrt(Math.max(t, n, i))
    }
    makeTranslation(e, t, n) {
        return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1),
        this
    }
    makeRotationX(e) {
        const t = Math.cos(e)
          , n = Math.sin(e);
        return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationY(e) {
        const t = Math.cos(e)
          , n = Math.sin(e);
        return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationZ(e) {
        const t = Math.cos(e)
          , n = Math.sin(e);
        return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    makeRotationAxis(e, t) {
        const n = Math.cos(t)
          , i = Math.sin(t)
          , r = 1 - n
          , s = e.x
          , a = e.y
          , o = e.z
          , l = r * s
          , c = r * a;
        return this.set(l * s + n, l * a - i * o, l * o + i * a, 0, l * a + i * o, c * a + n, c * o - i * s, 0, l * o - i * a, c * o + i * s, r * o * o + n, 0, 0, 0, 0, 1),
        this
    }
    makeScale(e, t, n) {
        return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1),
        this
    }
    makeShear(e, t, n, i, r, s) {
        return this.set(1, n, r, 0, e, 1, s, 0, t, i, 1, 0, 0, 0, 0, 1),
        this
    }
    compose(e, t, n) {
        const i = this.elements
          , r = t._x
          , s = t._y
          , a = t._z
          , o = t._w
          , l = r + r
          , c = s + s
          , h = a + a
          , u = r * l
          , d = r * c
          , p = r * h
          , m = s * c
          , f = s * h
          , g = a * h
          , v = o * l
          , x = o * c
          , y = o * h
          , _ = n.x
          , b = n.y
          , M = n.z;
        return i[0] = (1 - (m + g)) * _,
        i[1] = (d + y) * _,
        i[2] = (p - x) * _,
        i[3] = 0,
        i[4] = (d - y) * b,
        i[5] = (1 - (u + g)) * b,
        i[6] = (f + v) * b,
        i[7] = 0,
        i[8] = (p + x) * M,
        i[9] = (f - v) * M,
        i[10] = (1 - (u + m)) * M,
        i[11] = 0,
        i[12] = e.x,
        i[13] = e.y,
        i[14] = e.z,
        i[15] = 1,
        this
    }
    decompose(e, t, n) {
        const i = this.elements;
        let r = jn.set(i[0], i[1], i[2]).length();
        const s = jn.set(i[4], i[5], i[6]).length()
          , a = jn.set(i[8], i[9], i[10]).length();
        this.determinant() < 0 && (r = -r),
        e.x = i[12],
        e.y = i[13],
        e.z = i[14],
        Xn.copy(this);
        const o = 1 / r
          , l = 1 / s
          , c = 1 / a;
        return Xn.elements[0] *= o,
        Xn.elements[1] *= o,
        Xn.elements[2] *= o,
        Xn.elements[4] *= l,
        Xn.elements[5] *= l,
        Xn.elements[6] *= l,
        Xn.elements[8] *= c,
        Xn.elements[9] *= c,
        Xn.elements[10] *= c,
        t.setFromRotationMatrix(Xn),
        n.x = r,
        n.y = s,
        n.z = a,
        this
    }
    makePerspective(e, t, n, i, r, s) {
        const a = this.elements
          , o = 2 * r / (t - e)
          , l = 2 * r / (n - i)
          , c = (t + e) / (t - e)
          , h = (n + i) / (n - i)
          , u = -(s + r) / (s - r)
          , d = -2 * s * r / (s - r);
        return a[0] = o,
        a[4] = 0,
        a[8] = c,
        a[12] = 0,
        a[1] = 0,
        a[5] = l,
        a[9] = h,
        a[13] = 0,
        a[2] = 0,
        a[6] = 0,
        a[10] = u,
        a[14] = d,
        a[3] = 0,
        a[7] = 0,
        a[11] = -1,
        a[15] = 0,
        this
    }
    makeOrthographic(e, t, n, i, r, s) {
        const a = this.elements
          , o = 1 / (t - e)
          , l = 1 / (n - i)
          , c = 1 / (s - r)
          , h = (t + e) * o
          , u = (n + i) * l
          , d = (s + r) * c;
        return a[0] = 2 * o,
        a[4] = 0,
        a[8] = 0,
        a[12] = -h,
        a[1] = 0,
        a[5] = 2 * l,
        a[9] = 0,
        a[13] = -u,
        a[2] = 0,
        a[6] = 0,
        a[10] = -2 * c,
        a[14] = -d,
        a[3] = 0,
        a[7] = 0,
        a[11] = 0,
        a[15] = 1,
        this
    }
    equals(e) {
        const t = this.elements
          , n = e.elements;
        for (let e = 0; e < 16; e++)
            if (t[e] !== n[e])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let n = 0; n < 16; n++)
            this.elements[n] = e[n + t];
        return this
    }
    toArray(e=[], t=0) {
        const n = this.elements;
        return e[t] = n[0],
        e[t + 1] = n[1],
        e[t + 2] = n[2],
        e[t + 3] = n[3],
        e[t + 4] = n[4],
        e[t + 5] = n[5],
        e[t + 6] = n[6],
        e[t + 7] = n[7],
        e[t + 8] = n[8],
        e[t + 9] = n[9],
        e[t + 10] = n[10],
        e[t + 11] = n[11],
        e[t + 12] = n[12],
        e[t + 13] = n[13],
        e[t + 14] = n[14],
        e[t + 15] = n[15],
        e
    }
}
const jn = new pn
  , Xn = new Wn
  , qn = new pn(0,0,0)
  , Yn = new pn(1,1,1)
  , Zn = new pn
  , Jn = new pn
  , Kn = new pn
  , Qn = new Wn
  , $n = new dn;
class ei {
    constructor(e=0, t=0, n=0, i=ei.DefaultOrder) {
        this.isEuler = !0,
        this._x = e,
        this._y = t,
        this._z = n,
        this._order = i
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get order() {
        return this._order
    }
    set order(e) {
        this._order = e,
        this._onChangeCallback()
    }
    set(e, t, n, i=this._order) {
        return this._x = e,
        this._y = t,
        this._z = n,
        this._order = i,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._order)
    }
    copy(e) {
        return this._x = e._x,
        this._y = e._y,
        this._z = e._z,
        this._order = e._order,
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e, t=this._order, n=!0) {
        const i = e.elements
          , r = i[0]
          , s = i[4]
          , a = i[8]
          , o = i[1]
          , l = i[5]
          , c = i[9]
          , h = i[2]
          , u = i[6]
          , d = i[10];
        switch (t) {
        case "XYZ":
            this._y = Math.asin(Lt(a, -1, 1)),
            Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, d),
            this._z = Math.atan2(-s, r)) : (this._x = Math.atan2(u, l),
            this._z = 0);
            break;
        case "YXZ":
            this._x = Math.asin(-Lt(c, -1, 1)),
            Math.abs(c) < .9999999 ? (this._y = Math.atan2(a, d),
            this._z = Math.atan2(o, l)) : (this._y = Math.atan2(-h, r),
            this._z = 0);
            break;
        case "ZXY":
            this._x = Math.asin(Lt(u, -1, 1)),
            Math.abs(u) < .9999999 ? (this._y = Math.atan2(-h, d),
            this._z = Math.atan2(-s, l)) : (this._y = 0,
            this._z = Math.atan2(o, r));
            break;
        case "ZYX":
            this._y = Math.asin(-Lt(h, -1, 1)),
            Math.abs(h) < .9999999 ? (this._x = Math.atan2(u, d),
            this._z = Math.atan2(o, r)) : (this._x = 0,
            this._z = Math.atan2(-s, l));
            break;
        case "YZX":
            this._z = Math.asin(Lt(o, -1, 1)),
            Math.abs(o) < .9999999 ? (this._x = Math.atan2(-c, l),
            this._y = Math.atan2(-h, r)) : (this._x = 0,
            this._y = Math.atan2(a, d));
            break;
        case "XZY":
            this._z = Math.asin(-Lt(s, -1, 1)),
            Math.abs(s) < .9999999 ? (this._x = Math.atan2(u, l),
            this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-c, d),
            this._y = 0);
            break;
        default:
            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
        }
        return this._order = t,
        !0 === n && this._onChangeCallback(),
        this
    }
    setFromQuaternion(e, t, n) {
        return Qn.makeRotationFromQuaternion(e),
        this.setFromRotationMatrix(Qn, t, n)
    }
    setFromVector3(e, t=this._order) {
        return this.set(e.x, e.y, e.z, t)
    }
    reorder(e) {
        return $n.setFromEuler(this),
        this.setFromQuaternion($n, e)
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
    }
    fromArray(e) {
        return this._x = e[0],
        this._y = e[1],
        this._z = e[2],
        void 0 !== e[3] && (this._order = e[3]),
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._order,
        e
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._order
    }
    toVector3() {
        console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead")
    }
}
ei.DefaultOrder = "XYZ",
ei.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
class ti {
    constructor() {
        this.mask = 1
    }
    set(e) {
        this.mask = (1 << e | 0) >>> 0
    }
    enable(e) {
        this.mask |= 1 << e | 0
    }
    enableAll() {
        this.mask = -1
    }
    toggle(e) {
        this.mask ^= 1 << e | 0
    }
    disable(e) {
        this.mask &= ~(1 << e | 0)
    }
    disableAll() {
        this.mask = 0
    }
    test(e) {
        return 0 != (this.mask & e.mask)
    }
    isEnabled(e) {
        return 0 != (this.mask & (1 << e | 0))
    }
}
let ni = 0;
const ii = new pn
  , ri = new dn
  , si = new Wn
  , ai = new pn
  , oi = new pn
  , li = new pn
  , ci = new dn
  , hi = new pn(1,0,0)
  , ui = new pn(0,1,0)
  , di = new pn(0,0,1)
  , pi = {
    type: "added"
}
  , mi = {
    type: "removed"
};
class fi extends wt {
    constructor() {
        super(),
        this.isObject3D = !0,
        Object.defineProperty(this, "id", {
            value: ni++
        }),
        this.uuid = Ct(),
        this.name = "",
        this.type = "Object3D",
        this.parent = null,
        this.children = [],
        this.up = fi.DefaultUp.clone();
        const e = new pn
          , t = new ei
          , n = new dn
          , i = new pn(1,1,1);
        t._onChange((function() {
            n.setFromEuler(t, !1)
        }
        )),
        n._onChange((function() {
            t.setFromQuaternion(n, void 0, !1)
        }
        )),
        Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: n
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: i
            },
            modelViewMatrix: {
                value: new Wn
            },
            normalMatrix: {
                value: new Bt
            }
        }),
        this.matrix = new Wn,
        this.matrixWorld = new Wn,
        this.matrixAutoUpdate = fi.DefaultMatrixAutoUpdate,
        this.matrixWorldNeedsUpdate = !1,
        this.matrixWorldAutoUpdate = fi.DefaultMatrixWorldAutoUpdate,
        this.layers = new ti,
        this.visible = !0,
        this.castShadow = !1,
        this.receiveShadow = !1,
        this.frustumCulled = !0,
        this.renderOrder = 0,
        this.animations = [],
        this.userData = {}
    }
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        this.matrix.premultiply(e),
        this.matrix.decompose(this.position, this.quaternion, this.scale)
    }
    applyQuaternion(e) {
        return this.quaternion.premultiply(e),
        this
    }
    setRotationFromAxisAngle(e, t) {
        this.quaternion.setFromAxisAngle(e, t)
    }
    setRotationFromEuler(e) {
        this.quaternion.setFromEuler(e, !0)
    }
    setRotationFromMatrix(e) {
        this.quaternion.setFromRotationMatrix(e)
    }
    setRotationFromQuaternion(e) {
        this.quaternion.copy(e)
    }
    rotateOnAxis(e, t) {
        return ri.setFromAxisAngle(e, t),
        this.quaternion.multiply(ri),
        this
    }
    rotateOnWorldAxis(e, t) {
        return ri.setFromAxisAngle(e, t),
        this.quaternion.premultiply(ri),
        this
    }
    rotateX(e) {
        return this.rotateOnAxis(hi, e)
    }
    rotateY(e) {
        return this.rotateOnAxis(ui, e)
    }
    rotateZ(e) {
        return this.rotateOnAxis(di, e)
    }
    translateOnAxis(e, t) {
        return ii.copy(e).applyQuaternion(this.quaternion),
        this.position.add(ii.multiplyScalar(t)),
        this
    }
    translateX(e) {
        return this.translateOnAxis(hi, e)
    }
    translateY(e) {
        return this.translateOnAxis(ui, e)
    }
    translateZ(e) {
        return this.translateOnAxis(di, e)
    }
    localToWorld(e) {
        return e.applyMatrix4(this.matrixWorld)
    }
    worldToLocal(e) {
        return e.applyMatrix4(si.copy(this.matrixWorld).invert())
    }
    lookAt(e, t, n) {
        e.isVector3 ? ai.copy(e) : ai.set(e, t, n);
        const i = this.parent;
        this.updateWorldMatrix(!0, !1),
        oi.setFromMatrixPosition(this.matrixWorld),
        this.isCamera || this.isLight ? si.lookAt(oi, ai, this.up) : si.lookAt(ai, oi, this.up),
        this.quaternion.setFromRotationMatrix(si),
        i && (si.extractRotation(i.matrixWorld),
        ri.setFromRotationMatrix(si),
        this.quaternion.premultiply(ri.invert()))
    }
    add(e) {
        if (arguments.length > 1) {
            for (let e = 0; e < arguments.length; e++)
                this.add(arguments[e]);
            return this
        }
        return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e),
        this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e),
        e.parent = this,
        this.children.push(e),
        e.dispatchEvent(pi)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e),
        this)
    }
    remove(e) {
        if (arguments.length > 1) {
            for (let e = 0; e < arguments.length; e++)
                this.remove(arguments[e]);
            return this
        }
        const t = this.children.indexOf(e);
        return -1 !== t && (e.parent = null,
        this.children.splice(t, 1),
        e.dispatchEvent(mi)),
        this
    }
    removeFromParent() {
        const e = this.parent;
        return null !== e && e.remove(this),
        this
    }
    clear() {
        for (let e = 0; e < this.children.length; e++) {
            const t = this.children[e];
            t.parent = null,
            t.dispatchEvent(mi)
        }
        return this.children.length = 0,
        this
    }
    attach(e) {
        return this.updateWorldMatrix(!0, !1),
        si.copy(this.matrixWorld).invert(),
        null !== e.parent && (e.parent.updateWorldMatrix(!0, !1),
        si.multiply(e.parent.matrixWorld)),
        e.applyMatrix4(si),
        this.add(e),
        e.updateWorldMatrix(!1, !0),
        this
    }
    getObjectById(e) {
        return this.getObjectByProperty("id", e)
    }
    getObjectByName(e) {
        return this.getObjectByProperty("name", e)
    }
    getObjectByProperty(e, t) {
        if (this[e] === t)
            return this;
        for (let n = 0, i = this.children.length; n < i; n++) {
            const i = this.children[n].getObjectByProperty(e, t);
            if (void 0 !== i)
                return i
        }
    }
    getWorldPosition(e) {
        return this.updateWorldMatrix(!0, !1),
        e.setFromMatrixPosition(this.matrixWorld)
    }
    getWorldQuaternion(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(oi, e, li),
        e
    }
    getWorldScale(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(oi, ci, e),
        e
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(t[8], t[9], t[10]).normalize()
    }
    raycast() {}
    traverse(e) {
        e(this);
        const t = this.children;
        for (let n = 0, i = t.length; n < i; n++)
            t[n].traverse(e)
    }
    traverseVisible(e) {
        if (!1 === this.visible)
            return;
        e(this);
        const t = this.children;
        for (let n = 0, i = t.length; n < i; n++)
            t[n].traverseVisible(e)
    }
    traverseAncestors(e) {
        const t = this.parent;
        null !== t && (e(t),
        t.traverseAncestors(e))
    }
    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale),
        this.matrixWorldNeedsUpdate = !0
    }
    updateMatrixWorld(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
        this.matrixWorldNeedsUpdate = !1,
        e = !0);
        const t = this.children;
        for (let n = 0, i = t.length; n < i; n++) {
            const i = t[n];
            !0 !== i.matrixWorldAutoUpdate && !0 !== e || i.updateMatrixWorld(e)
        }
    }
    updateWorldMatrix(e, t) {
        const n = this.parent;
        if (!0 === e && null !== n && !0 === n.matrixWorldAutoUpdate && n.updateWorldMatrix(!0, !1),
        this.matrixAutoUpdate && this.updateMatrix(),
        null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
        !0 === t) {
            const e = this.children;
            for (let t = 0, n = e.length; t < n; t++) {
                const n = e[t];
                !0 === n.matrixWorldAutoUpdate && n.updateWorldMatrix(!1, !0)
            }
        }
    }
    toJSON(e) {
        const t = void 0 === e || "string" == typeof e
          , n = {};
        t && (e = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
        },
        n.metadata = {
            version: 4.5,
            type: "Object",
            generator: "Object3D.toJSON"
        });
        const i = {};
        function r(t, n) {
            return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)),
            n.uuid
        }
        if (i.uuid = this.uuid,
        i.type = this.type,
        "" !== this.name && (i.name = this.name),
        !0 === this.castShadow && (i.castShadow = !0),
        !0 === this.receiveShadow && (i.receiveShadow = !0),
        !1 === this.visible && (i.visible = !1),
        !1 === this.frustumCulled && (i.frustumCulled = !1),
        0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
        "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData),
        i.layers = this.layers.mask,
        i.matrix = this.matrix.toArray(),
        !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
        this.isInstancedMesh && (i.type = "InstancedMesh",
        i.count = this.count,
        i.instanceMatrix = this.instanceMatrix.toJSON(),
        null !== this.instanceColor && (i.instanceColor = this.instanceColor.toJSON())),
        this.isScene)
            this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)),
            this.environment && this.environment.isTexture && !0 !== this.environment.isRenderTargetTexture && (i.environment = this.environment.toJSON(e).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
            i.geometry = r(e.geometries, this.geometry);
            const t = this.geometry.parameters;
            if (void 0 !== t && void 0 !== t.shapes) {
                const n = t.shapes;
                if (Array.isArray(n))
                    for (let t = 0, i = n.length; t < i; t++) {
                        const i = n[t];
                        r(e.shapes, i)
                    }
                else
                    r(e.shapes, n)
            }
        }
        if (this.isSkinnedMesh && (i.bindMode = this.bindMode,
        i.bindMatrix = this.bindMatrix.toArray(),
        void 0 !== this.skeleton && (r(e.skeletons, this.skeleton),
        i.skeleton = this.skeleton.uuid)),
        void 0 !== this.material)
            if (Array.isArray(this.material)) {
                const t = [];
                for (let n = 0, i = this.material.length; n < i; n++)
                    t.push(r(e.materials, this.material[n]));
                i.material = t
            } else
                i.material = r(e.materials, this.material);
        if (this.children.length > 0) {
            i.children = [];
            for (let t = 0; t < this.children.length; t++)
                i.children.push(this.children[t].toJSON(e).object)
        }
        if (this.animations.length > 0) {
            i.animations = [];
            for (let t = 0; t < this.animations.length; t++) {
                const n = this.animations[t];
                i.animations.push(r(e.animations, n))
            }
        }
        if (t) {
            const t = s(e.geometries)
              , i = s(e.materials)
              , r = s(e.textures)
              , a = s(e.images)
              , o = s(e.shapes)
              , l = s(e.skeletons)
              , c = s(e.animations)
              , h = s(e.nodes);
            t.length > 0 && (n.geometries = t),
            i.length > 0 && (n.materials = i),
            r.length > 0 && (n.textures = r),
            a.length > 0 && (n.images = a),
            o.length > 0 && (n.shapes = o),
            l.length > 0 && (n.skeletons = l),
            c.length > 0 && (n.animations = c),
            h.length > 0 && (n.nodes = h)
        }
        return n.object = i,
        n;
        function s(e) {
            const t = [];
            for (const n in e) {
                const i = e[n];
                delete i.metadata,
                t.push(i)
            }
            return t
        }
    }
    clone(e) {
        return (new this.constructor).copy(this, e)
    }
    copy(e, t=!0) {
        if (this.name = e.name,
        this.up.copy(e.up),
        this.position.copy(e.position),
        this.rotation.order = e.rotation.order,
        this.quaternion.copy(e.quaternion),
        this.scale.copy(e.scale),
        this.matrix.copy(e.matrix),
        this.matrixWorld.copy(e.matrixWorld),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
        this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate,
        this.layers.mask = e.layers.mask,
        this.visible = e.visible,
        this.castShadow = e.castShadow,
        this.receiveShadow = e.receiveShadow,
        this.frustumCulled = e.frustumCulled,
        this.renderOrder = e.renderOrder,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        !0 === t)
            for (let t = 0; t < e.children.length; t++) {
                const n = e.children[t];
                this.add(n.clone())
            }
        return this
    }
}
fi.DefaultUp = new pn(0,1,0),
fi.DefaultMatrixAutoUpdate = !0,
fi.DefaultMatrixWorldAutoUpdate = !0;
const gi = new pn
  , vi = new pn
  , xi = new pn
  , yi = new pn
  , _i = new pn
  , bi = new pn
  , Mi = new pn
  , wi = new pn
  , Si = new pn
  , Ti = new pn;
class Ai {
    constructor(e=new pn, t=new pn, n=new pn) {
        this.a = e,
        this.b = t,
        this.c = n
    }
    static getNormal(e, t, n, i) {
        i.subVectors(n, t),
        gi.subVectors(e, t),
        i.cross(gi);
        const r = i.lengthSq();
        return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
    }
    static getBarycoord(e, t, n, i, r) {
        gi.subVectors(i, t),
        vi.subVectors(n, t),
        xi.subVectors(e, t);
        const s = gi.dot(gi)
          , a = gi.dot(vi)
          , o = gi.dot(xi)
          , l = vi.dot(vi)
          , c = vi.dot(xi)
          , h = s * l - a * a;
        if (0 === h)
            return r.set(-2, -1, -1);
        const u = 1 / h
          , d = (l * o - a * c) * u
          , p = (s * c - a * o) * u;
        return r.set(1 - d - p, p, d)
    }
    static containsPoint(e, t, n, i) {
        return this.getBarycoord(e, t, n, i, yi),
        yi.x >= 0 && yi.y >= 0 && yi.x + yi.y <= 1
    }
    static getUV(e, t, n, i, r, s, a, o) {
        return this.getBarycoord(e, t, n, i, yi),
        o.set(0, 0),
        o.addScaledVector(r, yi.x),
        o.addScaledVector(s, yi.y),
        o.addScaledVector(a, yi.z),
        o
    }
    static isFrontFacing(e, t, n, i) {
        return gi.subVectors(n, t),
        vi.subVectors(e, t),
        gi.cross(vi).dot(i) < 0
    }
    set(e, t, n) {
        return this.a.copy(e),
        this.b.copy(t),
        this.c.copy(n),
        this
    }
    setFromPointsAndIndices(e, t, n, i) {
        return this.a.copy(e[t]),
        this.b.copy(e[n]),
        this.c.copy(e[i]),
        this
    }
    setFromAttributeAndIndices(e, t, n, i) {
        return this.a.fromBufferAttribute(e, t),
        this.b.fromBufferAttribute(e, n),
        this.c.fromBufferAttribute(e, i),
        this
    }
    clone() {
        return (new this.constructor).copy(this)
    }
    copy(e) {
        return this.a.copy(e.a),
        this.b.copy(e.b),
        this.c.copy(e.c),
        this
    }
    getArea() {
        return gi.subVectors(this.c, this.b),
        vi.subVectors(this.a, this.b),
        .5 * gi.cross(vi).length()
    }
    getMidpoint(e) {
        return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    }
    getNormal(e) {
        return Ai.getNormal(this.a, this.b, this.c, e)
    }
    getPlane(e) {
        return e.setFromCoplanarPoints(this.a, this.b, this.c)
    }
    getBarycoord(e, t) {
        return Ai.getBarycoord(e, this.a, this.b, this.c, t)
    }
    getUV(e, t, n, i, r) {
        return Ai.getUV(e, this.a, this.b, this.c, t, n, i, r)
    }
    containsPoint(e) {
        return Ai.containsPoint(e, this.a, this.b, this.c)
    }
    isFrontFacing(e) {
        return Ai.isFrontFacing(this.a, this.b, this.c, e)
    }
    intersectsBox(e) {
        return e.intersectsTriangle(this)
    }
    closestPointToPoint(e, t) {
        const n = this.a
          , i = this.b
          , r = this.c;
        let s, a;
        _i.subVectors(i, n),
        bi.subVectors(r, n),
        wi.subVectors(e, n);
        const o = _i.dot(wi)
          , l = bi.dot(wi);
        if (o <= 0 && l <= 0)
            return t.copy(n);
        Si.subVectors(e, i);
        const c = _i.dot(Si)
          , h = bi.dot(Si);
        if (c >= 0 && h <= c)
            return t.copy(i);
        const u = o * h - c * l;
        if (u <= 0 && o >= 0 && c <= 0)
            return s = o / (o - c),
            t.copy(n).addScaledVector(_i, s);
        Ti.subVectors(e, r);
        const d = _i.dot(Ti)
          , p = bi.dot(Ti);
        if (p >= 0 && d <= p)
            return t.copy(r);
        const m = d * l - o * p;
        if (m <= 0 && l >= 0 && p <= 0)
            return a = l / (l - p),
            t.copy(n).addScaledVector(bi, a);
        const f = c * p - d * h;
        if (f <= 0 && h - c >= 0 && d - p >= 0)
            return Mi.subVectors(r, i),
            a = (h - c) / (h - c + (d - p)),
            t.copy(i).addScaledVector(Mi, a);
        const g = 1 / (f + m + u);
        return s = m * g,
        a = u * g,
        t.copy(n).addScaledVector(_i, s).addScaledVector(bi, a)
    }
    equals(e) {
        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
    }
}
let Ei = 0;
class Ci extends wt {
    constructor() {
        super(),
        this.isMaterial = !0,
        Object.defineProperty(this, "id", {
            value: Ei++
        }),
        this.uuid = Ct(),
        this.name = "",
        this.type = "Material",
        this.blending = 1,
        this.side = 0,
        this.vertexColors = !1,
        this.opacity = 1,
        this.transparent = !1,
        this.blendSrc = 204,
        this.blendDst = 205,
        this.blendEquation = ce,
        this.blendSrcAlpha = null,
        this.blendDstAlpha = null,
        this.blendEquationAlpha = null,
        this.depthFunc = 3,
        this.depthTest = !0,
        this.depthWrite = !0,
        this.stencilWriteMask = 255,
        this.stencilFunc = 519,
        this.stencilRef = 0,
        this.stencilFuncMask = 255,
        this.stencilFail = yt,
        this.stencilZFail = yt,
        this.stencilZPass = yt,
        this.stencilWrite = !1,
        this.clippingPlanes = null,
        this.clipIntersection = !1,
        this.clipShadows = !1,
        this.shadowSide = null,
        this.colorWrite = !0,
        this.precision = null,
        this.polygonOffset = !1,
        this.polygonOffsetFactor = 0,
        this.polygonOffsetUnits = 0,
        this.dithering = !1,
        this.alphaToCoverage = !1,
        this.premultipliedAlpha = !1,
        this.visible = !0,
        this.toneMapped = !0,
        this.userData = {},
        this.version = 0,
        this._alphaTest = 0
    }
    get alphaTest() {
        return this._alphaTest
    }
    set alphaTest(e) {
        this._alphaTest > 0 != e > 0 && this.version++,
        this._alphaTest = e
    }
    onBuild() {}
    onBeforeRender() {}
    onBeforeCompile() {}
    customProgramCacheKey() {
        return this.onBeforeCompile.toString()
    }
    setValues(e) {
        if (void 0 !== e)
            for (const t in e) {
                const n = e[t];
                if (void 0 === n) {
                    console.warn("THREE.Material: '" + t + "' parameter is undefined.");
                    continue
                }
                const i = this[t];
                void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n : console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.")
            }
    }
    toJSON(e) {
        const t = void 0 === e || "string" == typeof e;
        t && (e = {
            textures: {},
            images: {}
        });
        const n = {
            metadata: {
                version: 4.5,
                type: "Material",
                generator: "Material.toJSON"
            }
        };
        function i(e) {
            const t = [];
            for (const n in e) {
                const i = e[n];
                delete i.metadata,
                t.push(i)
            }
            return t
        }
        if (n.uuid = this.uuid,
        n.type = this.type,
        "" !== this.name && (n.name = this.name),
        this.color && this.color.isColor && (n.color = this.color.getHex()),
        void 0 !== this.roughness && (n.roughness = this.roughness),
        void 0 !== this.metalness && (n.metalness = this.metalness),
        void 0 !== this.sheen && (n.sheen = this.sheen),
        this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()),
        void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness),
        this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
        this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity),
        this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
        void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity),
        this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()),
        void 0 !== this.shininess && (n.shininess = this.shininess),
        void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
        void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness),
        this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
        this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
        this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid,
        n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
        void 0 !== this.iridescence && (n.iridescence = this.iridescence),
        void 0 !== this.iridescenceIOR && (n.iridescenceIOR = this.iridescenceIOR),
        void 0 !== this.iridescenceThicknessRange && (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
        this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
        this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
        this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
        this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid),
        this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid),
        this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid,
        n.lightMapIntensity = this.lightMapIntensity),
        this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid,
        n.aoMapIntensity = this.aoMapIntensity),
        this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid,
        n.bumpScale = this.bumpScale),
        this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid,
        n.normalMapType = this.normalMapType,
        n.normalScale = this.normalScale.toArray()),
        this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid,
        n.displacementScale = this.displacementScale,
        n.displacementBias = this.displacementBias),
        this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
        this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
        this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
        this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid),
        this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
        this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid),
        this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid,
        void 0 !== this.combine && (n.combine = this.combine)),
        void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity),
        void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity),
        void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio),
        this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid),
        void 0 !== this.transmission && (n.transmission = this.transmission),
        this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
        void 0 !== this.thickness && (n.thickness = this.thickness),
        this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
        void 0 !== this.attenuationDistance && (n.attenuationDistance = this.attenuationDistance),
        void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()),
        void 0 !== this.size && (n.size = this.size),
        null !== this.shadowSide && (n.shadowSide = this.shadowSide),
        void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation),
        1 !== this.blending && (n.blending = this.blending),
        0 !== this.side && (n.side = this.side),
        this.vertexColors && (n.vertexColors = !0),
        this.opacity < 1 && (n.opacity = this.opacity),
        !0 === this.transparent && (n.transparent = this.transparent),
        n.depthFunc = this.depthFunc,
        n.depthTest = this.depthTest,
        n.depthWrite = this.depthWrite,
        n.colorWrite = this.colorWrite,
        n.stencilWrite = this.stencilWrite,
        n.stencilWriteMask = this.stencilWriteMask,
        n.stencilFunc = this.stencilFunc,
        n.stencilRef = this.stencilRef,
        n.stencilFuncMask = this.stencilFuncMask,
        n.stencilFail = this.stencilFail,
        n.stencilZFail = this.stencilZFail,
        n.stencilZPass = this.stencilZPass,
        void 0 !== this.rotation && 0 !== this.rotation && (n.rotation = this.rotation),
        !0 === this.polygonOffset && (n.polygonOffset = !0),
        0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor),
        0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits),
        void 0 !== this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth),
        void 0 !== this.dashSize && (n.dashSize = this.dashSize),
        void 0 !== this.gapSize && (n.gapSize = this.gapSize),
        void 0 !== this.scale && (n.scale = this.scale),
        !0 === this.dithering && (n.dithering = !0),
        this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
        !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage),
        !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha),
        !0 === this.wireframe && (n.wireframe = this.wireframe),
        this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
        "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap),
        "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin),
        !0 === this.flatShading && (n.flatShading = this.flatShading),
        !1 === this.visible && (n.visible = !1),
        !1 === this.toneMapped && (n.toneMapped = !1),
        !1 === this.fog && (n.fog = !1),
        "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData),
        t) {
            const t = i(e.textures)
              , r = i(e.images);
            t.length > 0 && (n.textures = t),
            r.length > 0 && (n.images = r)
        }
        return n
    }
    clone() {
        return (new this.constructor).copy(this)
    }
    copy(e) {
        this.name = e.name,
        this.blending = e.blending,
        this.side = e.side,
        this.vertexColors = e.vertexColors,
        this.opacity = e.opacity,
        this.transparent = e.transparent,
        this.blendSrc = e.blendSrc,
        this.blendDst = e.blendDst,
        this.blendEquation = e.blendEquation,
        this.blendSrcAlpha = e.blendSrcAlpha,
        this.blendDstAlpha = e.blendDstAlpha,
        this.blendEquationAlpha = e.blendEquationAlpha,
        this.depthFunc = e.depthFunc,
        this.depthTest = e.depthTest,
        this.depthWrite = e.depthWrite,
        this.stencilWriteMask = e.stencilWriteMask,
        this.stencilFunc = e.stencilFunc,
        this.stencilRef = e.stencilRef,
        this.stencilFuncMask = e.stencilFuncMask,
        this.stencilFail = e.stencilFail,
        this.stencilZFail = e.stencilZFail,
        this.stencilZPass = e.stencilZPass,
        this.stencilWrite = e.stencilWrite;
        const t = e.clippingPlanes;
        let n = null;
        if (null !== t) {
            const e = t.length;
            n = new Array(e);
            for (let i = 0; i !== e; ++i)
                n[i] = t[i].clone()
        }
        return this.clippingPlanes = n,
        this.clipIntersection = e.clipIntersection,
        this.clipShadows = e.clipShadows,
        this.shadowSide = e.shadowSide,
        this.colorWrite = e.colorWrite,
        this.precision = e.precision,
        this.polygonOffset = e.polygonOffset,
        this.polygonOffsetFactor = e.polygonOffsetFactor,
        this.polygonOffsetUnits = e.polygonOffsetUnits,
        this.dithering = e.dithering,
        this.alphaTest = e.alphaTest,
        this.alphaToCoverage = e.alphaToCoverage,
        this.premultipliedAlpha = e.premultipliedAlpha,
        this.visible = e.visible,
        this.toneMapped = e.toneMapped,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    set needsUpdate(e) {
        !0 === e && this.version++
    }
}
class Li extends Ci {
    constructor(e) {
        super(),
        this.isMeshBasicMaterial = !0,
        this.type = "MeshBasicMaterial",
        this.color = new en(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = 0,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.fog = e.fog,
        this
    }
}
const Ri = new pn
  , Pi = new Ft;
class Ii {
    constructor(e, t, n) {
        if (Array.isArray(e))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.isBufferAttribute = !0,
        this.name = "",
        this.array = e,
        this.itemSize = t,
        this.count = void 0 !== e ? e.length / t : 0,
        this.normalized = !0 === n,
        this.usage = _t,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.version = 0
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        !0 === e && this.version++
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    copy(e) {
        return this.name = e.name,
        this.array = new e.array.constructor(e.array),
        this.itemSize = e.itemSize,
        this.count = e.count,
        this.normalized = e.normalized,
        this.usage = e.usage,
        this
    }
    copyAt(e, t, n) {
        e *= this.itemSize,
        n *= t.itemSize;
        for (let i = 0, r = this.itemSize; i < r; i++)
            this.array[e + i] = t.array[n + i];
        return this
    }
    copyArray(e) {
        return this.array.set(e),
        this
    }
    applyMatrix3(e) {
        if (2 === this.itemSize)
            for (let t = 0, n = this.count; t < n; t++)
                Pi.fromBufferAttribute(this, t),
                Pi.applyMatrix3(e),
                this.setXY(t, Pi.x, Pi.y);
        else if (3 === this.itemSize)
            for (let t = 0, n = this.count; t < n; t++)
                Ri.fromBufferAttribute(this, t),
                Ri.applyMatrix3(e),
                this.setXYZ(t, Ri.x, Ri.y, Ri.z);
        return this
    }
    applyMatrix4(e) {
        for (let t = 0, n = this.count; t < n; t++)
            Ri.fromBufferAttribute(this, t),
            Ri.applyMatrix4(e),
            this.setXYZ(t, Ri.x, Ri.y, Ri.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, n = this.count; t < n; t++)
            Ri.fromBufferAttribute(this, t),
            Ri.applyNormalMatrix(e),
            this.setXYZ(t, Ri.x, Ri.y, Ri.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, n = this.count; t < n; t++)
            Ri.fromBufferAttribute(this, t),
            Ri.transformDirection(e),
            this.setXYZ(t, Ri.x, Ri.y, Ri.z);
        return this
    }
    set(e, t=0) {
        return this.array.set(e, t),
        this
    }
    getX(e) {
        let t = this.array[e * this.itemSize];
        return this.normalized && (t = Nt(t, this.array)),
        t
    }
    setX(e, t) {
        return this.normalized && (t = zt(t, this.array)),
        this.array[e * this.itemSize] = t,
        this
    }
    getY(e) {
        let t = this.array[e * this.itemSize + 1];
        return this.normalized && (t = Nt(t, this.array)),
        t
    }
    setY(e, t) {
        return this.normalized && (t = zt(t, this.array)),
        this.array[e * this.itemSize + 1] = t,
        this
    }
    getZ(e) {
        let t = this.array[e * this.itemSize + 2];
        return this.normalized && (t = Nt(t, this.array)),
        t
    }
    setZ(e, t) {
        return this.normalized && (t = zt(t, this.array)),
        this.array[e * this.itemSize + 2] = t,
        this
    }
    getW(e) {
        let t = this.array[e * this.itemSize + 3];
        return this.normalized && (t = Nt(t, this.array)),
        t
    }
    setW(e, t) {
        return this.normalized && (t = zt(t, this.array)),
        this.array[e * this.itemSize + 3] = t,
        this
    }
    setXY(e, t, n) {
        return e *= this.itemSize,
        this.normalized && (t = zt(t, this.array),
        n = zt(n, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = n,
        this
    }
    setXYZ(e, t, n, i) {
        return e *= this.itemSize,
        this.normalized && (t = zt(t, this.array),
        n = zt(n, this.array),
        i = zt(i, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = n,
        this.array[e + 2] = i,
        this
    }
    setXYZW(e, t, n, i, r) {
        return e *= this.itemSize,
        this.normalized && (t = zt(t, this.array),
        n = zt(n, this.array),
        i = zt(i, this.array),
        r = zt(r, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = n,
        this.array[e + 2] = i,
        this.array[e + 3] = r,
        this
    }
    onUpload(e) {
        return this.onUploadCallback = e,
        this
    }
    clone() {
        return new this.constructor(this.array,this.itemSize).copy(this)
    }
    toJSON() {
        const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
        };
        return "" !== this.name && (e.name = this.name),
        this.usage !== _t && (e.usage = this.usage),
        0 === this.updateRange.offset && -1 === this.updateRange.count || (e.updateRange = this.updateRange),
        e
    }
    copyColorsArray() {
        console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.")
    }
    copyVector2sArray() {
        console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.")
    }
    copyVector3sArray() {
        console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.")
    }
    copyVector4sArray() {
        console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.")
    }
}
class Di extends Ii {
    constructor(e, t, n) {
        super(new Uint16Array(e), t, n)
    }
}
class Oi extends Ii {
    constructor(e, t, n) {
        super(new Uint32Array(e), t, n)
    }
}
class Ni extends Ii {
    constructor(e, t, n) {
        super(new Float32Array(e), t, n)
    }
}
let zi = 0;
const Ui = new Wn
  , Fi = new fi
  , Bi = new pn
  , ki = new gn
  , Gi = new gn
  , Hi = new pn;
class Vi extends wt {
    constructor() {
        super(),
        this.isBufferGeometry = !0,
        Object.defineProperty(this, "id", {
            value: zi++
        }),
        this.uuid = Ct(),
        this.name = "",
        this.type = "BufferGeometry",
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.morphTargetsRelative = !1,
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.drawRange = {
            start: 0,
            count: Infinity
        },
        this.userData = {}
    }
    getIndex() {
        return this.index
    }
    setIndex(e) {
        return Array.isArray(e) ? this.index = new (kt(e) ? Oi : Di)(e,1) : this.index = e,
        this
    }
    getAttribute(e) {
        return this.attributes[e]
    }
    setAttribute(e, t) {
        return this.attributes[e] = t,
        this
    }
    deleteAttribute(e) {
        return delete this.attributes[e],
        this
    }
    hasAttribute(e) {
        return void 0 !== this.attributes[e]
    }
    addGroup(e, t, n=0) {
        this.groups.push({
            start: e,
            count: t,
            materialIndex: n
        })
    }
    clearGroups() {
        this.groups = []
    }
    setDrawRange(e, t) {
        this.drawRange.start = e,
        this.drawRange.count = t
    }
    applyMatrix4(e) {
        const t = this.attributes.position;
        void 0 !== t && (t.applyMatrix4(e),
        t.needsUpdate = !0);
        const n = this.attributes.normal;
        if (void 0 !== n) {
            const t = (new Bt).getNormalMatrix(e);
            n.applyNormalMatrix(t),
            n.needsUpdate = !0
        }
        const i = this.attributes.tangent;
        return void 0 !== i && (i.transformDirection(e),
        i.needsUpdate = !0),
        null !== this.boundingBox && this.computeBoundingBox(),
        null !== this.boundingSphere && this.computeBoundingSphere(),
        this
    }
    applyQuaternion(e) {
        return Ui.makeRotationFromQuaternion(e),
        this.applyMatrix4(Ui),
        this
    }
    rotateX(e) {
        return Ui.makeRotationX(e),
        this.applyMatrix4(Ui),
        this
    }
    rotateY(e) {
        return Ui.makeRotationY(e),
        this.applyMatrix4(Ui),
        this
    }
    rotateZ(e) {
        return Ui.makeRotationZ(e),
        this.applyMatrix4(Ui),
        this
    }
    translate(e, t, n) {
        return Ui.makeTranslation(e, t, n),
        this.applyMatrix4(Ui),
        this
    }
    scale(e, t, n) {
        return Ui.makeScale(e, t, n),
        this.applyMatrix4(Ui),
        this
    }
    lookAt(e) {
        return Fi.lookAt(e),
        Fi.updateMatrix(),
        this.applyMatrix4(Fi.matrix),
        this
    }
    center() {
        return this.computeBoundingBox(),
        this.boundingBox.getCenter(Bi).negate(),
        this.translate(Bi.x, Bi.y, Bi.z),
        this
    }
    setFromPoints(e) {
        const t = [];
        for (let n = 0, i = e.length; n < i; n++) {
            const i = e[n];
            t.push(i.x, i.y, i.z || 0)
        }
        return this.setAttribute("position", new Ni(t,3)),
        this
    }
    computeBoundingBox() {
        null === this.boundingBox && (this.boundingBox = new gn);
        const e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute)
            return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this),
            void this.boundingBox.set(new pn(-Infinity,-Infinity,-Infinity), new pn(Infinity,Infinity,Infinity));
        if (void 0 !== e) {
            if (this.boundingBox.setFromBufferAttribute(e),
            t)
                for (let e = 0, n = t.length; e < n; e++) {
                    const n = t[e];
                    ki.setFromBufferAttribute(n),
                    this.morphTargetsRelative ? (Hi.addVectors(this.boundingBox.min, ki.min),
                    this.boundingBox.expandByPoint(Hi),
                    Hi.addVectors(this.boundingBox.max, ki.max),
                    this.boundingBox.expandByPoint(Hi)) : (this.boundingBox.expandByPoint(ki.min),
                    this.boundingBox.expandByPoint(ki.max))
                }
        } else
            this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
    }
    computeBoundingSphere() {
        null === this.boundingSphere && (this.boundingSphere = new Nn);
        const e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute)
            return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this),
            void this.boundingSphere.set(new pn, Infinity);
        if (e) {
            const n = this.boundingSphere.center;
            if (ki.setFromBufferAttribute(e),
            t)
                for (let e = 0, n = t.length; e < n; e++) {
                    const n = t[e];
                    Gi.setFromBufferAttribute(n),
                    this.morphTargetsRelative ? (Hi.addVectors(ki.min, Gi.min),
                    ki.expandByPoint(Hi),
                    Hi.addVectors(ki.max, Gi.max),
                    ki.expandByPoint(Hi)) : (ki.expandByPoint(Gi.min),
                    ki.expandByPoint(Gi.max))
                }
            ki.getCenter(n);
            let i = 0;
            for (let t = 0, r = e.count; t < r; t++)
                Hi.fromBufferAttribute(e, t),
                i = Math.max(i, n.distanceToSquared(Hi));
            if (t)
                for (let r = 0, s = t.length; r < s; r++) {
                    const s = t[r]
                      , a = this.morphTargetsRelative;
                    for (let t = 0, r = s.count; t < r; t++)
                        Hi.fromBufferAttribute(s, t),
                        a && (Bi.fromBufferAttribute(e, t),
                        Hi.add(Bi)),
                        i = Math.max(i, n.distanceToSquared(Hi))
                }
            this.boundingSphere.radius = Math.sqrt(i),
            isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
        }
    }
    computeTangents() {
        const e = this.index
          , t = this.attributes;
        if (null === e || void 0 === t.position || void 0 === t.normal || void 0 === t.uv)
            return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
        const n = e.array
          , i = t.position.array
          , r = t.normal.array
          , s = t.uv.array
          , a = i.length / 3;
        !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new Ii(new Float32Array(4 * a),4));
        const o = this.getAttribute("tangent").array
          , l = []
          , c = [];
        for (let e = 0; e < a; e++)
            l[e] = new pn,
            c[e] = new pn;
        const h = new pn
          , u = new pn
          , d = new pn
          , p = new Ft
          , m = new Ft
          , f = new Ft
          , g = new pn
          , v = new pn;
        function x(e, t, n) {
            h.fromArray(i, 3 * e),
            u.fromArray(i, 3 * t),
            d.fromArray(i, 3 * n),
            p.fromArray(s, 2 * e),
            m.fromArray(s, 2 * t),
            f.fromArray(s, 2 * n),
            u.sub(h),
            d.sub(h),
            m.sub(p),
            f.sub(p);
            const r = 1 / (m.x * f.y - f.x * m.y);
            isFinite(r) && (g.copy(u).multiplyScalar(f.y).addScaledVector(d, -m.y).multiplyScalar(r),
            v.copy(d).multiplyScalar(m.x).addScaledVector(u, -f.x).multiplyScalar(r),
            l[e].add(g),
            l[t].add(g),
            l[n].add(g),
            c[e].add(v),
            c[t].add(v),
            c[n].add(v))
        }
        let y = this.groups;
        0 === y.length && (y = [{
            start: 0,
            count: n.length
        }]);
        for (let e = 0, t = y.length; e < t; ++e) {
            const t = y[e]
              , i = t.start;
            for (let e = i, r = i + t.count; e < r; e += 3)
                x(n[e + 0], n[e + 1], n[e + 2])
        }
        const _ = new pn
          , b = new pn
          , M = new pn
          , w = new pn;
        function S(e) {
            M.fromArray(r, 3 * e),
            w.copy(M);
            const t = l[e];
            _.copy(t),
            _.sub(M.multiplyScalar(M.dot(t))).normalize(),
            b.crossVectors(w, t);
            const n = b.dot(c[e]) < 0 ? -1 : 1;
            o[4 * e] = _.x,
            o[4 * e + 1] = _.y,
            o[4 * e + 2] = _.z,
            o[4 * e + 3] = n
        }
        for (let e = 0, t = y.length; e < t; ++e) {
            const t = y[e]
              , i = t.start;
            for (let e = i, r = i + t.count; e < r; e += 3)
                S(n[e + 0]),
                S(n[e + 1]),
                S(n[e + 2])
        }
    }
    computeVertexNormals() {
        const e = this.index
          , t = this.getAttribute("position");
        if (void 0 !== t) {
            let n = this.getAttribute("normal");
            if (void 0 === n)
                n = new Ii(new Float32Array(3 * t.count),3),
                this.setAttribute("normal", n);
            else
                for (let e = 0, t = n.count; e < t; e++)
                    n.setXYZ(e, 0, 0, 0);
            const i = new pn
              , r = new pn
              , s = new pn
              , a = new pn
              , o = new pn
              , l = new pn
              , c = new pn
              , h = new pn;
            if (e)
                for (let u = 0, d = e.count; u < d; u += 3) {
                    const d = e.getX(u + 0)
                      , p = e.getX(u + 1)
                      , m = e.getX(u + 2);
                    i.fromBufferAttribute(t, d),
                    r.fromBufferAttribute(t, p),
                    s.fromBufferAttribute(t, m),
                    c.subVectors(s, r),
                    h.subVectors(i, r),
                    c.cross(h),
                    a.fromBufferAttribute(n, d),
                    o.fromBufferAttribute(n, p),
                    l.fromBufferAttribute(n, m),
                    a.add(c),
                    o.add(c),
                    l.add(c),
                    n.setXYZ(d, a.x, a.y, a.z),
                    n.setXYZ(p, o.x, o.y, o.z),
                    n.setXYZ(m, l.x, l.y, l.z)
                }
            else
                for (let e = 0, a = t.count; e < a; e += 3)
                    i.fromBufferAttribute(t, e + 0),
                    r.fromBufferAttribute(t, e + 1),
                    s.fromBufferAttribute(t, e + 2),
                    c.subVectors(s, r),
                    h.subVectors(i, r),
                    c.cross(h),
                    n.setXYZ(e + 0, c.x, c.y, c.z),
                    n.setXYZ(e + 1, c.x, c.y, c.z),
                    n.setXYZ(e + 2, c.x, c.y, c.z);
            this.normalizeNormals(),
            n.needsUpdate = !0
        }
    }
    merge() {
        return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead."),
        this
    }
    normalizeNormals() {
        const e = this.attributes.normal;
        for (let t = 0, n = e.count; t < n; t++)
            Hi.fromBufferAttribute(e, t),
            Hi.normalize(),
            e.setXYZ(t, Hi.x, Hi.y, Hi.z)
    }
    toNonIndexed() {
        function e(e, t) {
            const n = e.array
              , i = e.itemSize
              , r = e.normalized
              , s = new n.constructor(t.length * i);
            let a = 0
              , o = 0;
            for (let r = 0, l = t.length; r < l; r++) {
                a = e.isInterleavedBufferAttribute ? t[r] * e.data.stride + e.offset : t[r] * i;
                for (let e = 0; e < i; e++)
                    s[o++] = n[a++]
            }
            return new Ii(s,i,r)
        }
        if (null === this.index)
            return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
            this;
        const t = new Vi
          , n = this.index.array
          , i = this.attributes;
        for (const r in i) {
            const s = e(i[r], n);
            t.setAttribute(r, s)
        }
        const r = this.morphAttributes;
        for (const i in r) {
            const s = []
              , a = r[i];
            for (let t = 0, i = a.length; t < i; t++) {
                const i = e(a[t], n);
                s.push(i)
            }
            t.morphAttributes[i] = s
        }
        t.morphTargetsRelative = this.morphTargetsRelative;
        const s = this.groups;
        for (let e = 0, n = s.length; e < n; e++) {
            const n = s[e];
            t.addGroup(n.start, n.count, n.materialIndex)
        }
        return t
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.5,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        if (e.uuid = this.uuid,
        e.type = this.type,
        "" !== this.name && (e.name = this.name),
        Object.keys(this.userData).length > 0 && (e.userData = this.userData),
        void 0 !== this.parameters) {
            const t = this.parameters;
            for (const n in t)
                void 0 !== t[n] && (e[n] = t[n]);
            return e
        }
        e.data = {
            attributes: {}
        };
        const t = this.index;
        null !== t && (e.data.index = {
            type: t.array.constructor.name,
            array: Array.prototype.slice.call(t.array)
        });
        const n = this.attributes;
        for (const t in n) {
            const i = n[t];
            e.data.attributes[t] = i.toJSON(e.data)
        }
        const i = {};
        let r = !1;
        for (const t in this.morphAttributes) {
            const n = this.morphAttributes[t]
              , s = [];
            for (let t = 0, i = n.length; t < i; t++) {
                const i = n[t];
                s.push(i.toJSON(e.data))
            }
            s.length > 0 && (i[t] = s,
            r = !0)
        }
        r && (e.data.morphAttributes = i,
        e.data.morphTargetsRelative = this.morphTargetsRelative);
        const s = this.groups;
        s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s)));
        const a = this.boundingSphere;
        return null !== a && (e.data.boundingSphere = {
            center: a.center.toArray(),
            radius: a.radius
        }),
        e
    }
    clone() {
        return (new this.constructor).copy(this)
    }
    copy(e) {
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null;
        const t = {};
        this.name = e.name;
        const n = e.index;
        null !== n && this.setIndex(n.clone(t));
        const i = e.attributes;
        for (const e in i) {
            const n = i[e];
            this.setAttribute(e, n.clone(t))
        }
        const r = e.morphAttributes;
        for (const e in r) {
            const n = []
              , i = r[e];
            for (let e = 0, r = i.length; e < r; e++)
                n.push(i[e].clone(t));
            this.morphAttributes[e] = n
        }
        this.morphTargetsRelative = e.morphTargetsRelative;
        const s = e.groups;
        for (let e = 0, t = s.length; e < t; e++) {
            const t = s[e];
            this.addGroup(t.start, t.count, t.materialIndex)
        }
        const a = e.boundingBox;
        null !== a && (this.boundingBox = a.clone());
        const o = e.boundingSphere;
        return null !== o && (this.boundingSphere = o.clone()),
        this.drawRange.start = e.drawRange.start,
        this.drawRange.count = e.drawRange.count,
        this.userData = e.userData,
        void 0 !== e.parameters && (this.parameters = Object.assign({}, e.parameters)),
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
const Wi = new Wn
  , ji = new Vn
  , Xi = new Nn
  , qi = new pn
  , Yi = new pn
  , Zi = new pn
  , Ji = new pn
  , Ki = new pn
  , Qi = new pn
  , $i = new pn
  , er = new pn
  , tr = new pn
  , nr = new Ft
  , ir = new Ft
  , rr = new Ft
  , sr = new pn
  , ar = new pn;
class or extends fi {
    constructor(e=new Vi, t=new Li) {
        super(),
        this.isMesh = !0,
        this.type = "Mesh",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
        void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
        this.material = e.material,
        this.geometry = e.geometry,
        this
    }
    updateMorphTargets() {
        const e = this.geometry.morphAttributes
          , t = Object.keys(e);
        if (t.length > 0) {
            const n = e[t[0]];
            if (void 0 !== n) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let e = 0, t = n.length; e < t; e++) {
                    const t = n[e].name || String(e);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[t] = e
                }
            }
        }
    }
    raycast(e, t) {
        const n = this.geometry
          , i = this.material
          , r = this.matrixWorld;
        if (void 0 === i)
            return;
        if (null === n.boundingSphere && n.computeBoundingSphere(),
        Xi.copy(n.boundingSphere),
        Xi.applyMatrix4(r),
        !1 === e.ray.intersectsSphere(Xi))
            return;
        if (Wi.copy(r).invert(),
        ji.copy(e.ray).applyMatrix4(Wi),
        null !== n.boundingBox && !1 === ji.intersectsBox(n.boundingBox))
            return;
        let s;
        const a = n.index
          , o = n.attributes.position
          , l = n.morphAttributes.position
          , c = n.morphTargetsRelative
          , h = n.attributes.uv
          , u = n.attributes.uv2
          , d = n.groups
          , p = n.drawRange;
        if (null !== a)
            if (Array.isArray(i))
                for (let n = 0, r = d.length; n < r; n++) {
                    const r = d[n]
                      , m = i[r.materialIndex];
                    for (let n = Math.max(r.start, p.start), i = Math.min(a.count, Math.min(r.start + r.count, p.start + p.count)); n < i; n += 3) {
                        const i = a.getX(n)
                          , d = a.getX(n + 1)
                          , p = a.getX(n + 2);
                        s = lr(this, m, e, ji, o, l, c, h, u, i, d, p),
                        s && (s.faceIndex = Math.floor(n / 3),
                        s.face.materialIndex = r.materialIndex,
                        t.push(s))
                    }
                }
            else {
                for (let n = Math.max(0, p.start), r = Math.min(a.count, p.start + p.count); n < r; n += 3) {
                    const r = a.getX(n)
                      , d = a.getX(n + 1)
                      , p = a.getX(n + 2);
                    s = lr(this, i, e, ji, o, l, c, h, u, r, d, p),
                    s && (s.faceIndex = Math.floor(n / 3),
                    t.push(s))
                }
            }
        else if (void 0 !== o)
            if (Array.isArray(i))
                for (let n = 0, r = d.length; n < r; n++) {
                    const r = d[n]
                      , a = i[r.materialIndex];
                    for (let n = Math.max(r.start, p.start), i = Math.min(o.count, Math.min(r.start + r.count, p.start + p.count)); n < i; n += 3) {
                        s = lr(this, a, e, ji, o, l, c, h, u, n, n + 1, n + 2),
                        s && (s.faceIndex = Math.floor(n / 3),
                        s.face.materialIndex = r.materialIndex,
                        t.push(s))
                    }
                }
            else {
                for (let n = Math.max(0, p.start), r = Math.min(o.count, p.start + p.count); n < r; n += 3) {
                    s = lr(this, i, e, ji, o, l, c, h, u, n, n + 1, n + 2),
                    s && (s.faceIndex = Math.floor(n / 3),
                    t.push(s))
                }
            }
    }
}
function lr(e, t, n, i, r, s, a, o, l, c, h, u) {
    qi.fromBufferAttribute(r, c),
    Yi.fromBufferAttribute(r, h),
    Zi.fromBufferAttribute(r, u);
    const d = e.morphTargetInfluences;
    if (s && d) {
        $i.set(0, 0, 0),
        er.set(0, 0, 0),
        tr.set(0, 0, 0);
        for (let e = 0, t = s.length; e < t; e++) {
            const t = d[e]
              , n = s[e];
            0 !== t && (Ji.fromBufferAttribute(n, c),
            Ki.fromBufferAttribute(n, h),
            Qi.fromBufferAttribute(n, u),
            a ? ($i.addScaledVector(Ji, t),
            er.addScaledVector(Ki, t),
            tr.addScaledVector(Qi, t)) : ($i.addScaledVector(Ji.sub(qi), t),
            er.addScaledVector(Ki.sub(Yi), t),
            tr.addScaledVector(Qi.sub(Zi), t)))
        }
        qi.add($i),
        Yi.add(er),
        Zi.add(tr)
    }
    e.isSkinnedMesh && (e.boneTransform(c, qi),
    e.boneTransform(h, Yi),
    e.boneTransform(u, Zi));
    const p = function(e, t, n, i, r, s, a, o) {
        let l;
        if (l = 1 === t.side ? i.intersectTriangle(a, s, r, !0, o) : i.intersectTriangle(r, s, a, t.side !== ae, o),
        null === l)
            return null;
        ar.copy(o),
        ar.applyMatrix4(e.matrixWorld);
        const c = n.ray.origin.distanceTo(ar);
        return c < n.near || c > n.far ? null : {
            distance: c,
            point: ar.clone(),
            object: e
        }
    }(e, t, n, i, qi, Yi, Zi, sr);
    if (p) {
        o && (nr.fromBufferAttribute(o, c),
        ir.fromBufferAttribute(o, h),
        rr.fromBufferAttribute(o, u),
        p.uv = Ai.getUV(sr, qi, Yi, Zi, nr, ir, rr, new Ft)),
        l && (nr.fromBufferAttribute(l, c),
        ir.fromBufferAttribute(l, h),
        rr.fromBufferAttribute(l, u),
        p.uv2 = Ai.getUV(sr, qi, Yi, Zi, nr, ir, rr, new Ft));
        const e = {
            a: c,
            b: h,
            c: u,
            normal: new pn,
            materialIndex: 0
        };
        Ai.getNormal(qi, Yi, Zi, e.normal),
        p.face = e
    }
    return p
}
class cr extends Vi {
    constructor(e=1, t=1, n=1, i=1, r=1, s=1) {
        super(),
        this.type = "BoxGeometry",
        this.parameters = {
            width: e,
            height: t,
            depth: n,
            widthSegments: i,
            heightSegments: r,
            depthSegments: s
        };
        const a = this;
        i = Math.floor(i),
        r = Math.floor(r),
        s = Math.floor(s);
        const o = []
          , l = []
          , c = []
          , h = [];
        let u = 0
          , d = 0;
        function p(e, t, n, i, r, s, p, m, f, g, v) {
            const x = s / f
              , y = p / g
              , _ = s / 2
              , b = p / 2
              , M = m / 2
              , w = f + 1
              , S = g + 1;
            let T = 0
              , A = 0;
            const E = new pn;
            for (let s = 0; s < S; s++) {
                const a = s * y - b;
                for (let o = 0; o < w; o++) {
                    const u = o * x - _;
                    E[e] = u * i,
                    E[t] = a * r,
                    E[n] = M,
                    l.push(E.x, E.y, E.z),
                    E[e] = 0,
                    E[t] = 0,
                    E[n] = m > 0 ? 1 : -1,
                    c.push(E.x, E.y, E.z),
                    h.push(o / f),
                    h.push(1 - s / g),
                    T += 1
                }
            }
            for (let e = 0; e < g; e++)
                for (let t = 0; t < f; t++) {
                    const n = u + t + w * e
                      , i = u + t + w * (e + 1)
                      , r = u + (t + 1) + w * (e + 1)
                      , s = u + (t + 1) + w * e;
                    o.push(n, i, s),
                    o.push(i, r, s),
                    A += 6
                }
            a.addGroup(d, A, v),
            d += A,
            u += T
        }
        p("z", "y", "x", -1, -1, n, t, e, s, r, 0),
        p("z", "y", "x", 1, -1, n, t, -e, s, r, 1),
        p("x", "z", "y", 1, 1, e, n, t, i, s, 2),
        p("x", "z", "y", 1, -1, e, n, -t, i, s, 3),
        p("x", "y", "z", 1, -1, e, t, n, i, r, 4),
        p("x", "y", "z", -1, -1, e, t, -n, i, r, 5),
        this.setIndex(o),
        this.setAttribute("position", new Ni(l,3)),
        this.setAttribute("normal", new Ni(c,3)),
        this.setAttribute("uv", new Ni(h,2))
    }
    static fromJSON(e) {
        return new cr(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)
    }
}
function hr(e) {
    const t = {};
    for (const n in e) {
        t[n] = {};
        for (const i in e[n]) {
            const r = e[n][i];
            r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? t[n][i] = r.clone() : Array.isArray(r) ? t[n][i] = r.slice() : t[n][i] = r
        }
    }
    return t
}
function ur(e) {
    const t = {};
    for (let n = 0; n < e.length; n++) {
        const i = hr(e[n]);
        for (const e in i)
            t[e] = i[e]
    }
    return t
}
const dr = {
    clone: hr,
    merge: ur
};
class pr extends Ci {
    constructor(e) {
        super(),
        this.isShaderMaterial = !0,
        this.type = "ShaderMaterial",
        this.defines = {},
        this.uniforms = {},
        this.uniformsGroups = [],
        this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
        this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",
        this.linewidth = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.clipping = !1,
        this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        },
        this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        },
        this.index0AttributeName = void 0,
        this.uniformsNeedUpdate = !1,
        this.glslVersion = null,
        void 0 !== e && this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.fragmentShader = e.fragmentShader,
        this.vertexShader = e.vertexShader,
        this.uniforms = hr(e.uniforms),
        this.uniformsGroups = function(e) {
            const t = [];
            for (let n = 0; n < e.length; n++)
                t.push(e[n].clone());
            return t
        }(e.uniformsGroups),
        this.defines = Object.assign({}, e.defines),
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.fog = e.fog,
        this.lights = e.lights,
        this.clipping = e.clipping,
        this.extensions = Object.assign({}, e.extensions),
        this.glslVersion = e.glslVersion,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        t.glslVersion = this.glslVersion,
        t.uniforms = {};
        for (const n in this.uniforms) {
            const i = this.uniforms[n].value;
            i && i.isTexture ? t.uniforms[n] = {
                type: "t",
                value: i.toJSON(e).uuid
            } : i && i.isColor ? t.uniforms[n] = {
                type: "c",
                value: i.getHex()
            } : i && i.isVector2 ? t.uniforms[n] = {
                type: "v2",
                value: i.toArray()
            } : i && i.isVector3 ? t.uniforms[n] = {
                type: "v3",
                value: i.toArray()
            } : i && i.isVector4 ? t.uniforms[n] = {
                type: "v4",
                value: i.toArray()
            } : i && i.isMatrix3 ? t.uniforms[n] = {
                type: "m3",
                value: i.toArray()
            } : i && i.isMatrix4 ? t.uniforms[n] = {
                type: "m4",
                value: i.toArray()
            } : t.uniforms[n] = {
                value: i
            }
        }
        Object.keys(this.defines).length > 0 && (t.defines = this.defines),
        t.vertexShader = this.vertexShader,
        t.fragmentShader = this.fragmentShader;
        const n = {};
        for (const e in this.extensions)
            !0 === this.extensions[e] && (n[e] = !0);
        return Object.keys(n).length > 0 && (t.extensions = n),
        t
    }
}
class mr extends fi {
    constructor() {
        super(),
        this.isCamera = !0,
        this.type = "Camera",
        this.matrixWorldInverse = new Wn,
        this.projectionMatrix = new Wn,
        this.projectionMatrixInverse = new Wn
    }
    copy(e, t) {
        return super.copy(e, t),
        this.matrixWorldInverse.copy(e.matrixWorldInverse),
        this.projectionMatrix.copy(e.projectionMatrix),
        this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
        this
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(-t[8], -t[9], -t[10]).normalize()
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    updateWorldMatrix(e, t) {
        super.updateWorldMatrix(e, t),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    clone() {
        return (new this.constructor).copy(this)
    }
}
class fr extends mr {
    constructor(e=50, t=1, n=.1, i=2e3) {
        super(),
        this.isPerspectiveCamera = !0,
        this.type = "PerspectiveCamera",
        this.fov = e,
        this.zoom = 1,
        this.near = n,
        this.far = i,
        this.focus = 10,
        this.aspect = t,
        this.view = null,
        this.filmGauge = 35,
        this.filmOffset = 0,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.fov = e.fov,
        this.zoom = e.zoom,
        this.near = e.near,
        this.far = e.far,
        this.focus = e.focus,
        this.aspect = e.aspect,
        this.view = null === e.view ? null : Object.assign({}, e.view),
        this.filmGauge = e.filmGauge,
        this.filmOffset = e.filmOffset,
        this
    }
    setFocalLength(e) {
        const t = .5 * this.getFilmHeight() / e;
        this.fov = 2 * Et * Math.atan(t),
        this.updateProjectionMatrix()
    }
    getFocalLength() {
        const e = Math.tan(.5 * At * this.fov);
        return .5 * this.getFilmHeight() / e
    }
    getEffectiveFOV() {
        return 2 * Et * Math.atan(Math.tan(.5 * At * this.fov) / this.zoom)
    }
    getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1)
    }
    getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1)
    }
    setViewOffset(e, t, n, i, r, s) {
        this.aspect = e / t,
        null === this.view && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = n,
        this.view.offsetY = i,
        this.view.width = r,
        this.view.height = s,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        null !== this.view && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = this.near;
        let t = e * Math.tan(.5 * At * this.fov) / this.zoom
          , n = 2 * t
          , i = this.aspect * n
          , r = -.5 * i;
        const s = this.view;
        if (null !== this.view && this.view.enabled) {
            const e = s.fullWidth
              , a = s.fullHeight;
            r += s.offsetX * i / e,
            t -= s.offsetY * n / a,
            i *= s.width / e,
            n *= s.height / a
        }
        const a = this.filmOffset;
        0 !== a && (r += e * a / this.getFilmWidth()),
        this.projectionMatrix.makePerspective(r, r + i, t, t - n, e, this.far),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.fov = this.fov,
        t.object.zoom = this.zoom,
        t.object.near = this.near,
        t.object.far = this.far,
        t.object.focus = this.focus,
        t.object.aspect = this.aspect,
        null !== this.view && (t.object.view = Object.assign({}, this.view)),
        t.object.filmGauge = this.filmGauge,
        t.object.filmOffset = this.filmOffset,
        t
    }
}
const gr = 90;
class vr extends fi {
    constructor(e, t, n) {
        super(),
        this.type = "CubeCamera",
        this.renderTarget = n;
        const i = new fr(gr,1,e,t);
        i.layers = this.layers,
        i.up.set(0, -1, 0),
        i.lookAt(new pn(1,0,0)),
        this.add(i);
        const r = new fr(gr,1,e,t);
        r.layers = this.layers,
        r.up.set(0, -1, 0),
        r.lookAt(new pn(-1,0,0)),
        this.add(r);
        const s = new fr(gr,1,e,t);
        s.layers = this.layers,
        s.up.set(0, 0, 1),
        s.lookAt(new pn(0,1,0)),
        this.add(s);
        const a = new fr(gr,1,e,t);
        a.layers = this.layers,
        a.up.set(0, 0, -1),
        a.lookAt(new pn(0,-1,0)),
        this.add(a);
        const o = new fr(gr,1,e,t);
        o.layers = this.layers,
        o.up.set(0, -1, 0),
        o.lookAt(new pn(0,0,1)),
        this.add(o);
        const l = new fr(gr,1,e,t);
        l.layers = this.layers,
        l.up.set(0, -1, 0),
        l.lookAt(new pn(0,0,-1)),
        this.add(l)
    }
    update(e, t) {
        null === this.parent && this.updateMatrixWorld();
        const n = this.renderTarget
          , [i,r,s,a,o,l] = this.children
          , c = e.getRenderTarget()
          , h = e.toneMapping
          , u = e.xr.enabled;
        e.toneMapping = 0,
        e.xr.enabled = !1;
        const d = n.texture.generateMipmaps;
        n.texture.generateMipmaps = !1,
        e.setRenderTarget(n, 0),
        e.render(t, i),
        e.setRenderTarget(n, 1),
        e.render(t, r),
        e.setRenderTarget(n, 2),
        e.render(t, s),
        e.setRenderTarget(n, 3),
        e.render(t, a),
        e.setRenderTarget(n, 4),
        e.render(t, o),
        n.texture.generateMipmaps = d,
        e.setRenderTarget(n, 5),
        e.render(t, l),
        e.setRenderTarget(c),
        e.toneMapping = h,
        e.xr.enabled = u,
        n.texture.needsPMREMUpdate = !0
    }
}
class xr extends on {
    constructor(e, t, n, i, r, s, a, o, l, c) {
        super(e = void 0 !== e ? e : [], t = void 0 !== t ? t : de, n, i, r, s, a, o, l, c),
        this.isCubeTexture = !0,
        this.flipY = !1
    }
    get images() {
        return this.image
    }
    set images(e) {
        this.image = e
    }
}
class yr extends cn {
    constructor(e, t={}) {
        super(e, e, t),
        this.isWebGLCubeRenderTarget = !0;
        const n = {
            width: e,
            height: e,
            depth: 1
        }
          , i = [n, n, n, n, n, n];
        this.texture = new xr(i,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),
        this.texture.isRenderTargetTexture = !0,
        this.texture.generateMipmaps = void 0 !== t.generateMipmaps && t.generateMipmaps,
        this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : we
    }
    fromEquirectangularTexture(e, t) {
        this.texture.type = t.type,
        this.texture.encoding = t.encoding,
        this.texture.generateMipmaps = t.generateMipmaps,
        this.texture.minFilter = t.minFilter,
        this.texture.magFilter = t.magFilter;
        const n = {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
            fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
        }
          , i = new cr(5,5,5)
          , r = new pr({
            name: "CubemapFromEquirect",
            uniforms: hr(n.uniforms),
            vertexShader: n.vertexShader,
            fragmentShader: n.fragmentShader,
            side: 1,
            blending: 0
        });
        r.uniforms.tEquirect.value = t;
        const s = new or(i,r)
          , a = t.minFilter;
        t.minFilter === Te && (t.minFilter = we);
        return new vr(1,10,this).update(e, s),
        t.minFilter = a,
        s.geometry.dispose(),
        s.material.dispose(),
        this
    }
    clear(e, t, n, i) {
        const r = e.getRenderTarget();
        for (let r = 0; r < 6; r++)
            e.setRenderTarget(this, r),
            e.clear(t, n, i);
        e.setRenderTarget(r)
    }
}
const _r = new pn
  , br = new pn
  , Mr = new Bt;
class wr {
    constructor(e=new pn(1,0,0), t=0) {
        this.isPlane = !0,
        this.normal = e,
        this.constant = t
    }
    set(e, t) {
        return this.normal.copy(e),
        this.constant = t,
        this
    }
    setComponents(e, t, n, i) {
        return this.normal.set(e, t, n),
        this.constant = i,
        this
    }
    setFromNormalAndCoplanarPoint(e, t) {
        return this.normal.copy(e),
        this.constant = -t.dot(this.normal),
        this
    }
    setFromCoplanarPoints(e, t, n) {
        const i = _r.subVectors(n, t).cross(br.subVectors(e, t)).normalize();
        return this.setFromNormalAndCoplanarPoint(i, e),
        this
    }
    copy(e) {
        return this.normal.copy(e.normal),
        this.constant = e.constant,
        this
    }
    normalize() {
        const e = 1 / this.normal.length();
        return this.normal.multiplyScalar(e),
        this.constant *= e,
        this
    }
    negate() {
        return this.constant *= -1,
        this.normal.negate(),
        this
    }
    distanceToPoint(e) {
        return this.normal.dot(e) + this.constant
    }
    distanceToSphere(e) {
        return this.distanceToPoint(e.center) - e.radius
    }
    projectPoint(e, t) {
        return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
    }
    intersectLine(e, t) {
        const n = e.delta(_r)
          , i = this.normal.dot(n);
        if (0 === i)
            return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
        const r = -(e.start.dot(this.normal) + this.constant) / i;
        return r < 0 || r > 1 ? null : t.copy(n).multiplyScalar(r).add(e.start)
    }
    intersectsLine(e) {
        const t = this.distanceToPoint(e.start)
          , n = this.distanceToPoint(e.end);
        return t < 0 && n > 0 || n < 0 && t > 0
    }
    intersectsBox(e) {
        return e.intersectsPlane(this)
    }
    intersectsSphere(e) {
        return e.intersectsPlane(this)
    }
    coplanarPoint(e) {
        return e.copy(this.normal).multiplyScalar(-this.constant)
    }
    applyMatrix4(e, t) {
        const n = t || Mr.getNormalMatrix(e)
          , i = this.coplanarPoint(_r).applyMatrix4(e)
          , r = this.normal.applyMatrix3(n).normalize();
        return this.constant = -i.dot(r),
        this
    }
    translate(e) {
        return this.constant -= e.dot(this.normal),
        this
    }
    equals(e) {
        return e.normal.equals(this.normal) && e.constant === this.constant
    }
    clone() {
        return (new this.constructor).copy(this)
    }
}
const Sr = new Nn
  , Tr = new pn;
class Ar {
    constructor(e=new wr, t=new wr, n=new wr, i=new wr, r=new wr, s=new wr) {
        this.planes = [e, t, n, i, r, s]
    }
    set(e, t, n, i, r, s) {
        const a = this.planes;
        return a[0].copy(e),
        a[1].copy(t),
        a[2].copy(n),
        a[3].copy(i),
        a[4].copy(r),
        a[5].copy(s),
        this
    }
    copy(e) {
        const t = this.planes;
        for (let n = 0; n < 6; n++)
            t[n].copy(e.planes[n]);
        return this
    }
    setFromProjectionMatrix(e) {
        const t = this.planes
          , n = e.elements
          , i = n[0]
          , r = n[1]
          , s = n[2]
          , a = n[3]
          , o = n[4]
          , l = n[5]
          , c = n[6]
          , h = n[7]
          , u = n[8]
          , d = n[9]
          , p = n[10]
          , m = n[11]
          , f = n[12]
          , g = n[13]
          , v = n[14]
          , x = n[15];
        return t[0].setComponents(a - i, h - o, m - u, x - f).normalize(),
        t[1].setComponents(a + i, h + o, m + u, x + f).normalize(),
        t[2].setComponents(a + r, h + l, m + d, x + g).normalize(),
        t[3].setComponents(a - r, h - l, m - d, x - g).normalize(),
        t[4].setComponents(a - s, h - c, m - p, x - v).normalize(),
        t[5].setComponents(a + s, h + c, m + p, x + v).normalize(),
        this
    }
    intersectsObject(e) {
        const t = e.geometry;
        return null === t.boundingSphere && t.computeBoundingSphere(),
        Sr.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),
        this.intersectsSphere(Sr)
    }
    intersectsSprite(e) {
        return Sr.center.set(0, 0, 0),
        Sr.radius = .7071067811865476,
        Sr.applyMatrix4(e.matrixWorld),
        this.intersectsSphere(Sr)
    }
    intersectsSphere(e) {
        const t = this.planes
          , n = e.center
          , i = -e.radius;
        for (let e = 0; e < 6; e++) {
            if (t[e].distanceToPoint(n) < i)
                return !1
        }
        return !0
    }
    intersectsBox(e) {
        const t = this.planes;
        for (let n = 0; n < 6; n++) {
            const i = t[n];
            if (Tr.x = i.normal.x > 0 ? e.max.x : e.min.x,
            Tr.y = i.normal.y > 0 ? e.max.y : e.min.y,
            Tr.z = i.normal.z > 0 ? e.max.z : e.min.z,
            i.distanceToPoint(Tr) < 0)
                return !1
        }
        return !0
    }
    containsPoint(e) {
        const t = this.planes;
        for (let n = 0; n < 6; n++)
            if (t[n].distanceToPoint(e) < 0)
                return !1;
        return !0
    }
    clone() {
        return (new this.constructor).copy(this)
    }
}
function Er() {
    let e = null
      , t = !1
      , n = null
      , i = null;
    function r(t, s) {
        n(t, s),
        i = e.requestAnimationFrame(r)
    }
    return {
        start: function() {
            !0 !== t && null !== n && (i = e.requestAnimationFrame(r),
            t = !0)
        },
        stop: function() {
            e.cancelAnimationFrame(i),
            t = !1
        },
        setAnimationLoop: function(e) {
            n = e
        },
        setContext: function(t) {
            e = t
        }
    }
}
function Cr(e, t) {
    const n = t.isWebGL2
      , i = new WeakMap;
    return {
        get: function(e) {
            return e.isInterleavedBufferAttribute && (e = e.data),
            i.get(e)
        },
        remove: function(t) {
            t.isInterleavedBufferAttribute && (t = t.data);
            const n = i.get(t);
            n && (e.deleteBuffer(n.buffer),
            i.delete(t))
        },
        update: function(t, r) {
            if (t.isGLBufferAttribute) {
                const e = i.get(t);
                return void ((!e || e.version < t.version) && i.set(t, {
                    buffer: t.buffer,
                    type: t.type,
                    bytesPerElement: t.elementSize,
                    version: t.version
                }))
            }
            t.isInterleavedBufferAttribute && (t = t.data);
            const s = i.get(t);
            void 0 === s ? i.set(t, function(t, i) {
                const r = t.array
                  , s = t.usage
                  , a = e.createBuffer();
                let o;
                if (e.bindBuffer(i, a),
                e.bufferData(i, r, s),
                t.onUploadCallback(),
                r instanceof Float32Array)
                    o = 5126;
                else if (r instanceof Uint16Array)
                    if (t.isFloat16BufferAttribute) {
                        if (!n)
                            throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
                        o = 5131
                    } else
                        o = 5123;
                else if (r instanceof Int16Array)
                    o = 5122;
                else if (r instanceof Uint32Array)
                    o = 5125;
                else if (r instanceof Int32Array)
                    o = 5124;
                else if (r instanceof Int8Array)
                    o = 5120;
                else if (r instanceof Uint8Array)
                    o = 5121;
                else {
                    if (!(r instanceof Uint8ClampedArray))
                        throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + r);
                    o = 5121
                }
                return {
                    buffer: a,
                    type: o,
                    bytesPerElement: r.BYTES_PER_ELEMENT,
                    version: t.version
                }
            }(t, r)) : s.version < t.version && (!function(t, i, r) {
                const s = i.array
                  , a = i.updateRange;
                e.bindBuffer(r, t),
                -1 === a.count ? e.bufferSubData(r, 0, s) : (n ? e.bufferSubData(r, a.offset * s.BYTES_PER_ELEMENT, s, a.offset, a.count) : e.bufferSubData(r, a.offset * s.BYTES_PER_ELEMENT, s.subarray(a.offset, a.offset + a.count)),
                a.count = -1)
            }(s.buffer, t, r),
            s.version = t.version)
        }
    }
}
class Lr extends Vi {
    constructor(e=1, t=1, n=1, i=1) {
        super(),
        this.type = "PlaneGeometry",
        this.parameters = {
            width: e,
            height: t,
            widthSegments: n,
            heightSegments: i
        };
        const r = e / 2
          , s = t / 2
          , a = Math.floor(n)
          , o = Math.floor(i)
          , l = a + 1
          , c = o + 1
          , h = e / a
          , u = t / o
          , d = []
          , p = []
          , m = []
          , f = [];
        for (let e = 0; e < c; e++) {
            const t = e * u - s;
            for (let n = 0; n < l; n++) {
                const i = n * h - r;
                p.push(i, -t, 0),
                m.push(0, 0, 1),
                f.push(n / a),
                f.push(1 - e / o)
            }
        }
        for (let e = 0; e < o; e++)
            for (let t = 0; t < a; t++) {
                const n = t + l * e
                  , i = t + l * (e + 1)
                  , r = t + 1 + l * (e + 1)
                  , s = t + 1 + l * e;
                d.push(n, i, s),
                d.push(i, r, s)
            }
        this.setIndex(d),
        this.setAttribute("position", new Ni(p,3)),
        this.setAttribute("normal", new Ni(m,3)),
        this.setAttribute("uv", new Ni(f,2))
    }
    static fromJSON(e) {
        return new Lr(e.width,e.height,e.widthSegments,e.heightSegments)
    }
}
const Rr = {
    alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
    alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
    alphatest_fragment: "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
    alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
    aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
    aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
    begin_vertex: "vec3 transformed = vec3( position );",
    beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
    bsdfs: "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif",
    iridescence_fragment: "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\t return vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat R21 = R12;\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
    bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
    clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
    clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
    clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
    clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
    color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
    color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
    color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
    color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
    common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
    cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_v0 0.339\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_v1 0.276\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_v4 0.046\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_v5 0.016\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_v6 0.0038\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
    defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
    displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
    displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
    emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
    emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
    encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
    encodings_pars_fragment: "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
    envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
    envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
    envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
    envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
    envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",
    envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
    fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
    fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
    fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
    fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
    gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",
    lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
    lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
    lights_lambert_fragment: "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
    lights_lambert_pars_fragment: "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert\n#define Material_LightProbeLOD( material )\t(0)",
    lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
    lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
    lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
    lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
    lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
    lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif",
    lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n\t#else\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
    lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
    lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
    lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
    logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
    logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
    logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
    logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
    map_fragment: "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
    map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
    map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
    map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
    metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
    metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
    morphcolor_vertex: "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
    morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
    morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
    morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
    normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
    normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
    normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
    normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
    normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
    normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
    clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
    clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
    clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
    iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
    output_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
    packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
    premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
    project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
    dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
    dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
    roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
    roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
    shadowmap_pars_fragment: "#if NUM_SPOT_LIGHT_COORDS > 0\n  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n  uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
    shadowmap_pars_vertex: "#if NUM_SPOT_LIGHT_COORDS > 0\n  uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
    shadowmap_vertex: "#if defined( USE_SHADOWMAP ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_COORDS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
    shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
    skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
    skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif",
    skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
    skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
    specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
    specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
    tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
    tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
    transmission_fragment: "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );\n#endif",
    transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",
    uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
    uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
    uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
    uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
    uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
    uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
    worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
    background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
    background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tgl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n\t#endif\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
    cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
    cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
    depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
    depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
    distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
    distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
    equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
    equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
    linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
    linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
    meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
    meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    meshlambert_vert: "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
    meshlambert_frag: "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
    meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
    meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
    meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
    meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
    meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
    meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
    points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
    shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
    shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
    sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
    sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"
}
  , Pr = {
    common: {
        diffuse: {
            value: new en(16777215)
        },
        opacity: {
            value: 1
        },
        map: {
            value: null
        },
        uvTransform: {
            value: new Bt
        },
        uv2Transform: {
            value: new Bt
        },
        alphaMap: {
            value: null
        },
        alphaTest: {
            value: 0
        }
    },
    specularmap: {
        specularMap: {
            value: null
        }
    },
    envmap: {
        envMap: {
            value: null
        },
        flipEnvMap: {
            value: -1
        },
        reflectivity: {
            value: 1
        },
        ior: {
            value: 1.5
        },
        refractionRatio: {
            value: .98
        }
    },
    aomap: {
        aoMap: {
            value: null
        },
        aoMapIntensity: {
            value: 1
        }
    },
    lightmap: {
        lightMap: {
            value: null
        },
        lightMapIntensity: {
            value: 1
        }
    },
    emissivemap: {
        emissiveMap: {
            value: null
        }
    },
    bumpmap: {
        bumpMap: {
            value: null
        },
        bumpScale: {
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            value: null
        },
        normalScale: {
            value: new Ft(1,1)
        }
    },
    displacementmap: {
        displacementMap: {
            value: null
        },
        displacementScale: {
            value: 1
        },
        displacementBias: {
            value: 0
        }
    },
    roughnessmap: {
        roughnessMap: {
            value: null
        }
    },
    metalnessmap: {
        metalnessMap: {
            value: null
        }
    },
    gradientmap: {
        gradientMap: {
            value: null
        }
    },
    fog: {
        fogDensity: {
            value: 25e-5
        },
        fogNear: {
            value: 1
        },
        fogFar: {
            value: 2e3
        },
        fogColor: {
            value: new en(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            value: []
        },
        lightProbe: {
            value: []
        },
        directionalLights: {
            value: [],
            properties: {
                direction: {},
                color: {}
            }
        },
        directionalLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        directionalShadowMap: {
            value: []
        },
        directionalShadowMatrix: {
            value: []
        },
        spotLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {}
            }
        },
        spotLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        spotLightMap: {
            value: []
        },
        spotShadowMap: {
            value: []
        },
        spotLightMatrix: {
            value: []
        },
        pointLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                decay: {},
                distance: {}
            }
        },
        pointLightShadows: {
            value: [],
            properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {}
            }
        },
        pointShadowMap: {
            value: []
        },
        pointShadowMatrix: {
            value: []
        },
        hemisphereLights: {
            value: [],
            properties: {
                direction: {},
                skyColor: {},
                groundColor: {}
            }
        },
        rectAreaLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                width: {},
                height: {}
            }
        },
        ltc_1: {
            value: null
        },
        ltc_2: {
            value: null
        }
    },
    points: {
        diffuse: {
            value: new en(16777215)
        },
        opacity: {
            value: 1
        },
        size: {
            value: 1
        },
        scale: {
            value: 1
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        alphaTest: {
            value: 0
        },
        uvTransform: {
            value: new Bt
        }
    },
    sprite: {
        diffuse: {
            value: new en(16777215)
        },
        opacity: {
            value: 1
        },
        center: {
            value: new Ft(.5,.5)
        },
        rotation: {
            value: 0
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        alphaTest: {
            value: 0
        },
        uvTransform: {
            value: new Bt
        }
    }
}
  , Ir = {
    basic: {
        uniforms: ur([Pr.common, Pr.specularmap, Pr.envmap, Pr.aomap, Pr.lightmap, Pr.fog]),
        vertexShader: Rr.meshbasic_vert,
        fragmentShader: Rr.meshbasic_frag
    },
    lambert: {
        uniforms: ur([Pr.common, Pr.specularmap, Pr.envmap, Pr.aomap, Pr.lightmap, Pr.emissivemap, Pr.bumpmap, Pr.normalmap, Pr.displacementmap, Pr.fog, Pr.lights, {
            emissive: {
                value: new en(0)
            }
        }]),
        vertexShader: Rr.meshlambert_vert,
        fragmentShader: Rr.meshlambert_frag
    },
    phong: {
        uniforms: ur([Pr.common, Pr.specularmap, Pr.envmap, Pr.aomap, Pr.lightmap, Pr.emissivemap, Pr.bumpmap, Pr.normalmap, Pr.displacementmap, Pr.fog, Pr.lights, {
            emissive: {
                value: new en(0)
            },
            specular: {
                value: new en(1118481)
            },
            shininess: {
                value: 30
            }
        }]),
        vertexShader: Rr.meshphong_vert,
        fragmentShader: Rr.meshphong_frag
    },
    standard: {
        uniforms: ur([Pr.common, Pr.envmap, Pr.aomap, Pr.lightmap, Pr.emissivemap, Pr.bumpmap, Pr.normalmap, Pr.displacementmap, Pr.roughnessmap, Pr.metalnessmap, Pr.fog, Pr.lights, {
            emissive: {
                value: new en(0)
            },
            roughness: {
                value: 1
            },
            metalness: {
                value: 0
            },
            envMapIntensity: {
                value: 1
            }
        }]),
        vertexShader: Rr.meshphysical_vert,
        fragmentShader: Rr.meshphysical_frag
    },
    toon: {
        uniforms: ur([Pr.common, Pr.aomap, Pr.lightmap, Pr.emissivemap, Pr.bumpmap, Pr.normalmap, Pr.displacementmap, Pr.gradientmap, Pr.fog, Pr.lights, {
            emissive: {
                value: new en(0)
            }
        }]),
        vertexShader: Rr.meshtoon_vert,
        fragmentShader: Rr.meshtoon_frag
    },
    matcap: {
        uniforms: ur([Pr.common, Pr.bumpmap, Pr.normalmap, Pr.displacementmap, Pr.fog, {
            matcap: {
                value: null
            }
        }]),
        vertexShader: Rr.meshmatcap_vert,
        fragmentShader: Rr.meshmatcap_frag
    },
    points: {
        uniforms: ur([Pr.points, Pr.fog]),
        vertexShader: Rr.points_vert,
        fragmentShader: Rr.points_frag
    },
    dashed: {
        uniforms: ur([Pr.common, Pr.fog, {
            scale: {
                value: 1
            },
            dashSize: {
                value: 1
            },
            totalSize: {
                value: 2
            }
        }]),
        vertexShader: Rr.linedashed_vert,
        fragmentShader: Rr.linedashed_frag
    },
    depth: {
        uniforms: ur([Pr.common, Pr.displacementmap]),
        vertexShader: Rr.depth_vert,
        fragmentShader: Rr.depth_frag
    },
    normal: {
        uniforms: ur([Pr.common, Pr.bumpmap, Pr.normalmap, Pr.displacementmap, {
            opacity: {
                value: 1
            }
        }]),
        vertexShader: Rr.meshnormal_vert,
        fragmentShader: Rr.meshnormal_frag
    },
    sprite: {
        uniforms: ur([Pr.sprite, Pr.fog]),
        vertexShader: Rr.sprite_vert,
        fragmentShader: Rr.sprite_frag
    },
    background: {
        uniforms: {
            uvTransform: {
                value: new Bt
            },
            t2D: {
                value: null
            }
        },
        vertexShader: Rr.background_vert,
        fragmentShader: Rr.background_frag
    },
    cube: {
        uniforms: ur([Pr.envmap, {
            opacity: {
                value: 1
            }
        }]),
        vertexShader: Rr.cube_vert,
        fragmentShader: Rr.cube_frag
    },
    equirect: {
        uniforms: {
            tEquirect: {
                value: null
            }
        },
        vertexShader: Rr.equirect_vert,
        fragmentShader: Rr.equirect_frag
    },
    distanceRGBA: {
        uniforms: ur([Pr.common, Pr.displacementmap, {
            referencePosition: {
                value: new pn
            },
            nearDistance: {
                value: 1
            },
            farDistance: {
                value: 1e3
            }
        }]),
        vertexShader: Rr.distanceRGBA_vert,
        fragmentShader: Rr.distanceRGBA_frag
    },
    shadow: {
        uniforms: ur([Pr.lights, Pr.fog, {
            color: {
                value: new en(0)
            },
            opacity: {
                value: 1
            }
        }]),
        vertexShader: Rr.shadow_vert,
        fragmentShader: Rr.shadow_frag
    }
};
function Dr(e, t, n, i, r, s) {
    const a = new en(0);
    let o, l, c = !0 === r ? 0 : 1, h = null, u = 0, d = null;
    function p(e, t) {
        n.buffers.color.setClear(e.r, e.g, e.b, t, s)
    }
    return {
        getClearColor: function() {
            return a
        },
        setClearColor: function(e, t=1) {
            a.set(e),
            c = t,
            p(a, c)
        },
        getClearAlpha: function() {
            return c
        },
        setClearAlpha: function(e) {
            c = e,
            p(a, c)
        },
        render: function(n, r) {
            let s = !1
              , m = !0 === r.isScene ? r.background : null;
            m && m.isTexture && (m = t.get(m));
            const f = e.xr
              , g = f.getSession && f.getSession();
            g && "additive" === g.environmentBlendMode && (m = null),
            null === m ? p(a, c) : m && m.isColor && (p(m, 1),
            s = !0),
            (e.autoClear || s) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
            m && (m.isCubeTexture || m.mapping === ge) ? (void 0 === l && (l = new or(new cr(1,1,1),new pr({
                name: "BackgroundCubeMaterial",
                uniforms: hr(Ir.cube.uniforms),
                vertexShader: Ir.cube.vertexShader,
                fragmentShader: Ir.cube.fragmentShader,
                side: 1,
                depthTest: !1,
                depthWrite: !1,
                fog: !1
            })),
            l.geometry.deleteAttribute("normal"),
            l.geometry.deleteAttribute("uv"),
            l.onBeforeRender = function(e, t, n) {
                this.matrixWorld.copyPosition(n.matrixWorld)
            }
            ,
            Object.defineProperty(l.material, "envMap", {
                get: function() {
                    return this.uniforms.envMap.value
                }
            }),
            i.update(l)),
            l.material.uniforms.envMap.value = m,
            l.material.uniforms.flipEnvMap.value = m.isCubeTexture && !1 === m.isRenderTargetTexture ? -1 : 1,
            h === m && u === m.version && d === e.toneMapping || (l.material.needsUpdate = !0,
            h = m,
            u = m.version,
            d = e.toneMapping),
            l.layers.enableAll(),
            n.unshift(l, l.geometry, l.material, 0, 0, null)) : m && m.isTexture && (void 0 === o && (o = new or(new Lr(2,2),new pr({
                name: "BackgroundMaterial",
                uniforms: hr(Ir.background.uniforms),
                vertexShader: Ir.background.vertexShader,
                fragmentShader: Ir.background.fragmentShader,
                side: 0,
                depthTest: !1,
                depthWrite: !1,
                fog: !1
            })),
            o.geometry.deleteAttribute("normal"),
            Object.defineProperty(o.material, "map", {
                get: function() {
                    return this.uniforms.t2D.value
                }
            }),
            i.update(o)),
            o.material.uniforms.t2D.value = m,
            !0 === m.matrixAutoUpdate && m.updateMatrix(),
            o.material.uniforms.uvTransform.value.copy(m.matrix),
            h === m && u === m.version && d === e.toneMapping || (o.material.needsUpdate = !0,
            h = m,
            u = m.version,
            d = e.toneMapping),
            o.layers.enableAll(),
            n.unshift(o, o.geometry, o.material, 0, 0, null))
        }
    }
}
function Or(e, t, n, i) {
    const r = e.getParameter(34921)
      , s = i.isWebGL2 ? null : t.get("OES_vertex_array_object")
      , a = i.isWebGL2 || null !== s
      , o = {}
      , l = p(null);
    let c = l
      , h = !1;
    function u(t) {
        return i.isWebGL2 ? e.bindVertexArray(t) : s.bindVertexArrayOES(t)
    }
    function d(t) {
        return i.isWebGL2 ? e.deleteVertexArray(t) : s.deleteVertexArrayOES(t)
    }
    function p(e) {
        const t = []
          , n = []
          , i = [];
        for (let e = 0; e < r; e++)
            t[e] = 0,
            n[e] = 0,
            i[e] = 0;
        return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: t,
            enabledAttributes: n,
            attributeDivisors: i,
            object: e,
            attributes: {},
            index: null
        }
    }
    function m() {
        const e = c.newAttributes;
        for (let t = 0, n = e.length; t < n; t++)
            e[t] = 0
    }
    function f(e) {
        g(e, 0)
    }
    function g(n, r) {
        const s = c.newAttributes
          , a = c.enabledAttributes
          , o = c.attributeDivisors;
        if (s[n] = 1,
        0 === a[n] && (e.enableVertexAttribArray(n),
        a[n] = 1),
        o[n] !== r) {
            (i.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r),
            o[n] = r
        }
    }
    function v() {
        const t = c.newAttributes
          , n = c.enabledAttributes;
        for (let i = 0, r = n.length; i < r; i++)
            n[i] !== t[i] && (e.disableVertexAttribArray(i),
            n[i] = 0)
    }
    function x(t, n, r, s, a, o) {
        !0 !== i.isWebGL2 || 5124 !== r && 5125 !== r ? e.vertexAttribPointer(t, n, r, s, a, o) : e.vertexAttribIPointer(t, n, r, a, o)
    }
    function y() {
        _(),
        h = !0,
        c !== l && (c = l,
        u(c.object))
    }
    function _() {
        l.geometry = null,
        l.program = null,
        l.wireframe = !1
    }
    return {
        setup: function(r, l, d, y, _) {
            let b = !1;
            if (a) {
                const t = function(t, n, r) {
                    const a = !0 === r.wireframe;
                    let l = o[t.id];
                    void 0 === l && (l = {},
                    o[t.id] = l);
                    let c = l[n.id];
                    void 0 === c && (c = {},
                    l[n.id] = c);
                    let h = c[a];
                    void 0 === h && (h = p(i.isWebGL2 ? e.createVertexArray() : s.createVertexArrayOES()),
                    c[a] = h);
                    return h
                }(y, d, l);
                c !== t && (c = t,
                u(c.object)),
                b = function(e, t, n, i) {
                    const r = c.attributes
                      , s = t.attributes;
                    let a = 0;
                    const o = n.getAttributes();
                    for (const t in o) {
                        if (o[t].location >= 0) {
                            const n = r[t];
                            let i = s[t];
                            if (void 0 === i && ("instanceMatrix" === t && e.instanceMatrix && (i = e.instanceMatrix),
                            "instanceColor" === t && e.instanceColor && (i = e.instanceColor)),
                            void 0 === n)
                                return !0;
                            if (n.attribute !== i)
                                return !0;
                            if (i && n.data !== i.data)
                                return !0;
                            a++
                        }
                    }
                    return c.attributesNum !== a || c.index !== i
                }(r, y, d, _),
                b && function(e, t, n, i) {
                    const r = {}
                      , s = t.attributes;
                    let a = 0;
                    const o = n.getAttributes();
                    for (const t in o) {
                        if (o[t].location >= 0) {
                            let n = s[t];
                            void 0 === n && ("instanceMatrix" === t && e.instanceMatrix && (n = e.instanceMatrix),
                            "instanceColor" === t && e.instanceColor && (n = e.instanceColor));
                            const i = {};
                            i.attribute = n,
                            n && n.data && (i.data = n.data),
                            r[t] = i,
                            a++
                        }
                    }
                    c.attributes = r,
                    c.attributesNum = a,
                    c.index = i
                }(r, y, d, _)
            } else {
                const e = !0 === l.wireframe;
                c.geometry === y.id && c.program === d.id && c.wireframe === e || (c.geometry = y.id,
                c.program = d.id,
                c.wireframe = e,
                b = !0)
            }
            null !== _ && n.update(_, 34963),
            (b || h) && (h = !1,
            function(r, s, a, o) {
                if (!1 === i.isWebGL2 && (r.isInstancedMesh || o.isInstancedBufferGeometry) && null === t.get("ANGLE_instanced_arrays"))
                    return;
                m();
                const l = o.attributes
                  , c = a.getAttributes()
                  , h = s.defaultAttributeValues;
                for (const t in c) {
                    const i = c[t];
                    if (i.location >= 0) {
                        let s = l[t];
                        if (void 0 === s && ("instanceMatrix" === t && r.instanceMatrix && (s = r.instanceMatrix),
                        "instanceColor" === t && r.instanceColor && (s = r.instanceColor)),
                        void 0 !== s) {
                            const t = s.normalized
                              , a = s.itemSize
                              , l = n.get(s);
                            if (void 0 === l)
                                continue;
                            const c = l.buffer
                              , h = l.type
                              , u = l.bytesPerElement;
                            if (s.isInterleavedBufferAttribute) {
                                const n = s.data
                                  , l = n.stride
                                  , d = s.offset;
                                if (n.isInstancedInterleavedBuffer) {
                                    for (let e = 0; e < i.locationSize; e++)
                                        g(i.location + e, n.meshPerAttribute);
                                    !0 !== r.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = n.meshPerAttribute * n.count)
                                } else
                                    for (let e = 0; e < i.locationSize; e++)
                                        f(i.location + e);
                                e.bindBuffer(34962, c);
                                for (let e = 0; e < i.locationSize; e++)
                                    x(i.location + e, a / i.locationSize, h, t, l * u, (d + a / i.locationSize * e) * u)
                            } else {
                                if (s.isInstancedBufferAttribute) {
                                    for (let e = 0; e < i.locationSize; e++)
                                        g(i.location + e, s.meshPerAttribute);
                                    !0 !== r.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = s.meshPerAttribute * s.count)
                                } else
                                    for (let e = 0; e < i.locationSize; e++)
                                        f(i.location + e);
                                e.bindBuffer(34962, c);
                                for (let e = 0; e < i.locationSize; e++)
                                    x(i.location + e, a / i.locationSize, h, t, a * u, a / i.locationSize * e * u)
                            }
                        } else if (void 0 !== h) {
                            const n = h[t];
                            if (void 0 !== n)
                                switch (n.length) {
                                case 2:
                                    e.vertexAttrib2fv(i.location, n);
                                    break;
                                case 3:
                                    e.vertexAttrib3fv(i.location, n);
                                    break;
                                case 4:
                                    e.vertexAttrib4fv(i.location, n);
                                    break;
                                default:
                                    e.vertexAttrib1fv(i.location, n)
                                }
                        }
                    }
                }
                v()
            }(r, l, d, y),
            null !== _ && e.bindBuffer(34963, n.get(_).buffer))
        },
        reset: y,
        resetDefaultState: _,
        dispose: function() {
            y();
            for (const e in o) {
                const t = o[e];
                for (const e in t) {
                    const n = t[e];
                    for (const e in n)
                        d(n[e].object),
                        delete n[e];
                    delete t[e]
                }
                delete o[e]
            }
        },
        releaseStatesOfGeometry: function(e) {
            if (void 0 === o[e.id])
                return;
            const t = o[e.id];
            for (const e in t) {
                const n = t[e];
                for (const e in n)
                    d(n[e].object),
                    delete n[e];
                delete t[e]
            }
            delete o[e.id]
        },
        releaseStatesOfProgram: function(e) {
            for (const t in o) {
                const n = o[t];
                if (void 0 === n[e.id])
                    continue;
                const i = n[e.id];
                for (const e in i)
                    d(i[e].object),
                    delete i[e];
                delete n[e.id]
            }
        },
        initAttributes: m,
        enableAttribute: f,
        disableUnusedAttributes: v
    }
}
function Nr(e, t, n, i) {
    const r = i.isWebGL2;
    let s;
    this.setMode = function(e) {
        s = e
    }
    ,
    this.render = function(t, i) {
        e.drawArrays(s, t, i),
        n.update(i, s, 1)
    }
    ,
    this.renderInstances = function(i, a, o) {
        if (0 === o)
            return;
        let l, c;
        if (r)
            l = e,
            c = "drawArraysInstanced";
        else if (l = t.get("ANGLE_instanced_arrays"),
        c = "drawArraysInstancedANGLE",
        null === l)
            return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        l[c](s, i, a, o),
        n.update(a, s, o)
    }
}
function zr(e, t, n) {
    let i;
    function r(t) {
        if ("highp" === t) {
            if (e.getShaderPrecisionFormat(35633, 36338).precision > 0 && e.getShaderPrecisionFormat(35632, 36338).precision > 0)
                return "highp";
            t = "mediump"
        }
        return "mediump" === t && e.getShaderPrecisionFormat(35633, 36337).precision > 0 && e.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
    }
    const s = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && e instanceof WebGL2ComputeRenderingContext;
    let a = void 0 !== n.precision ? n.precision : "highp";
    const o = r(a);
    o !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", o, "instead."),
    a = o);
    const l = s || t.has("WEBGL_draw_buffers")
      , c = !0 === n.logarithmicDepthBuffer
      , h = e.getParameter(34930)
      , u = e.getParameter(35660)
      , d = e.getParameter(3379)
      , p = e.getParameter(34076)
      , m = e.getParameter(34921)
      , f = e.getParameter(36347)
      , g = e.getParameter(36348)
      , v = e.getParameter(36349)
      , x = u > 0
      , y = s || t.has("OES_texture_float");
    return {
        isWebGL2: s,
        drawBuffers: l,
        getMaxAnisotropy: function() {
            if (void 0 !== i)
                return i;
            if (!0 === t.has("EXT_texture_filter_anisotropic")) {
                const n = t.get("EXT_texture_filter_anisotropic");
                i = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
            } else
                i = 0;
            return i
        },
        getMaxPrecision: r,
        precision: a,
        logarithmicDepthBuffer: c,
        maxTextures: h,
        maxVertexTextures: u,
        maxTextureSize: d,
        maxCubemapSize: p,
        maxAttributes: m,
        maxVertexUniforms: f,
        maxVaryings: g,
        maxFragmentUniforms: v,
        vertexTextures: x,
        floatFragmentTextures: y,
        floatVertexTextures: x && y,
        maxSamples: s ? e.getParameter(36183) : 0
    }
}
function Ur(e) {
    const t = this;
    let n = null
      , i = 0
      , r = !1
      , s = !1;
    const a = new wr
      , o = new Bt
      , l = {
        value: null,
        needsUpdate: !1
    };
    function c() {
        l.value !== n && (l.value = n,
        l.needsUpdate = i > 0),
        t.numPlanes = i,
        t.numIntersection = 0
    }
    function h(e, n, i, r) {
        const s = null !== e ? e.length : 0;
        let c = null;
        if (0 !== s) {
            if (c = l.value,
            !0 !== r || null === c) {
                const t = i + 4 * s
                  , r = n.matrixWorldInverse;
                o.getNormalMatrix(r),
                (null === c || c.length < t) && (c = new Float32Array(t));
                for (let t = 0, n = i; t !== s; ++t,
                n += 4)
                    a.copy(e[t]).applyMatrix4(r, o),
                    a.normal.toArray(c, n),
                    c[n + 3] = a.constant
            }
            l.value = c,
            l.needsUpdate = !0
        }
        return t.numPlanes = s,
        t.numIntersection = 0,
        c
    }
    this.uniform = l,
    this.numPlanes = 0,
    this.numIntersection = 0,
    this.init = function(e, t, s) {
        const a = 0 !== e.length || t || 0 !== i || r;
        return r = t,
        n = h(e, s, 0),
        i = e.length,
        a
    }
    ,
    this.beginShadows = function() {
        s = !0,
        h(null)
    }
    ,
    this.endShadows = function() {
        s = !1,
        c()
    }
    ,
    this.setState = function(t, a, o) {
        const u = t.clippingPlanes
          , d = t.clipIntersection
          , p = t.clipShadows
          , m = e.get(t);
        if (!r || null === u || 0 === u.length || s && !p)
            s ? h(null) : c();
        else {
            const e = s ? 0 : i
              , t = 4 * e;
            let r = m.clippingState || null;
            l.value = r,
            r = h(u, a, t, o);
            for (let e = 0; e !== t; ++e)
                r[e] = n[e];
            m.clippingState = r,
            this.numIntersection = d ? this.numPlanes : 0,
            this.numPlanes += e
        }
    }
}
function Fr(e) {
    let t = new WeakMap;
    function n(e, t) {
        return t === me ? e.mapping = de : t === fe && (e.mapping = pe),
        e
    }
    function i(e) {
        const n = e.target;
        n.removeEventListener("dispose", i);
        const r = t.get(n);
        void 0 !== r && (t.delete(n),
        r.dispose())
    }
    return {
        get: function(r) {
            if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
                const s = r.mapping;
                if (s === me || s === fe) {
                    if (t.has(r)) {
                        return n(t.get(r).texture, r.mapping)
                    }
                    {
                        const s = r.image;
                        if (s && s.height > 0) {
                            const a = new yr(s.height / 2);
                            return a.fromEquirectangularTexture(e, r),
                            t.set(r, a),
                            r.addEventListener("dispose", i),
                            n(a.texture, r.mapping)
                        }
                        return null
                    }
                }
            }
            return r
        },
        dispose: function() {
            t = new WeakMap
        }
    }
}
Ir.physical = {
    uniforms: ur([Ir.standard.uniforms, {
        clearcoat: {
            value: 0
        },
        clearcoatMap: {
            value: null
        },
        clearcoatRoughness: {
            value: 0
        },
        clearcoatRoughnessMap: {
            value: null
        },
        clearcoatNormalScale: {
            value: new Ft(1,1)
        },
        clearcoatNormalMap: {
            value: null
        },
        iridescence: {
            value: 0
        },
        iridescenceMap: {
            value: null
        },
        iridescenceIOR: {
            value: 1.3
        },
        iridescenceThicknessMinimum: {
            value: 100
        },
        iridescenceThicknessMaximum: {
            value: 400
        },
        iridescenceThicknessMap: {
            value: null
        },
        sheen: {
            value: 0
        },
        sheenColor: {
            value: new en(0)
        },
        sheenColorMap: {
            value: null
        },
        sheenRoughness: {
            value: 1
        },
        sheenRoughnessMap: {
            value: null
        },
        transmission: {
            value: 0
        },
        transmissionMap: {
            value: null
        },
        transmissionSamplerSize: {
            value: new Ft
        },
        transmissionSamplerMap: {
            value: null
        },
        thickness: {
            value: 0
        },
        thicknessMap: {
            value: null
        },
        attenuationDistance: {
            value: 0
        },
        attenuationColor: {
            value: new en(0)
        },
        specularIntensity: {
            value: 1
        },
        specularIntensityMap: {
            value: null
        },
        specularColor: {
            value: new en(1,1,1)
        },
        specularColorMap: {
            value: null
        }
    }]),
    vertexShader: Rr.meshphysical_vert,
    fragmentShader: Rr.meshphysical_frag
};
class Br extends mr {
    constructor(e=-1, t=1, n=1, i=-1, r=.1, s=2e3) {
        super(),
        this.isOrthographicCamera = !0,
        this.type = "OrthographicCamera",
        this.zoom = 1,
        this.view = null,
        this.left = e,
        this.right = t,
        this.top = n,
        this.bottom = i,
        this.near = r,
        this.far = s,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.left = e.left,
        this.right = e.right,
        this.top = e.top,
        this.bottom = e.bottom,
        this.near = e.near,
        this.far = e.far,
        this.zoom = e.zoom,
        this.view = null === e.view ? null : Object.assign({}, e.view),
        this
    }
    setViewOffset(e, t, n, i, r, s) {
        null === this.view && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = n,
        this.view.offsetY = i,
        this.view.width = r,
        this.view.height = s,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        null !== this.view && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = (this.right - this.left) / (2 * this.zoom)
          , t = (this.top - this.bottom) / (2 * this.zoom)
          , n = (this.right + this.left) / 2
          , i = (this.top + this.bottom) / 2;
        let r = n - e
          , s = n + e
          , a = i + t
          , o = i - t;
        if (null !== this.view && this.view.enabled) {
            const e = (this.right - this.left) / this.view.fullWidth / this.zoom
              , t = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            r += e * this.view.offsetX,
            s = r + e * this.view.width,
            a -= t * this.view.offsetY,
            o = a - t * this.view.height
        }
        this.projectionMatrix.makeOrthographic(r, s, a, o, this.near, this.far),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.zoom = this.zoom,
        t.object.left = this.left,
        t.object.right = this.right,
        t.object.top = this.top,
        t.object.bottom = this.bottom,
        t.object.near = this.near,
        t.object.far = this.far,
        null !== this.view && (t.object.view = Object.assign({}, this.view)),
        t
    }
}
const kr = [.125, .215, .35, .446, .526, .582]
  , Gr = 20
  , Hr = new Br
  , Vr = new en;
let Wr = null;
const jr = (1 + Math.sqrt(5)) / 2
  , Xr = 1 / jr
  , qr = [new pn(1,1,1), new pn(-1,1,1), new pn(1,1,-1), new pn(-1,1,-1), new pn(0,jr,Xr), new pn(0,jr,-Xr), new pn(Xr,0,jr), new pn(-Xr,0,jr), new pn(jr,Xr,0), new pn(-jr,Xr,0)];
class Yr {
    constructor(e) {
        this._renderer = e,
        this._pingPongRenderTarget = null,
        this._lodMax = 0,
        this._cubeSize = 0,
        this._lodPlanes = [],
        this._sizeLods = [],
        this._sigmas = [],
        this._blurMaterial = null,
        this._cubemapMaterial = null,
        this._equirectMaterial = null,
        this._compileMaterial(this._blurMaterial)
    }
    fromScene(e, t=0, n=.1, i=100) {
        Wr = this._renderer.getRenderTarget(),
        this._setSize(256);
        const r = this._allocateTargets();
        return r.depthBuffer = !0,
        this._sceneToCubeUV(e, n, i, r),
        t > 0 && this._blur(r, 0, 0, t),
        this._applyPMREM(r),
        this._cleanup(r),
        r
    }
    fromEquirectangular(e, t=null) {
        return this._fromTexture(e, t)
    }
    fromCubemap(e, t=null) {
        return this._fromTexture(e, t)
    }
    compileCubemapShader() {
        null === this._cubemapMaterial && (this._cubemapMaterial = Qr(),
        this._compileMaterial(this._cubemapMaterial))
    }
    compileEquirectangularShader() {
        null === this._equirectMaterial && (this._equirectMaterial = Kr(),
        this._compileMaterial(this._equirectMaterial))
    }
    dispose() {
        this._dispose(),
        null !== this._cubemapMaterial && this._cubemapMaterial.dispose(),
        null !== this._equirectMaterial && this._equirectMaterial.dispose()
    }
    _setSize(e) {
        this._lodMax = Math.floor(Math.log2(e)),
        this._cubeSize = Math.pow(2, this._lodMax)
    }
    _dispose() {
        null !== this._blurMaterial && this._blurMaterial.dispose(),
        null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
        for (let e = 0; e < this._lodPlanes.length; e++)
            this._lodPlanes[e].dispose()
    }
    _cleanup(e) {
        this._renderer.setRenderTarget(Wr),
        e.scissorTest = !1,
        Jr(e, 0, 0, e.width, e.height)
    }
    _fromTexture(e, t) {
        e.mapping === de || e.mapping === pe ? this._setSize(0 === e.image.length ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4),
        Wr = this._renderer.getRenderTarget();
        const n = t || this._allocateTargets();
        return this._textureToCubeUV(e, n),
        this._applyPMREM(n),
        this._cleanup(n),
        n
    }
    _allocateTargets() {
        const e = 3 * Math.max(this._cubeSize, 112)
          , t = 4 * this._cubeSize
          , n = {
            magFilter: we,
            minFilter: we,
            generateMipmaps: !1,
            type: Re,
            format: Ie,
            encoding: ft,
            depthBuffer: !1
        }
          , i = Zr(e, t, n);
        if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== e) {
            null !== this._pingPongRenderTarget && this._dispose(),
            this._pingPongRenderTarget = Zr(e, t, n);
            const {_lodMax: i} = this;
            ({sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas} = function(e) {
                const t = []
                  , n = []
                  , i = [];
                let r = e;
                const s = e - 4 + 1 + kr.length;
                for (let a = 0; a < s; a++) {
                    const s = Math.pow(2, r);
                    n.push(s);
                    let o = 1 / s;
                    a > e - 4 ? o = kr[a - e + 4 - 1] : 0 === a && (o = 0),
                    i.push(o);
                    const l = 1 / (s - 2)
                      , c = -l
                      , h = 1 + l
                      , u = [c, c, h, c, h, h, c, c, h, h, c, h]
                      , d = 6
                      , p = 6
                      , m = 3
                      , f = 2
                      , g = 1
                      , v = new Float32Array(m * p * d)
                      , x = new Float32Array(f * p * d)
                      , y = new Float32Array(g * p * d);
                    for (let e = 0; e < d; e++) {
                        const t = e % 3 * 2 / 3 - 1
                          , n = e > 2 ? 0 : -1
                          , i = [t, n, 0, t + 2 / 3, n, 0, t + 2 / 3, n + 1, 0, t, n, 0, t + 2 / 3, n + 1, 0, t, n + 1, 0];
                        v.set(i, m * p * e),
                        x.set(u, f * p * e);
                        const r = [e, e, e, e, e, e];
                        y.set(r, g * p * e)
                    }
                    const _ = new Vi;
                    _.setAttribute("position", new Ii(v,m)),
                    _.setAttribute("uv", new Ii(x,f)),
                    _.setAttribute("faceIndex", new Ii(y,g)),
                    t.push(_),
                    r > 4 && r--
                }
                return {
                    lodPlanes: t,
                    sizeLods: n,
                    sigmas: i
                }
            }(i)),
            this._blurMaterial = function(e, t, n) {
                const i = new Float32Array(Gr)
                  , r = new pn(0,1,0)
                  , s = new pr({
                    name: "SphericalGaussianBlur",
                    defines: {
                        n: Gr,
                        CUBEUV_TEXEL_WIDTH: 1 / t,
                        CUBEUV_TEXEL_HEIGHT: 1 / n,
                        CUBEUV_MAX_MIP: `${e}.0`
                    },
                    uniforms: {
                        envMap: {
                            value: null
                        },
                        samples: {
                            value: 1
                        },
                        weights: {
                            value: i
                        },
                        latitudinal: {
                            value: !1
                        },
                        dTheta: {
                            value: 0
                        },
                        mipInt: {
                            value: 0
                        },
                        poleAxis: {
                            value: r
                        }
                    },
                    vertexShader: $r(),
                    fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                    blending: 0,
                    depthTest: !1,
                    depthWrite: !1
                });
                return s
            }(i, e, t)
        }
        return i
    }
    _compileMaterial(e) {
        const t = new or(this._lodPlanes[0],e);
        this._renderer.compile(t, Hr)
    }
    _sceneToCubeUV(e, t, n, i) {
        const r = new fr(90,1,t,n)
          , s = [1, -1, 1, 1, 1, 1]
          , a = [1, 1, 1, -1, -1, -1]
          , o = this._renderer
          , l = o.autoClear
          , c = o.toneMapping;
        o.getClearColor(Vr),
        o.toneMapping = 0,
        o.autoClear = !1;
        const h = new Li({
            name: "PMREM.Background",
            side: 1,
            depthWrite: !1,
            depthTest: !1
        })
          , u = new or(new cr,h);
        let d = !1;
        const p = e.background;
        p ? p.isColor && (h.color.copy(p),
        e.background = null,
        d = !0) : (h.color.copy(Vr),
        d = !0);
        for (let t = 0; t < 6; t++) {
            const n = t % 3;
            0 === n ? (r.up.set(0, s[t], 0),
            r.lookAt(a[t], 0, 0)) : 1 === n ? (r.up.set(0, 0, s[t]),
            r.lookAt(0, a[t], 0)) : (r.up.set(0, s[t], 0),
            r.lookAt(0, 0, a[t]));
            const l = this._cubeSize;
            Jr(i, n * l, t > 2 ? l : 0, l, l),
            o.setRenderTarget(i),
            d && o.render(u, r),
            o.render(e, r)
        }
        u.geometry.dispose(),
        u.material.dispose(),
        o.toneMapping = c,
        o.autoClear = l,
        e.background = p
    }
    _textureToCubeUV(e, t) {
        const n = this._renderer
          , i = e.mapping === de || e.mapping === pe;
        i ? (null === this._cubemapMaterial && (this._cubemapMaterial = Qr()),
        this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === e.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = Kr());
        const r = i ? this._cubemapMaterial : this._equirectMaterial
          , s = new or(this._lodPlanes[0],r);
        r.uniforms.envMap.value = e;
        const a = this._cubeSize;
        Jr(t, 0, 0, 3 * a, 2 * a),
        n.setRenderTarget(t),
        n.render(s, Hr)
    }
    _applyPMREM(e) {
        const t = this._renderer
          , n = t.autoClear;
        t.autoClear = !1;
        for (let t = 1; t < this._lodPlanes.length; t++) {
            const n = Math.sqrt(this._sigmas[t] * this._sigmas[t] - this._sigmas[t - 1] * this._sigmas[t - 1])
              , i = qr[(t - 1) % qr.length];
            this._blur(e, t - 1, t, n, i)
        }
        t.autoClear = n
    }
    _blur(e, t, n, i, r) {
        const s = this._pingPongRenderTarget;
        this._halfBlur(e, s, t, n, i, "latitudinal", r),
        this._halfBlur(s, e, n, n, i, "longitudinal", r)
    }
    _halfBlur(e, t, n, i, r, s, a) {
        const o = this._renderer
          , l = this._blurMaterial;
        "latitudinal" !== s && "longitudinal" !== s && console.error("blur direction must be either latitudinal or longitudinal!");
        const c = new or(this._lodPlanes[i],l)
          , h = l.uniforms
          , u = this._sizeLods[n] - 1
          , d = isFinite(r) ? Math.PI / (2 * u) : 2 * Math.PI / 39
          , p = r / d
          , m = isFinite(r) ? 1 + Math.floor(3 * p) : Gr;
        m > Gr && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${m} samples when the maximum is set to 20`);
        const f = [];
        let g = 0;
        for (let e = 0; e < Gr; ++e) {
            const t = e / p
              , n = Math.exp(-t * t / 2);
            f.push(n),
            0 === e ? g += n : e < m && (g += 2 * n)
        }
        for (let e = 0; e < f.length; e++)
            f[e] = f[e] / g;
        h.envMap.value = e.texture,
        h.samples.value = m,
        h.weights.value = f,
        h.latitudinal.value = "latitudinal" === s,
        a && (h.poleAxis.value = a);
        const {_lodMax: v} = this;
        h.dTheta.value = d,
        h.mipInt.value = v - n;
        const x = this._sizeLods[i];
        Jr(t, 3 * x * (i > v - 4 ? i - v + 4 : 0), 4 * (this._cubeSize - x), 3 * x, 2 * x),
        o.setRenderTarget(t),
        o.render(c, Hr)
    }
}
function Zr(e, t, n) {
    const i = new cn(e,t,n);
    return i.texture.mapping = ge,
    i.texture.name = "PMREM.cubeUv",
    i.scissorTest = !0,
    i
}
function Jr(e, t, n, i, r) {
    e.viewport.set(t, n, i, r),
    e.scissor.set(t, n, i, r)
}
function Kr() {
    return new pr({
        name: "EquirectangularToCubeUV",
        uniforms: {
            envMap: {
                value: null
            }
        },
        vertexShader: $r(),
        fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
        blending: 0,
        depthTest: !1,
        depthWrite: !1
    })
}
function Qr() {
    return new pr({
        name: "CubemapToCubeUV",
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            }
        },
        vertexShader: $r(),
        fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
        blending: 0,
        depthTest: !1,
        depthWrite: !1
    })
}
function $r() {
    return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"
}
function es(e) {
    let t = new WeakMap
      , n = null;
    function i(e) {
        const n = e.target;
        n.removeEventListener("dispose", i);
        const r = t.get(n);
        void 0 !== r && (t.delete(n),
        r.dispose())
    }
    return {
        get: function(r) {
            if (r && r.isTexture) {
                const s = r.mapping
                  , a = s === me || s === fe
                  , o = s === de || s === pe;
                if (a || o) {
                    if (r.isRenderTargetTexture && !0 === r.needsPMREMUpdate) {
                        r.needsPMREMUpdate = !1;
                        let i = t.get(r);
                        return null === n && (n = new Yr(e)),
                        i = a ? n.fromEquirectangular(r, i) : n.fromCubemap(r, i),
                        t.set(r, i),
                        i.texture
                    }
                    if (t.has(r))
                        return t.get(r).texture;
                    {
                        const s = r.image;
                        if (a && s && s.height > 0 || o && s && function(e) {
                            let t = 0;
                            const n = 6;
                            for (let i = 0; i < n; i++)
                                void 0 !== e[i] && t++;
                            return t === n
                        }(s)) {
                            null === n && (n = new Yr(e));
                            const s = a ? n.fromEquirectangular(r) : n.fromCubemap(r);
                            return t.set(r, s),
                            r.addEventListener("dispose", i),
                            s.texture
                        }
                        return null
                    }
                }
            }
            return r
        },
        dispose: function() {
            t = new WeakMap,
            null !== n && (n.dispose(),
            n = null)
        }
    }
}
function ts(e) {
    const t = {};
    function n(n) {
        if (void 0 !== t[n])
            return t[n];
        let i;
        switch (n) {
        case "WEBGL_depth_texture":
            i = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
        case "EXT_texture_filter_anisotropic":
            i = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
        case "WEBGL_compressed_texture_s3tc":
            i = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
        case "WEBGL_compressed_texture_pvrtc":
            i = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
        default:
            i = e.getExtension(n)
        }
        return t[n] = i,
        i
    }
    return {
        has: function(e) {
            return null !== n(e)
        },
        init: function(e) {
            e.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"),
            n("OES_texture_float"),
            n("OES_texture_half_float"),
            n("OES_texture_half_float_linear"),
            n("OES_standard_derivatives"),
            n("OES_element_index_uint"),
            n("OES_vertex_array_object"),
            n("ANGLE_instanced_arrays")),
            n("OES_texture_float_linear"),
            n("EXT_color_buffer_half_float"),
            n("WEBGL_multisampled_render_to_texture")
        },
        get: function(e) {
            const t = n(e);
            return null === t && console.warn("THREE.WebGLRenderer: " + e + " extension not supported."),
            t
        }
    }
}
function ns(e, t, n, i) {
    const r = {}
      , s = new WeakMap;
    function a(e) {
        const o = e.target;
        null !== o.index && t.remove(o.index);
        for (const e in o.attributes)
            t.remove(o.attributes[e]);
        o.removeEventListener("dispose", a),
        delete r[o.id];
        const l = s.get(o);
        l && (t.remove(l),
        s.delete(o)),
        i.releaseStatesOfGeometry(o),
        !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount,
        n.memory.geometries--
    }
    function o(e) {
        const n = []
          , i = e.index
          , r = e.attributes.position;
        let a = 0;
        if (null !== i) {
            const e = i.array;
            a = i.version;
            for (let t = 0, i = e.length; t < i; t += 3) {
                const i = e[t + 0]
                  , r = e[t + 1]
                  , s = e[t + 2];
                n.push(i, r, r, s, s, i)
            }
        } else {
            const e = r.array;
            a = r.version;
            for (let t = 0, i = e.length / 3 - 1; t < i; t += 3) {
                const e = t + 0
                  , i = t + 1
                  , r = t + 2;
                n.push(e, i, i, r, r, e)
            }
        }
        const o = new (kt(n) ? Oi : Di)(n,1);
        o.version = a;
        const l = s.get(e);
        l && t.remove(l),
        s.set(e, o)
    }
    return {
        get: function(e, t) {
            return !0 === r[t.id] || (t.addEventListener("dispose", a),
            r[t.id] = !0,
            n.memory.geometries++),
            t
        },
        update: function(e) {
            const n = e.attributes;
            for (const e in n)
                t.update(n[e], 34962);
            const i = e.morphAttributes;
            for (const e in i) {
                const n = i[e];
                for (let e = 0, i = n.length; e < i; e++)
                    t.update(n[e], 34962)
            }
        },
        getWireframeAttribute: function(e) {
            const t = s.get(e);
            if (t) {
                const n = e.index;
                null !== n && t.version < n.version && o(e)
            } else
                o(e);
            return s.get(e)
        }
    }
}
function is(e, t, n, i) {
    const r = i.isWebGL2;
    let s, a, o;
    this.setMode = function(e) {
        s = e
    }
    ,
    this.setIndex = function(e) {
        a = e.type,
        o = e.bytesPerElement
    }
    ,
    this.render = function(t, i) {
        e.drawElements(s, i, a, t * o),
        n.update(i, s, 1)
    }
    ,
    this.renderInstances = function(i, l, c) {
        if (0 === c)
            return;
        let h, u;
        if (r)
            h = e,
            u = "drawElementsInstanced";
        else if (h = t.get("ANGLE_instanced_arrays"),
        u = "drawElementsInstancedANGLE",
        null === h)
            return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        h[u](s, l, a, i * o, c),
        n.update(l, s, c)
    }
}
function rs(e) {
    const t = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
    };
    return {
        memory: {
            geometries: 0,
            textures: 0
        },
        render: t,
        programs: null,
        autoReset: !0,
        reset: function() {
            t.frame++,
            t.calls = 0,
            t.triangles = 0,
            t.points = 0,
            t.lines = 0
        },
        update: function(e, n, i) {
            switch (t.calls++,
            n) {
            case 4:
                t.triangles += i * (e / 3);
                break;
            case 1:
                t.lines += i * (e / 2);
                break;
            case 3:
                t.lines += i * (e - 1);
                break;
            case 2:
                t.lines += i * e;
                break;
            case 0:
                t.points += i * e;
                break;
            default:
                console.error("THREE.WebGLInfo: Unknown draw mode:", n)
            }
        }
    }
}
function ss(e, t) {
    return e[0] - t[0]
}
function as(e, t) {
    return Math.abs(t[1]) - Math.abs(e[1])
}
function os(e, t, n) {
    const i = {}
      , r = new Float32Array(8)
      , s = new WeakMap
      , a = new ln
      , o = [];
    for (let e = 0; e < 8; e++)
        o[e] = [e, 0];
    return {
        update: function(l, c, h, u) {
            const d = l.morphTargetInfluences;
            if (!0 === t.isWebGL2) {
                const i = c.morphAttributes.position || c.morphAttributes.normal || c.morphAttributes.color
                  , r = void 0 !== i ? i.length : 0;
                let o = s.get(c);
                if (void 0 === o || o.count !== r) {
                    void 0 !== o && o.texture.dispose();
                    const e = void 0 !== c.morphAttributes.position
                      , n = void 0 !== c.morphAttributes.normal
                      , i = void 0 !== c.morphAttributes.color
                      , l = c.morphAttributes.position || []
                      , h = c.morphAttributes.normal || []
                      , u = c.morphAttributes.color || [];
                    let d = 0;
                    !0 === e && (d = 1),
                    !0 === n && (d = 2),
                    !0 === i && (d = 3);
                    let p = c.attributes.position.count * d
                      , m = 1;
                    p > t.maxTextureSize && (m = Math.ceil(p / t.maxTextureSize),
                    p = t.maxTextureSize);
                    const f = new Float32Array(p * m * 4 * r)
                      , g = new hn(f,p,m,r);
                    g.type = Le,
                    g.needsUpdate = !0;
                    const v = 4 * d;
                    for (let t = 0; t < r; t++) {
                        const r = l[t]
                          , s = h[t]
                          , o = u[t]
                          , c = p * m * 4 * t;
                        for (let t = 0; t < r.count; t++) {
                            const l = t * v;
                            !0 === e && (a.fromBufferAttribute(r, t),
                            f[c + l + 0] = a.x,
                            f[c + l + 1] = a.y,
                            f[c + l + 2] = a.z,
                            f[c + l + 3] = 0),
                            !0 === n && (a.fromBufferAttribute(s, t),
                            f[c + l + 4] = a.x,
                            f[c + l + 5] = a.y,
                            f[c + l + 6] = a.z,
                            f[c + l + 7] = 0),
                            !0 === i && (a.fromBufferAttribute(o, t),
                            f[c + l + 8] = a.x,
                            f[c + l + 9] = a.y,
                            f[c + l + 10] = a.z,
                            f[c + l + 11] = 4 === o.itemSize ? a.w : 1)
                        }
                    }
                    o = {
                        count: r,
                        texture: g,
                        size: new Ft(p,m)
                    },
                    s.set(c, o),
                    c.addEventListener("dispose", (function e() {
                        g.dispose(),
                        s.delete(c),
                        c.removeEventListener("dispose", e)
                    }
                    ))
                }
                let l = 0;
                for (let e = 0; e < d.length; e++)
                    l += d[e];
                const h = c.morphTargetsRelative ? 1 : 1 - l;
                u.getUniforms().setValue(e, "morphTargetBaseInfluence", h),
                u.getUniforms().setValue(e, "morphTargetInfluences", d),
                u.getUniforms().setValue(e, "morphTargetsTexture", o.texture, n),
                u.getUniforms().setValue(e, "morphTargetsTextureSize", o.size)
            } else {
                const t = void 0 === d ? 0 : d.length;
                let n = i[c.id];
                if (void 0 === n || n.length !== t) {
                    n = [];
                    for (let e = 0; e < t; e++)
                        n[e] = [e, 0];
                    i[c.id] = n
                }
                for (let e = 0; e < t; e++) {
                    const t = n[e];
                    t[0] = e,
                    t[1] = d[e]
                }
                n.sort(as);
                for (let e = 0; e < 8; e++)
                    e < t && n[e][1] ? (o[e][0] = n[e][0],
                    o[e][1] = n[e][1]) : (o[e][0] = Number.MAX_SAFE_INTEGER,
                    o[e][1] = 0);
                o.sort(ss);
                const s = c.morphAttributes.position
                  , a = c.morphAttributes.normal;
                let l = 0;
                for (let e = 0; e < 8; e++) {
                    const t = o[e]
                      , n = t[0]
                      , i = t[1];
                    n !== Number.MAX_SAFE_INTEGER && i ? (s && c.getAttribute("morphTarget" + e) !== s[n] && c.setAttribute("morphTarget" + e, s[n]),
                    a && c.getAttribute("morphNormal" + e) !== a[n] && c.setAttribute("morphNormal" + e, a[n]),
                    r[e] = i,
                    l += i) : (s && !0 === c.hasAttribute("morphTarget" + e) && c.deleteAttribute("morphTarget" + e),
                    a && !0 === c.hasAttribute("morphNormal" + e) && c.deleteAttribute("morphNormal" + e),
                    r[e] = 0)
                }
                const h = c.morphTargetsRelative ? 1 : 1 - l;
                u.getUniforms().setValue(e, "morphTargetBaseInfluence", h),
                u.getUniforms().setValue(e, "morphTargetInfluences", r)
            }
        }
    }
}
function ls(e, t, n, i) {
    let r = new WeakMap;
    function s(e) {
        const t = e.target;
        t.removeEventListener("dispose", s),
        n.remove(t.instanceMatrix),
        null !== t.instanceColor && n.remove(t.instanceColor)
    }
    return {
        update: function(e) {
            const a = i.render.frame
              , o = e.geometry
              , l = t.get(e, o);
            return r.get(l) !== a && (t.update(l),
            r.set(l, a)),
            e.isInstancedMesh && (!1 === e.hasEventListener("dispose", s) && e.addEventListener("dispose", s),
            n.update(e.instanceMatrix, 34962),
            null !== e.instanceColor && n.update(e.instanceColor, 34962)),
            l
        },
        dispose: function() {
            r = new WeakMap
        }
    }
}
const cs = new on
  , hs = new hn
  , us = new un
  , ds = new xr
  , ps = []
  , ms = []
  , fs = new Float32Array(16)
  , gs = new Float32Array(9)
  , vs = new Float32Array(4);
function xs(e, t, n) {
    const i = e[0];
    if (i <= 0 || i > 0)
        return e;
    const r = t * n;
    let s = ps[r];
    if (void 0 === s && (s = new Float32Array(r),
    ps[r] = s),
    0 !== t) {
        i.toArray(s, 0);
        for (let i = 1, r = 0; i !== t; ++i)
            r += n,
            e[i].toArray(s, r)
    }
    return s
}
function ys(e, t) {
    if (e.length !== t.length)
        return !1;
    for (let n = 0, i = e.length; n < i; n++)
        if (e[n] !== t[n])
            return !1;
    return !0
}
function _s(e, t) {
    for (let n = 0, i = t.length; n < i; n++)
        e[n] = t[n]
}
function bs(e, t) {
    let n = ms[t];
    void 0 === n && (n = new Int32Array(t),
    ms[t] = n);
    for (let i = 0; i !== t; ++i)
        n[i] = e.allocateTextureUnit();
    return n
}
function Ms(e, t) {
    const n = this.cache;
    n[0] !== t && (e.uniform1f(this.addr, t),
    n[0] = t)
}
function ws(e, t) {
    const n = this.cache;
    if (void 0 !== t.x)
        n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y),
        n[0] = t.x,
        n[1] = t.y);
    else {
        if (ys(n, t))
            return;
        e.uniform2fv(this.addr, t),
        _s(n, t)
    }
}
function Ss(e, t) {
    const n = this.cache;
    if (void 0 !== t.x)
        n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z),
        n[0] = t.x,
        n[1] = t.y,
        n[2] = t.z);
    else if (void 0 !== t.r)
        n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b),
        n[0] = t.r,
        n[1] = t.g,
        n[2] = t.b);
    else {
        if (ys(n, t))
            return;
        e.uniform3fv(this.addr, t),
        _s(n, t)
    }
}
function Ts(e, t) {
    const n = this.cache;
    if (void 0 !== t.x)
        n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w),
        n[0] = t.x,
        n[1] = t.y,
        n[2] = t.z,
        n[3] = t.w);
    else {
        if (ys(n, t))
            return;
        e.uniform4fv(this.addr, t),
        _s(n, t)
    }
}
function As(e, t) {
    const n = this.cache
      , i = t.elements;
    if (void 0 === i) {
        if (ys(n, t))
            return;
        e.uniformMatrix2fv(this.addr, !1, t),
        _s(n, t)
    } else {
        if (ys(n, i))
            return;
        vs.set(i),
        e.uniformMatrix2fv(this.addr, !1, vs),
        _s(n, i)
    }
}
function Es(e, t) {
    const n = this.cache
      , i = t.elements;
    if (void 0 === i) {
        if (ys(n, t))
            return;
        e.uniformMatrix3fv(this.addr, !1, t),
        _s(n, t)
    } else {
        if (ys(n, i))
            return;
        gs.set(i),
        e.uniformMatrix3fv(this.addr, !1, gs),
        _s(n, i)
    }
}
function Cs(e, t) {
    const n = this.cache
      , i = t.elements;
    if (void 0 === i) {
        if (ys(n, t))
            return;
        e.uniformMatrix4fv(this.addr, !1, t),
        _s(n, t)
    } else {
        if (ys(n, i))
            return;
        fs.set(i),
        e.uniformMatrix4fv(this.addr, !1, fs),
        _s(n, i)
    }
}
function Ls(e, t) {
    const n = this.cache;
    n[0] !== t && (e.uniform1i(this.addr, t),
    n[0] = t)
}
function Rs(e, t) {
    const n = this.cache;
    ys(n, t) || (e.uniform2iv(this.addr, t),
    _s(n, t))
}
function Ps(e, t) {
    const n = this.cache;
    ys(n, t) || (e.uniform3iv(this.addr, t),
    _s(n, t))
}
function Is(e, t) {
    const n = this.cache;
    ys(n, t) || (e.uniform4iv(this.addr, t),
    _s(n, t))
}
function Ds(e, t) {
    const n = this.cache;
    n[0] !== t && (e.uniform1ui(this.addr, t),
    n[0] = t)
}
function Os(e, t) {
    const n = this.cache;
    ys(n, t) || (e.uniform2uiv(this.addr, t),
    _s(n, t))
}
function Ns(e, t) {
    const n = this.cache;
    ys(n, t) || (e.uniform3uiv(this.addr, t),
    _s(n, t))
}
function zs(e, t) {
    const n = this.cache;
    ys(n, t) || (e.uniform4uiv(this.addr, t),
    _s(n, t))
}
function Us(e, t, n) {
    const i = this.cache
      , r = n.allocateTextureUnit();
    i[0] !== r && (e.uniform1i(this.addr, r),
    i[0] = r),
    n.setTexture2D(t || cs, r)
}
function Fs(e, t, n) {
    const i = this.cache
      , r = n.allocateTextureUnit();
    i[0] !== r && (e.uniform1i(this.addr, r),
    i[0] = r),
    n.setTexture3D(t || us, r)
}
function Bs(e, t, n) {
    const i = this.cache
      , r = n.allocateTextureUnit();
    i[0] !== r && (e.uniform1i(this.addr, r),
    i[0] = r),
    n.setTextureCube(t || ds, r)
}
function ks(e, t, n) {
    const i = this.cache
      , r = n.allocateTextureUnit();
    i[0] !== r && (e.uniform1i(this.addr, r),
    i[0] = r),
    n.setTexture2DArray(t || hs, r)
}
function Gs(e, t) {
    e.uniform1fv(this.addr, t)
}
function Hs(e, t) {
    const n = xs(t, this.size, 2);
    e.uniform2fv(this.addr, n)
}
function Vs(e, t) {
    const n = xs(t, this.size, 3);
    e.uniform3fv(this.addr, n)
}
function Ws(e, t) {
    const n = xs(t, this.size, 4);
    e.uniform4fv(this.addr, n)
}
function js(e, t) {
    const n = xs(t, this.size, 4);
    e.uniformMatrix2fv(this.addr, !1, n)
}
function Xs(e, t) {
    const n = xs(t, this.size, 9);
    e.uniformMatrix3fv(this.addr, !1, n)
}
function qs(e, t) {
    const n = xs(t, this.size, 16);
    e.uniformMatrix4fv(this.addr, !1, n)
}
function Ys(e, t) {
    e.uniform1iv(this.addr, t)
}
function Zs(e, t) {
    e.uniform2iv(this.addr, t)
}
function Js(e, t) {
    e.uniform3iv(this.addr, t)
}
function Ks(e, t) {
    e.uniform4iv(this.addr, t)
}
function Qs(e, t) {
    e.uniform1uiv(this.addr, t)
}
function $s(e, t) {
    e.uniform2uiv(this.addr, t)
}
function ea(e, t) {
    e.uniform3uiv(this.addr, t)
}
function ta(e, t) {
    e.uniform4uiv(this.addr, t)
}
function na(e, t, n) {
    const i = t.length
      , r = bs(n, i);
    e.uniform1iv(this.addr, r);
    for (let e = 0; e !== i; ++e)
        n.setTexture2D(t[e] || cs, r[e])
}
function ia(e, t, n) {
    const i = t.length
      , r = bs(n, i);
    e.uniform1iv(this.addr, r);
    for (let e = 0; e !== i; ++e)
        n.setTexture3D(t[e] || us, r[e])
}
function ra(e, t, n) {
    const i = t.length
      , r = bs(n, i);
    e.uniform1iv(this.addr, r);
    for (let e = 0; e !== i; ++e)
        n.setTextureCube(t[e] || ds, r[e])
}
function sa(e, t, n) {
    const i = t.length
      , r = bs(n, i);
    e.uniform1iv(this.addr, r);
    for (let e = 0; e !== i; ++e)
        n.setTexture2DArray(t[e] || hs, r[e])
}
class aa {
    constructor(e, t, n) {
        this.id = e,
        this.addr = n,
        this.cache = [],
        this.setValue = function(e) {
            switch (e) {
            case 5126:
                return Ms;
            case 35664:
                return ws;
            case 35665:
                return Ss;
            case 35666:
                return Ts;
            case 35674:
                return As;
            case 35675:
                return Es;
            case 35676:
                return Cs;
            case 5124:
            case 35670:
                return Ls;
            case 35667:
            case 35671:
                return Rs;
            case 35668:
            case 35672:
                return Ps;
            case 35669:
            case 35673:
                return Is;
            case 5125:
                return Ds;
            case 36294:
                return Os;
            case 36295:
                return Ns;
            case 36296:
                return zs;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
                return Us;
            case 35679:
            case 36299:
            case 36307:
                return Fs;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
                return Bs;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
                return ks
            }
        }(t.type)
    }
}
class oa {
    constructor(e, t, n) {
        this.id = e,
        this.addr = n,
        this.cache = [],
        this.size = t.size,
        this.setValue = function(e) {
            switch (e) {
            case 5126:
                return Gs;
            case 35664:
                return Hs;
            case 35665:
                return Vs;
            case 35666:
                return Ws;
            case 35674:
                return js;
            case 35675:
                return Xs;
            case 35676:
                return qs;
            case 5124:
            case 35670:
                return Ys;
            case 35667:
            case 35671:
                return Zs;
            case 35668:
            case 35672:
                return Js;
            case 35669:
            case 35673:
                return Ks;
            case 5125:
                return Qs;
            case 36294:
                return $s;
            case 36295:
                return ea;
            case 36296:
                return ta;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
                return na;
            case 35679:
            case 36299:
            case 36307:
                return ia;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
                return ra;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
                return sa
            }
        }(t.type)
    }
}
class la {
    constructor(e) {
        this.id = e,
        this.seq = [],
        this.map = {}
    }
    setValue(e, t, n) {
        const i = this.seq;
        for (let r = 0, s = i.length; r !== s; ++r) {
            const s = i[r];
            s.setValue(e, t[s.id], n)
        }
    }
}
const ca = /(\w+)(\])?(\[|\.)?/g;
function ha(e, t) {
    e.seq.push(t),
    e.map[t.id] = t
}
function ua(e, t, n) {
    const i = e.name
      , r = i.length;
    for (ca.lastIndex = 0; ; ) {
        const s = ca.exec(i)
          , a = ca.lastIndex;
        let o = s[1];
        const l = "]" === s[2]
          , c = s[3];
        if (l && (o |= 0),
        void 0 === c || "[" === c && a + 2 === r) {
            ha(n, void 0 === c ? new aa(o,e,t) : new oa(o,e,t));
            break
        }
        {
            let e = n.map[o];
            void 0 === e && (e = new la(o),
            ha(n, e)),
            n = e
        }
    }
}
class da {
    constructor(e, t) {
        this.seq = [],
        this.map = {};
        const n = e.getProgramParameter(t, 35718);
        for (let i = 0; i < n; ++i) {
            const n = e.getActiveUniform(t, i);
            ua(n, e.getUniformLocation(t, n.name), this)
        }
    }
    setValue(e, t, n, i) {
        const r = this.map[t];
        void 0 !== r && r.setValue(e, n, i)
    }
    setOptional(e, t, n) {
        const i = t[n];
        void 0 !== i && this.setValue(e, n, i)
    }
    static upload(e, t, n, i) {
        for (let r = 0, s = t.length; r !== s; ++r) {
            const s = t[r]
              , a = n[s.id];
            !1 !== a.needsUpdate && s.setValue(e, a.value, i)
        }
    }
    static seqWithValue(e, t) {
        const n = [];
        for (let i = 0, r = e.length; i !== r; ++i) {
            const r = e[i];
            r.id in t && n.push(r)
        }
        return n
    }
}
function pa(e, t, n) {
    const i = e.createShader(t);
    return e.shaderSource(i, n),
    e.compileShader(i),
    i
}
let ma = 0;
function fa(e, t, n) {
    const i = e.getShaderParameter(t, 35713)
      , r = e.getShaderInfoLog(t).trim();
    if (i && "" === r)
        return "";
    const s = /ERROR: 0:(\d+)/.exec(r);
    if (s) {
        const i = parseInt(s[1]);
        return n.toUpperCase() + "\n\n" + r + "\n\n" + function(e, t) {
            const n = e.split("\n")
              , i = []
              , r = Math.max(t - 6, 0)
              , s = Math.min(t + 6, n.length);
            for (let e = r; e < s; e++) {
                const r = e + 1;
                i.push(`${r === t ? ">" : " "} ${r}: ${n[e]}`)
            }
            return i.join("\n")
        }(e.getShaderSource(t), i)
    }
    return r
}
function ga(e, t) {
    const n = function(e) {
        switch (e) {
        case ft:
            return ["Linear", "( value )"];
        case gt:
            return ["sRGB", "( value )"];
        default:
            return console.warn("THREE.WebGLProgram: Unsupported encoding:", e),
            ["Linear", "( value )"]
        }
    }(t);
    return "vec4 " + e + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
}
function va(e, t) {
    let n;
    switch (t) {
    case 1:
        n = "Linear";
        break;
    case 2:
        n = "Reinhard";
        break;
    case 3:
        n = "OptimizedCineon";
        break;
    case 4:
        n = "ACESFilmic";
        break;
    case 5:
        n = "Custom";
        break;
    default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t),
        n = "Linear"
    }
    return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
}
function xa(e) {
    return "" !== e
}
function ya(e, t) {
    const n = t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps;
    return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
}
function _a(e, t) {
    return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
}
const ba = /^[ \t]*#include +<([\w\d./]+)>/gm;
function Ma(e) {
    return e.replace(ba, wa)
}
function wa(e, t) {
    const n = Rr[t];
    if (void 0 === n)
        throw new Error("Can not resolve #include <" + t + ">");
    return Ma(n)
}
const Sa = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function Ta(e) {
    return e.replace(Sa, Aa)
}
function Aa(e, t, n, i) {
    let r = "";
    for (let e = parseInt(t); e < parseInt(n); e++)
        r += i.replace(/\[\s*i\s*\]/g, "[ " + e + " ]").replace(/UNROLLED_LOOP_INDEX/g, e);
    return r
}
function Ea(e) {
    let t = "precision " + e.precision + " float;\nprecision " + e.precision + " int;";
    return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"),
    t
}
function Ca(e, t, n, i) {
    const r = e.getContext()
      , s = n.defines;
    let a = n.vertexShader
      , o = n.fragmentShader;
    const l = function(e) {
        let t = "SHADOWMAP_TYPE_BASIC";
        return 1 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF" : 2 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === e.shadowMapType && (t = "SHADOWMAP_TYPE_VSM"),
        t
    }(n)
      , c = function(e) {
        let t = "ENVMAP_TYPE_CUBE";
        if (e.envMap)
            switch (e.envMapMode) {
            case de:
            case pe:
                t = "ENVMAP_TYPE_CUBE";
                break;
            case ge:
                t = "ENVMAP_TYPE_CUBE_UV"
            }
        return t
    }(n)
      , h = function(e) {
        let t = "ENVMAP_MODE_REFLECTION";
        e.envMap && e.envMapMode === pe && (t = "ENVMAP_MODE_REFRACTION");
        return t
    }(n)
      , u = function(e) {
        let t = "ENVMAP_BLENDING_NONE";
        if (e.envMap)
            switch (e.combine) {
            case 0:
                t = "ENVMAP_BLENDING_MULTIPLY";
                break;
            case 1:
                t = "ENVMAP_BLENDING_MIX";
                break;
            case 2:
                t = "ENVMAP_BLENDING_ADD"
            }
        return t
    }(n)
      , d = function(e) {
        const t = e.envMapCubeUVHeight;
        if (null === t)
            return null;
        const n = Math.log2(t) - 2
          , i = 1 / t;
        return {
            texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
            texelHeight: i,
            maxMip: n
        }
    }(n)
      , p = n.isWebGL2 ? "" : function(e) {
        return [e.extensionDerivatives || e.envMapCubeUVHeight || e.bumpMap || e.tangentSpaceNormalMap || e.clearcoatNormalMap || e.flatShading || "physical" === e.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (e.extensionFragDepth || e.logarithmicDepthBuffer) && e.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", e.extensionDrawBuffers && e.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (e.extensionShaderTextureLOD || e.envMap || e.transmission) && e.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(xa).join("\n")
    }(n)
      , m = function(e) {
        const t = [];
        for (const n in e) {
            const i = e[n];
            !1 !== i && t.push("#define " + n + " " + i)
        }
        return t.join("\n")
    }(s)
      , f = r.createProgram();
    let g, v, x = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
    n.isRawShaderMaterial ? (g = [m].filter(xa).join("\n"),
    g.length > 0 && (g += "\n"),
    v = [p, m].filter(xa).join("\n"),
    v.length > 0 && (v += "\n")) : (g = [Ea(n), "#define SHADER_NAME " + n.shaderName, m, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + h : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphColors && n.isWebGL2 ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(xa).join("\n"),
    v = [p, Ea(n), "#define SHADER_NAME " + n.shaderName, m, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + h : "", n.envMap ? "#define " + u : "", d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "", d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "", d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescence ? "#define USE_IRIDESCENCE" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? Rr.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? va("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque ? "#define OPAQUE" : "", Rr.encodings_pars_fragment, ga("linearToOutputTexel", n.outputEncoding), n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(xa).join("\n")),
    a = Ma(a),
    a = ya(a, n),
    a = _a(a, n),
    o = Ma(o),
    o = ya(o, n),
    o = _a(o, n),
    a = Ta(a),
    o = Ta(o),
    n.isWebGL2 && !0 !== n.isRawShaderMaterial && (x = "#version 300 es\n",
    g = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g,
    v = ["#define varying in", n.glslVersion === bt ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === bt ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v);
    const y = x + v + o
      , _ = pa(r, 35633, x + g + a)
      , b = pa(r, 35632, y);
    if (r.attachShader(f, _),
    r.attachShader(f, b),
    void 0 !== n.index0AttributeName ? r.bindAttribLocation(f, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(f, 0, "position"),
    r.linkProgram(f),
    e.debug.checkShaderErrors) {
        const e = r.getProgramInfoLog(f).trim()
          , t = r.getShaderInfoLog(_).trim()
          , n = r.getShaderInfoLog(b).trim();
        let i = !0
          , s = !0;
        if (!1 === r.getProgramParameter(f, 35714)) {
            i = !1;
            const t = fa(r, _, "vertex")
              , n = fa(r, b, "fragment");
            console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(f, 35715) + "\n\nProgram Info Log: " + e + "\n" + t + "\n" + n)
        } else
            "" !== e ? console.warn("THREE.WebGLProgram: Program Info Log:", e) : "" !== t && "" !== n || (s = !1);
        s && (this.diagnostics = {
            runnable: i,
            programLog: e,
            vertexShader: {
                log: t,
                prefix: g
            },
            fragmentShader: {
                log: n,
                prefix: v
            }
        })
    }
    let M, w;
    return r.deleteShader(_),
    r.deleteShader(b),
    this.getUniforms = function() {
        return void 0 === M && (M = new da(r,f)),
        M
    }
    ,
    this.getAttributes = function() {
        return void 0 === w && (w = function(e, t) {
            const n = {}
              , i = e.getProgramParameter(t, 35721);
            for (let r = 0; r < i; r++) {
                const i = e.getActiveAttrib(t, r)
                  , s = i.name;
                let a = 1;
                35674 === i.type && (a = 2),
                35675 === i.type && (a = 3),
                35676 === i.type && (a = 4),
                n[s] = {
                    type: i.type,
                    location: e.getAttribLocation(t, s),
                    locationSize: a
                }
            }
            return n
        }(r, f)),
        w
    }
    ,
    this.destroy = function() {
        i.releaseStatesOfProgram(this),
        r.deleteProgram(f),
        this.program = void 0
    }
    ,
    this.name = n.shaderName,
    this.id = ma++,
    this.cacheKey = t,
    this.usedTimes = 1,
    this.program = f,
    this.vertexShader = _,
    this.fragmentShader = b,
    this
}
let La = 0;
class Ra {
    constructor() {
        this.shaderCache = new Map,
        this.materialCache = new Map
    }
    update(e) {
        const t = e.vertexShader
          , n = e.fragmentShader
          , i = this._getShaderStage(t)
          , r = this._getShaderStage(n)
          , s = this._getShaderCacheForMaterial(e);
        return !1 === s.has(i) && (s.add(i),
        i.usedTimes++),
        !1 === s.has(r) && (s.add(r),
        r.usedTimes++),
        this
    }
    remove(e) {
        const t = this.materialCache.get(e);
        for (const e of t)
            e.usedTimes--,
            0 === e.usedTimes && this.shaderCache.delete(e.code);
        return this.materialCache.delete(e),
        this
    }
    getVertexShaderID(e) {
        return this._getShaderStage(e.vertexShader).id
    }
    getFragmentShaderID(e) {
        return this._getShaderStage(e.fragmentShader).id
    }
    dispose() {
        this.shaderCache.clear(),
        this.materialCache.clear()
    }
    _getShaderCacheForMaterial(e) {
        const t = this.materialCache;
        let n = t.get(e);
        return void 0 === n && (n = new Set,
        t.set(e, n)),
        n
    }
    _getShaderStage(e) {
        const t = this.shaderCache;
        let n = t.get(e);
        return void 0 === n && (n = new Pa(e),
        t.set(e, n)),
        n
    }
}
class Pa {
    constructor(e) {
        this.id = La++,
        this.code = e,
        this.usedTimes = 0
    }
}
function Ia(e, t, n, i, r, s, a) {
    const o = new ti
      , l = new Ra
      , c = []
      , h = r.isWebGL2
      , u = r.logarithmicDepthBuffer
      , d = r.vertexTextures;
    let p = r.precision;
    const m = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
    };
    return {
        getParameters: function(s, o, c, f, g) {
            const v = f.fog
              , x = g.geometry
              , y = s.isMeshStandardMaterial ? f.environment : null
              , _ = (s.isMeshStandardMaterial ? n : t).get(s.envMap || y)
              , b = _ && _.mapping === ge ? _.image.height : null
              , M = m[s.type];
            null !== s.precision && (p = r.getMaxPrecision(s.precision),
            p !== s.precision && console.warn("THREE.WebGLProgram.getParameters:", s.precision, "not supported, using", p, "instead."));
            const w = x.morphAttributes.position || x.morphAttributes.normal || x.morphAttributes.color
              , S = void 0 !== w ? w.length : 0;
            let T, A, E, C, L = 0;
            if (void 0 !== x.morphAttributes.position && (L = 1),
            void 0 !== x.morphAttributes.normal && (L = 2),
            void 0 !== x.morphAttributes.color && (L = 3),
            M) {
                const e = Ir[M];
                T = e.vertexShader,
                A = e.fragmentShader
            } else
                T = s.vertexShader,
                A = s.fragmentShader,
                l.update(s),
                E = l.getVertexShaderID(s),
                C = l.getFragmentShaderID(s);
            const R = e.getRenderTarget()
              , P = s.alphaTest > 0
              , I = s.clearcoat > 0
              , D = s.iridescence > 0;
            return {
                isWebGL2: h,
                shaderID: M,
                shaderName: s.type,
                vertexShader: T,
                fragmentShader: A,
                defines: s.defines,
                customVertexShaderID: E,
                customFragmentShaderID: C,
                isRawShaderMaterial: !0 === s.isRawShaderMaterial,
                glslVersion: s.glslVersion,
                precision: p,
                instancing: !0 === g.isInstancedMesh,
                instancingColor: !0 === g.isInstancedMesh && null !== g.instanceColor,
                supportsVertexTextures: d,
                outputEncoding: null === R ? e.outputEncoding : !0 === R.isXRRenderTarget ? R.texture.encoding : ft,
                map: !!s.map,
                matcap: !!s.matcap,
                envMap: !!_,
                envMapMode: _ && _.mapping,
                envMapCubeUVHeight: b,
                lightMap: !!s.lightMap,
                aoMap: !!s.aoMap,
                emissiveMap: !!s.emissiveMap,
                bumpMap: !!s.bumpMap,
                normalMap: !!s.normalMap,
                objectSpaceNormalMap: 1 === s.normalMapType,
                tangentSpaceNormalMap: 0 === s.normalMapType,
                decodeVideoTexture: !!s.map && !0 === s.map.isVideoTexture && s.map.encoding === gt,
                clearcoat: I,
                clearcoatMap: I && !!s.clearcoatMap,
                clearcoatRoughnessMap: I && !!s.clearcoatRoughnessMap,
                clearcoatNormalMap: I && !!s.clearcoatNormalMap,
                iridescence: D,
                iridescenceMap: D && !!s.iridescenceMap,
                iridescenceThicknessMap: D && !!s.iridescenceThicknessMap,
                displacementMap: !!s.displacementMap,
                roughnessMap: !!s.roughnessMap,
                metalnessMap: !!s.metalnessMap,
                specularMap: !!s.specularMap,
                specularIntensityMap: !!s.specularIntensityMap,
                specularColorMap: !!s.specularColorMap,
                opaque: !1 === s.transparent && 1 === s.blending,
                alphaMap: !!s.alphaMap,
                alphaTest: P,
                gradientMap: !!s.gradientMap,
                sheen: s.sheen > 0,
                sheenColorMap: !!s.sheenColorMap,
                sheenRoughnessMap: !!s.sheenRoughnessMap,
                transmission: s.transmission > 0,
                transmissionMap: !!s.transmissionMap,
                thicknessMap: !!s.thicknessMap,
                combine: s.combine,
                vertexTangents: !!s.normalMap && !!x.attributes.tangent,
                vertexColors: s.vertexColors,
                vertexAlphas: !0 === s.vertexColors && !!x.attributes.color && 4 === x.attributes.color.itemSize,
                vertexUvs: !!(s.map || s.bumpMap || s.normalMap || s.specularMap || s.alphaMap || s.emissiveMap || s.roughnessMap || s.metalnessMap || s.clearcoatMap || s.clearcoatRoughnessMap || s.clearcoatNormalMap || s.iridescenceMap || s.iridescenceThicknessMap || s.displacementMap || s.transmissionMap || s.thicknessMap || s.specularIntensityMap || s.specularColorMap || s.sheenColorMap || s.sheenRoughnessMap),
                uvsVertexOnly: !(s.map || s.bumpMap || s.normalMap || s.specularMap || s.alphaMap || s.emissiveMap || s.roughnessMap || s.metalnessMap || s.clearcoatNormalMap || s.iridescenceMap || s.iridescenceThicknessMap || s.transmission > 0 || s.transmissionMap || s.thicknessMap || s.specularIntensityMap || s.specularColorMap || s.sheen > 0 || s.sheenColorMap || s.sheenRoughnessMap || !s.displacementMap),
                fog: !!v,
                useFog: !0 === s.fog,
                fogExp2: v && v.isFogExp2,
                flatShading: !!s.flatShading,
                sizeAttenuation: s.sizeAttenuation,
                logarithmicDepthBuffer: u,
                skinning: !0 === g.isSkinnedMesh,
                morphTargets: void 0 !== x.morphAttributes.position,
                morphNormals: void 0 !== x.morphAttributes.normal,
                morphColors: void 0 !== x.morphAttributes.color,
                morphTargetsCount: S,
                morphTextureStride: L,
                numDirLights: o.directional.length,
                numPointLights: o.point.length,
                numSpotLights: o.spot.length,
                numSpotLightMaps: o.spotLightMap.length,
                numRectAreaLights: o.rectArea.length,
                numHemiLights: o.hemi.length,
                numDirLightShadows: o.directionalShadowMap.length,
                numPointLightShadows: o.pointShadowMap.length,
                numSpotLightShadows: o.spotShadowMap.length,
                numSpotLightShadowsWithMaps: o.numSpotLightShadowsWithMaps,
                numClippingPlanes: a.numPlanes,
                numClipIntersection: a.numIntersection,
                dithering: s.dithering,
                shadowMapEnabled: e.shadowMap.enabled && c.length > 0,
                shadowMapType: e.shadowMap.type,
                toneMapping: s.toneMapped ? e.toneMapping : 0,
                physicallyCorrectLights: e.physicallyCorrectLights,
                premultipliedAlpha: s.premultipliedAlpha,
                doubleSided: s.side === ae,
                flipSided: 1 === s.side,
                useDepthPacking: !!s.depthPacking,
                depthPacking: s.depthPacking || 0,
                index0AttributeName: s.index0AttributeName,
                extensionDerivatives: s.extensions && s.extensions.derivatives,
                extensionFragDepth: s.extensions && s.extensions.fragDepth,
                extensionDrawBuffers: s.extensions && s.extensions.drawBuffers,
                extensionShaderTextureLOD: s.extensions && s.extensions.shaderTextureLOD,
                rendererExtensionFragDepth: h || i.has("EXT_frag_depth"),
                rendererExtensionDrawBuffers: h || i.has("WEBGL_draw_buffers"),
                rendererExtensionShaderTextureLod: h || i.has("EXT_shader_texture_lod"),
                customProgramCacheKey: s.customProgramCacheKey()
            }
        },
        getProgramCacheKey: function(t) {
            const n = [];
            if (t.shaderID ? n.push(t.shaderID) : (n.push(t.customVertexShaderID),
            n.push(t.customFragmentShaderID)),
            void 0 !== t.defines)
                for (const e in t.defines)
                    n.push(e),
                    n.push(t.defines[e]);
            return !1 === t.isRawShaderMaterial && (!function(e, t) {
                e.push(t.precision),
                e.push(t.outputEncoding),
                e.push(t.envMapMode),
                e.push(t.envMapCubeUVHeight),
                e.push(t.combine),
                e.push(t.vertexUvs),
                e.push(t.fogExp2),
                e.push(t.sizeAttenuation),
                e.push(t.morphTargetsCount),
                e.push(t.morphAttributeCount),
                e.push(t.numDirLights),
                e.push(t.numPointLights),
                e.push(t.numSpotLights),
                e.push(t.numSpotLightMaps),
                e.push(t.numHemiLights),
                e.push(t.numRectAreaLights),
                e.push(t.numDirLightShadows),
                e.push(t.numPointLightShadows),
                e.push(t.numSpotLightShadows),
                e.push(t.numSpotLightShadowsWithMaps),
                e.push(t.shadowMapType),
                e.push(t.toneMapping),
                e.push(t.numClippingPlanes),
                e.push(t.numClipIntersection),
                e.push(t.depthPacking)
            }(n, t),
            function(e, t) {
                o.disableAll(),
                t.isWebGL2 && o.enable(0);
                t.supportsVertexTextures && o.enable(1);
                t.instancing && o.enable(2);
                t.instancingColor && o.enable(3);
                t.map && o.enable(4);
                t.matcap && o.enable(5);
                t.envMap && o.enable(6);
                t.lightMap && o.enable(7);
                t.aoMap && o.enable(8);
                t.emissiveMap && o.enable(9);
                t.bumpMap && o.enable(10);
                t.normalMap && o.enable(11);
                t.objectSpaceNormalMap && o.enable(12);
                t.tangentSpaceNormalMap && o.enable(13);
                t.clearcoat && o.enable(14);
                t.clearcoatMap && o.enable(15);
                t.clearcoatRoughnessMap && o.enable(16);
                t.clearcoatNormalMap && o.enable(17);
                t.iridescence && o.enable(18);
                t.iridescenceMap && o.enable(19);
                t.iridescenceThicknessMap && o.enable(20);
                t.displacementMap && o.enable(21);
                t.specularMap && o.enable(22);
                t.roughnessMap && o.enable(23);
                t.metalnessMap && o.enable(24);
                t.gradientMap && o.enable(25);
                t.alphaMap && o.enable(26);
                t.alphaTest && o.enable(27);
                t.vertexColors && o.enable(28);
                t.vertexAlphas && o.enable(29);
                t.vertexUvs && o.enable(30);
                t.vertexTangents && o.enable(31);
                t.uvsVertexOnly && o.enable(32);
                e.push(o.mask),
                o.disableAll(),
                t.fog && o.enable(0);
                t.useFog && o.enable(1);
                t.flatShading && o.enable(2);
                t.logarithmicDepthBuffer && o.enable(3);
                t.skinning && o.enable(4);
                t.morphTargets && o.enable(5);
                t.morphNormals && o.enable(6);
                t.morphColors && o.enable(7);
                t.premultipliedAlpha && o.enable(8);
                t.shadowMapEnabled && o.enable(9);
                t.physicallyCorrectLights && o.enable(10);
                t.doubleSided && o.enable(11);
                t.flipSided && o.enable(12);
                t.useDepthPacking && o.enable(13);
                t.dithering && o.enable(14);
                t.specularIntensityMap && o.enable(15);
                t.specularColorMap && o.enable(16);
                t.transmission && o.enable(17);
                t.transmissionMap && o.enable(18);
                t.thicknessMap && o.enable(19);
                t.sheen && o.enable(20);
                t.sheenColorMap && o.enable(21);
                t.sheenRoughnessMap && o.enable(22);
                t.decodeVideoTexture && o.enable(23);
                t.opaque && o.enable(24);
                e.push(o.mask)
            }(n, t),
            n.push(e.outputEncoding)),
            n.push(t.customProgramCacheKey),
            n.join()
        },
        getUniforms: function(e) {
            const t = m[e.type];
            let n;
            if (t) {
                const e = Ir[t];
                n = dr.clone(e.uniforms)
            } else
                n = e.uniforms;
            return n
        },
        acquireProgram: function(t, n) {
            let i;
            for (let e = 0, t = c.length; e < t; e++) {
                const t = c[e];
                if (t.cacheKey === n) {
                    i = t,
                    ++i.usedTimes;
                    break
                }
            }
            return void 0 === i && (i = new Ca(e,n,t,s),
            c.push(i)),
            i
        },
        releaseProgram: function(e) {
            if (0 == --e.usedTimes) {
                const t = c.indexOf(e);
                c[t] = c[c.length - 1],
                c.pop(),
                e.destroy()
            }
        },
        releaseShaderCache: function(e) {
            l.remove(e)
        },
        programs: c,
        dispose: function() {
            l.dispose()
        }
    }
}
function Da() {
    let e = new WeakMap;
    return {
        get: function(t) {
            let n = e.get(t);
            return void 0 === n && (n = {},
            e.set(t, n)),
            n
        },
        remove: function(t) {
            e.delete(t)
        },
        update: function(t, n, i) {
            e.get(t)[n] = i
        },
        dispose: function() {
            e = new WeakMap
        }
    }
}
function Oa(e, t) {
    return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
}
function Na(e, t) {
    return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
}
function za() {
    const e = [];
    let t = 0;
    const n = []
      , i = []
      , r = [];
    function s(n, i, r, s, a, o) {
        let l = e[t];
        return void 0 === l ? (l = {
            id: n.id,
            object: n,
            geometry: i,
            material: r,
            groupOrder: s,
            renderOrder: n.renderOrder,
            z: a,
            group: o
        },
        e[t] = l) : (l.id = n.id,
        l.object = n,
        l.geometry = i,
        l.material = r,
        l.groupOrder = s,
        l.renderOrder = n.renderOrder,
        l.z = a,
        l.group = o),
        t++,
        l
    }
    return {
        opaque: n,
        transmissive: i,
        transparent: r,
        init: function() {
            t = 0,
            n.length = 0,
            i.length = 0,
            r.length = 0
        },
        push: function(e, t, a, o, l, c) {
            const h = s(e, t, a, o, l, c);
            a.transmission > 0 ? i.push(h) : !0 === a.transparent ? r.push(h) : n.push(h)
        },
        unshift: function(e, t, a, o, l, c) {
            const h = s(e, t, a, o, l, c);
            a.transmission > 0 ? i.unshift(h) : !0 === a.transparent ? r.unshift(h) : n.unshift(h)
        },
        finish: function() {
            for (let n = t, i = e.length; n < i; n++) {
                const t = e[n];
                if (null === t.id)
                    break;
                t.id = null,
                t.object = null,
                t.geometry = null,
                t.material = null,
                t.group = null
            }
        },
        sort: function(e, t) {
            n.length > 1 && n.sort(e || Oa),
            i.length > 1 && i.sort(t || Na),
            r.length > 1 && r.sort(t || Na)
        }
    }
}
function Ua() {
    let e = new WeakMap;
    return {
        get: function(t, n) {
            const i = e.get(t);
            let r;
            return void 0 === i ? (r = new za,
            e.set(t, [r])) : n >= i.length ? (r = new za,
            i.push(r)) : r = i[n],
            r
        },
        dispose: function() {
            e = new WeakMap
        }
    }
}
function Fa() {
    const e = {};
    return {
        get: function(t) {
            if (void 0 !== e[t.id])
                return e[t.id];
            let n;
            switch (t.type) {
            case "DirectionalLight":
                n = {
                    direction: new pn,
                    color: new en
                };
                break;
            case "SpotLight":
                n = {
                    position: new pn,
                    direction: new pn,
                    color: new en,
                    distance: 0,
                    coneCos: 0,
                    penumbraCos: 0,
                    decay: 0
                };
                break;
            case "PointLight":
                n = {
                    position: new pn,
                    color: new en,
                    distance: 0,
                    decay: 0
                };
                break;
            case "HemisphereLight":
                n = {
                    direction: new pn,
                    skyColor: new en,
                    groundColor: new en
                };
                break;
            case "RectAreaLight":
                n = {
                    color: new en,
                    position: new pn,
                    halfWidth: new pn,
                    halfHeight: new pn
                }
            }
            return e[t.id] = n,
            n
        }
    }
}
let Ba = 0;
function ka(e, t) {
    return (t.castShadow ? 2 : 0) - (e.castShadow ? 2 : 0) + (t.map ? 1 : 0) - (e.map ? 1 : 0)
}
function Ga(e, t) {
    const n = new Fa
      , i = function() {
        const e = {};
        return {
            get: function(t) {
                if (void 0 !== e[t.id])
                    return e[t.id];
                let n;
                switch (t.type) {
                case "DirectionalLight":
                case "SpotLight":
                    n = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Ft
                    };
                    break;
                case "PointLight":
                    n = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Ft,
                        shadowCameraNear: 1,
                        shadowCameraFar: 1e3
                    }
                }
                return e[t.id] = n,
                n
            }
        }
    }()
      , r = {
        version: 0,
        hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1,
            numSpotMaps: -1
        },
        ambient: [0, 0, 0],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotLightMap: [],
        spotShadow: [],
        spotShadowMap: [],
        spotLightMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: [],
        numSpotLightShadowsWithMaps: 0
    };
    for (let e = 0; e < 9; e++)
        r.probe.push(new pn);
    const s = new pn
      , a = new Wn
      , o = new Wn;
    return {
        setup: function(s, a) {
            let o = 0
              , l = 0
              , c = 0;
            for (let e = 0; e < 9; e++)
                r.probe[e].set(0, 0, 0);
            let h = 0
              , u = 0
              , d = 0
              , p = 0
              , m = 0
              , f = 0
              , g = 0
              , v = 0
              , x = 0
              , y = 0;
            s.sort(ka);
            const _ = !0 !== a ? Math.PI : 1;
            for (let e = 0, t = s.length; e < t; e++) {
                const t = s[e]
                  , a = t.color
                  , b = t.intensity
                  , M = t.distance
                  , w = t.shadow && t.shadow.map ? t.shadow.map.texture : null;
                if (t.isAmbientLight)
                    o += a.r * b * _,
                    l += a.g * b * _,
                    c += a.b * b * _;
                else if (t.isLightProbe)
                    for (let e = 0; e < 9; e++)
                        r.probe[e].addScaledVector(t.sh.coefficients[e], b);
                else if (t.isDirectionalLight) {
                    const e = n.get(t);
                    if (e.color.copy(t.color).multiplyScalar(t.intensity * _),
                    t.castShadow) {
                        const e = t.shadow
                          , n = i.get(t);
                        n.shadowBias = e.bias,
                        n.shadowNormalBias = e.normalBias,
                        n.shadowRadius = e.radius,
                        n.shadowMapSize = e.mapSize,
                        r.directionalShadow[h] = n,
                        r.directionalShadowMap[h] = w,
                        r.directionalShadowMatrix[h] = t.shadow.matrix,
                        f++
                    }
                    r.directional[h] = e,
                    h++
                } else if (t.isSpotLight) {
                    const e = n.get(t);
                    e.position.setFromMatrixPosition(t.matrixWorld),
                    e.color.copy(a).multiplyScalar(b * _),
                    e.distance = M,
                    e.coneCos = Math.cos(t.angle),
                    e.penumbraCos = Math.cos(t.angle * (1 - t.penumbra)),
                    e.decay = t.decay,
                    r.spot[d] = e;
                    const s = t.shadow;
                    if (t.map && (r.spotLightMap[x] = t.map,
                    x++,
                    s.updateMatrices(t),
                    t.castShadow && y++),
                    r.spotLightMatrix[d] = s.matrix,
                    t.castShadow) {
                        const e = i.get(t);
                        e.shadowBias = s.bias,
                        e.shadowNormalBias = s.normalBias,
                        e.shadowRadius = s.radius,
                        e.shadowMapSize = s.mapSize,
                        r.spotShadow[d] = e,
                        r.spotShadowMap[d] = w,
                        v++
                    }
                    d++
                } else if (t.isRectAreaLight) {
                    const e = n.get(t);
                    e.color.copy(a).multiplyScalar(b),
                    e.halfWidth.set(.5 * t.width, 0, 0),
                    e.halfHeight.set(0, .5 * t.height, 0),
                    r.rectArea[p] = e,
                    p++
                } else if (t.isPointLight) {
                    const e = n.get(t);
                    if (e.color.copy(t.color).multiplyScalar(t.intensity * _),
                    e.distance = t.distance,
                    e.decay = t.decay,
                    t.castShadow) {
                        const e = t.shadow
                          , n = i.get(t);
                        n.shadowBias = e.bias,
                        n.shadowNormalBias = e.normalBias,
                        n.shadowRadius = e.radius,
                        n.shadowMapSize = e.mapSize,
                        n.shadowCameraNear = e.camera.near,
                        n.shadowCameraFar = e.camera.far,
                        r.pointShadow[u] = n,
                        r.pointShadowMap[u] = w,
                        r.pointShadowMatrix[u] = t.shadow.matrix,
                        g++
                    }
                    r.point[u] = e,
                    u++
                } else if (t.isHemisphereLight) {
                    const e = n.get(t);
                    e.skyColor.copy(t.color).multiplyScalar(b * _),
                    e.groundColor.copy(t.groundColor).multiplyScalar(b * _),
                    r.hemi[m] = e,
                    m++
                }
            }
            p > 0 && (t.isWebGL2 || !0 === e.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = Pr.LTC_FLOAT_1,
            r.rectAreaLTC2 = Pr.LTC_FLOAT_2) : !0 === e.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = Pr.LTC_HALF_1,
            r.rectAreaLTC2 = Pr.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),
            r.ambient[0] = o,
            r.ambient[1] = l,
            r.ambient[2] = c;
            const b = r.hash;
            b.directionalLength === h && b.pointLength === u && b.spotLength === d && b.rectAreaLength === p && b.hemiLength === m && b.numDirectionalShadows === f && b.numPointShadows === g && b.numSpotShadows === v && b.numSpotMaps === x || (r.directional.length = h,
            r.spot.length = d,
            r.rectArea.length = p,
            r.point.length = u,
            r.hemi.length = m,
            r.directionalShadow.length = f,
            r.directionalShadowMap.length = f,
            r.pointShadow.length = g,
            r.pointShadowMap.length = g,
            r.spotShadow.length = v,
            r.spotShadowMap.length = v,
            r.directionalShadowMatrix.length = f,
            r.pointShadowMatrix.length = g,
            r.spotLightMatrix.length = v + x - y,
            r.spotLightMap.length = x,
            r.numSpotLightShadowsWithMaps = y,
            b.directionalLength = h,
            b.pointLength = u,
            b.spotLength = d,
            b.rectAreaLength = p,
            b.hemiLength = m,
            b.numDirectionalShadows = f,
            b.numPointShadows = g,
            b.numSpotShadows = v,
            b.numSpotMaps = x,
            r.version = Ba++)
        },
        setupView: function(e, t) {
            let n = 0
              , i = 0
              , l = 0
              , c = 0
              , h = 0;
            const u = t.matrixWorldInverse;
            for (let t = 0, d = e.length; t < d; t++) {
                const d = e[t];
                if (d.isDirectionalLight) {
                    const e = r.directional[n];
                    e.direction.setFromMatrixPosition(d.matrixWorld),
                    s.setFromMatrixPosition(d.target.matrixWorld),
                    e.direction.sub(s),
                    e.direction.transformDirection(u),
                    n++
                } else if (d.isSpotLight) {
                    const e = r.spot[l];
                    e.position.setFromMatrixPosition(d.matrixWorld),
                    e.position.applyMatrix4(u),
                    e.direction.setFromMatrixPosition(d.matrixWorld),
                    s.setFromMatrixPosition(d.target.matrixWorld),
                    e.direction.sub(s),
                    e.direction.transformDirection(u),
                    l++
                } else if (d.isRectAreaLight) {
                    const e = r.rectArea[c];
                    e.position.setFromMatrixPosition(d.matrixWorld),
                    e.position.applyMatrix4(u),
                    o.identity(),
                    a.copy(d.matrixWorld),
                    a.premultiply(u),
                    o.extractRotation(a),
                    e.halfWidth.set(.5 * d.width, 0, 0),
                    e.halfHeight.set(0, .5 * d.height, 0),
                    e.halfWidth.applyMatrix4(o),
                    e.halfHeight.applyMatrix4(o),
                    c++
                } else if (d.isPointLight) {
                    const e = r.point[i];
                    e.position.setFromMatrixPosition(d.matrixWorld),
                    e.position.applyMatrix4(u),
                    i++
                } else if (d.isHemisphereLight) {
                    const e = r.hemi[h];
                    e.direction.setFromMatrixPosition(d.matrixWorld),
                    e.direction.transformDirection(u),
                    h++
                }
            }
        },
        state: r
    }
}
function Ha(e, t) {
    const n = new Ga(e,t)
      , i = []
      , r = [];
    return {
        init: function() {
            i.length = 0,
            r.length = 0
        },
        state: {
            lightsArray: i,
            shadowsArray: r,
            lights: n
        },
        setupLights: function(e) {
            n.setup(i, e)
        },
        setupLightsView: function(e) {
            n.setupView(i, e)
        },
        pushLight: function(e) {
            i.push(e)
        },
        pushShadow: function(e) {
            r.push(e)
        }
    }
}
function Va(e, t) {
    let n = new WeakMap;
    return {
        get: function(i, r=0) {
            const s = n.get(i);
            let a;
            return void 0 === s ? (a = new Ha(e,t),
            n.set(i, [a])) : r >= s.length ? (a = new Ha(e,t),
            s.push(a)) : a = s[r],
            a
        },
        dispose: function() {
            n = new WeakMap
        }
    }
}
class Wa extends Ci {
    constructor(e) {
        super(),
        this.isMeshDepthMaterial = !0,
        this.type = "MeshDepthMaterial",
        this.depthPacking = 3200,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.depthPacking = e.depthPacking,
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this
    }
}
class ja extends Ci {
    constructor(e) {
        super(),
        this.isMeshDistanceMaterial = !0,
        this.type = "MeshDistanceMaterial",
        this.referencePosition = new pn,
        this.nearDistance = 1,
        this.farDistance = 1e3,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.referencePosition.copy(e.referencePosition),
        this.nearDistance = e.nearDistance,
        this.farDistance = e.farDistance,
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this
    }
}
function Xa(e, t, n) {
    let i = new Ar;
    const r = new Ft
      , s = new Ft
      , a = new ln
      , o = new Wa({
        depthPacking: 3201
    })
      , l = new ja
      , c = {}
      , h = n.maxTextureSize
      , u = {
        0: 1,
        1: 0,
        2: ae
    }
      , d = new pr({
        defines: {
            VSM_SAMPLES: 8
        },
        uniforms: {
            shadow_pass: {
                value: null
            },
            resolution: {
                value: new Ft
            },
            radius: {
                value: 4
            }
        },
        vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
        fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
    })
      , p = d.clone();
    p.defines.HORIZONTAL_PASS = 1;
    const m = new Vi;
    m.setAttribute("position", new Ii(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
    const f = new or(m,d)
      , g = this;
    function v(n, i) {
        const s = t.update(f);
        d.defines.VSM_SAMPLES !== n.blurSamples && (d.defines.VSM_SAMPLES = n.blurSamples,
        p.defines.VSM_SAMPLES = n.blurSamples,
        d.needsUpdate = !0,
        p.needsUpdate = !0),
        null === n.mapPass && (n.mapPass = new cn(r.x,r.y)),
        d.uniforms.shadow_pass.value = n.map.texture,
        d.uniforms.resolution.value = n.mapSize,
        d.uniforms.radius.value = n.radius,
        e.setRenderTarget(n.mapPass),
        e.clear(),
        e.renderBufferDirect(i, null, s, d, f, null),
        p.uniforms.shadow_pass.value = n.mapPass.texture,
        p.uniforms.resolution.value = n.mapSize,
        p.uniforms.radius.value = n.radius,
        e.setRenderTarget(n.map),
        e.clear(),
        e.renderBufferDirect(i, null, s, p, f, null)
    }
    function x(t, n, i, r, s, a) {
        let h = null;
        const d = !0 === i.isPointLight ? t.customDistanceMaterial : t.customDepthMaterial;
        if (h = void 0 !== d ? d : !0 === i.isPointLight ? l : o,
        e.localClippingEnabled && !0 === n.clipShadows && Array.isArray(n.clippingPlanes) && 0 !== n.clippingPlanes.length || n.displacementMap && 0 !== n.displacementScale || n.alphaMap && n.alphaTest > 0) {
            const e = h.uuid
              , t = n.uuid;
            let i = c[e];
            void 0 === i && (i = {},
            c[e] = i);
            let r = i[t];
            void 0 === r && (r = h.clone(),
            i[t] = r),
            h = r
        }
        return h.visible = n.visible,
        h.wireframe = n.wireframe,
        h.side = 3 === a ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : u[n.side],
        h.alphaMap = n.alphaMap,
        h.alphaTest = n.alphaTest,
        h.clipShadows = n.clipShadows,
        h.clippingPlanes = n.clippingPlanes,
        h.clipIntersection = n.clipIntersection,
        h.displacementMap = n.displacementMap,
        h.displacementScale = n.displacementScale,
        h.displacementBias = n.displacementBias,
        h.wireframeLinewidth = n.wireframeLinewidth,
        h.linewidth = n.linewidth,
        !0 === i.isPointLight && !0 === h.isMeshDistanceMaterial && (h.referencePosition.setFromMatrixPosition(i.matrixWorld),
        h.nearDistance = r,
        h.farDistance = s),
        h
    }
    function y(n, r, s, a, o) {
        if (!1 === n.visible)
            return;
        if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && 3 === o) && (!n.frustumCulled || i.intersectsObject(n))) {
            n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, n.matrixWorld);
            const i = t.update(n)
              , r = n.material;
            if (Array.isArray(r)) {
                const t = i.groups;
                for (let l = 0, c = t.length; l < c; l++) {
                    const c = t[l]
                      , h = r[c.materialIndex];
                    if (h && h.visible) {
                        const t = x(n, h, a, s.near, s.far, o);
                        e.renderBufferDirect(s, null, i, t, n, c)
                    }
                }
            } else if (r.visible) {
                const t = x(n, r, a, s.near, s.far, o);
                e.renderBufferDirect(s, null, i, t, n, null)
            }
        }
        const l = n.children;
        for (let e = 0, t = l.length; e < t; e++)
            y(l[e], r, s, a, o)
    }
    this.enabled = !1,
    this.autoUpdate = !0,
    this.needsUpdate = !1,
    this.type = 1,
    this.render = function(t, n, o) {
        if (!1 === g.enabled)
            return;
        if (!1 === g.autoUpdate && !1 === g.needsUpdate)
            return;
        if (0 === t.length)
            return;
        const l = e.getRenderTarget()
          , c = e.getActiveCubeFace()
          , u = e.getActiveMipmapLevel()
          , d = e.state;
        d.setBlending(0),
        d.buffers.color.setClear(1, 1, 1, 1),
        d.buffers.depth.setTest(!0),
        d.setScissorTest(!1);
        for (let l = 0, c = t.length; l < c; l++) {
            const c = t[l]
              , u = c.shadow;
            if (void 0 === u) {
                console.warn("THREE.WebGLShadowMap:", c, "has no shadow.");
                continue
            }
            if (!1 === u.autoUpdate && !1 === u.needsUpdate)
                continue;
            r.copy(u.mapSize);
            const p = u.getFrameExtents();
            if (r.multiply(p),
            s.copy(u.mapSize),
            (r.x > h || r.y > h) && (r.x > h && (s.x = Math.floor(h / p.x),
            r.x = s.x * p.x,
            u.mapSize.x = s.x),
            r.y > h && (s.y = Math.floor(h / p.y),
            r.y = s.y * p.y,
            u.mapSize.y = s.y)),
            null === u.map) {
                const e = 3 !== this.type ? {
                    minFilter: _e,
                    magFilter: _e
                } : {};
                u.map = new cn(r.x,r.y,e),
                u.map.texture.name = c.name + ".shadowMap",
                u.camera.updateProjectionMatrix()
            }
            e.setRenderTarget(u.map),
            e.clear();
            const m = u.getViewportCount();
            for (let e = 0; e < m; e++) {
                const t = u.getViewport(e);
                a.set(s.x * t.x, s.y * t.y, s.x * t.z, s.y * t.w),
                d.viewport(a),
                u.updateMatrices(c, e),
                i = u.getFrustum(),
                y(n, o, u.camera, c, this.type)
            }
            !0 !== u.isPointLightShadow && 3 === this.type && v(u, o),
            u.needsUpdate = !1
        }
        g.needsUpdate = !1,
        e.setRenderTarget(l, c, u)
    }
}
function qa(e, t, n) {
    const i = n.isWebGL2;
    const r = new function() {
        let t = !1;
        const n = new ln;
        let i = null;
        const r = new ln(0,0,0,0);
        return {
            setMask: function(n) {
                i === n || t || (e.colorMask(n, n, n, n),
                i = n)
            },
            setLocked: function(e) {
                t = e
            },
            setClear: function(t, i, s, a, o) {
                !0 === o && (t *= a,
                i *= a,
                s *= a),
                n.set(t, i, s, a),
                !1 === r.equals(n) && (e.clearColor(t, i, s, a),
                r.copy(n))
            },
            reset: function() {
                t = !1,
                i = null,
                r.set(-1, 0, 0, 0)
            }
        }
    }
      , s = new function() {
        let t = !1
          , n = null
          , i = null
          , r = null;
        return {
            setTest: function(e) {
                e ? k(2929) : G(2929)
            },
            setMask: function(i) {
                n === i || t || (e.depthMask(i),
                n = i)
            },
            setFunc: function(t) {
                if (i !== t) {
                    if (t)
                        switch (t) {
                        case 0:
                            e.depthFunc(512);
                            break;
                        case 1:
                            e.depthFunc(519);
                            break;
                        case 2:
                            e.depthFunc(513);
                            break;
                        case 3:
                        default:
                            e.depthFunc(515);
                            break;
                        case 4:
                            e.depthFunc(514);
                            break;
                        case 5:
                            e.depthFunc(518);
                            break;
                        case 6:
                            e.depthFunc(516);
                            break;
                        case 7:
                            e.depthFunc(517)
                        }
                    else
                        e.depthFunc(515);
                    i = t
                }
            },
            setLocked: function(e) {
                t = e
            },
            setClear: function(t) {
                r !== t && (e.clearDepth(t),
                r = t)
            },
            reset: function() {
                t = !1,
                n = null,
                i = null,
                r = null
            }
        }
    }
      , a = new function() {
        let t = !1
          , n = null
          , i = null
          , r = null
          , s = null
          , a = null
          , o = null
          , l = null
          , c = null;
        return {
            setTest: function(e) {
                t || (e ? k(2960) : G(2960))
            },
            setMask: function(i) {
                n === i || t || (e.stencilMask(i),
                n = i)
            },
            setFunc: function(t, n, a) {
                i === t && r === n && s === a || (e.stencilFunc(t, n, a),
                i = t,
                r = n,
                s = a)
            },
            setOp: function(t, n, i) {
                a === t && o === n && l === i || (e.stencilOp(t, n, i),
                a = t,
                o = n,
                l = i)
            },
            setLocked: function(e) {
                t = e
            },
            setClear: function(t) {
                c !== t && (e.clearStencil(t),
                c = t)
            },
            reset: function() {
                t = !1,
                n = null,
                i = null,
                r = null,
                s = null,
                a = null,
                o = null,
                l = null,
                c = null
            }
        }
    }
      , o = new WeakMap
      , l = new WeakMap;
    let c = {}
      , h = {}
      , u = new WeakMap
      , d = []
      , p = null
      , m = !1
      , f = null
      , g = null
      , v = null
      , x = null
      , y = null
      , _ = null
      , b = null
      , M = !1
      , w = null
      , S = null
      , T = null
      , A = null
      , E = null;
    const C = e.getParameter(35661);
    let L = !1
      , R = 0;
    const P = e.getParameter(7938);
    -1 !== P.indexOf("WebGL") ? (R = parseFloat(/^WebGL (\d)/.exec(P)[1]),
    L = R >= 1) : -1 !== P.indexOf("OpenGL ES") && (R = parseFloat(/^OpenGL ES (\d)/.exec(P)[1]),
    L = R >= 2);
    let I = null
      , D = {};
    const O = e.getParameter(3088)
      , N = e.getParameter(2978)
      , z = (new ln).fromArray(O)
      , U = (new ln).fromArray(N);
    function F(t, n, i) {
        const r = new Uint8Array(4)
          , s = e.createTexture();
        e.bindTexture(t, s),
        e.texParameteri(t, 10241, 9728),
        e.texParameteri(t, 10240, 9728);
        for (let t = 0; t < i; t++)
            e.texImage2D(n + t, 0, 6408, 1, 1, 0, 6408, 5121, r);
        return s
    }
    const B = {};
    function k(t) {
        !0 !== c[t] && (e.enable(t),
        c[t] = !0)
    }
    function G(t) {
        !1 !== c[t] && (e.disable(t),
        c[t] = !1)
    }
    B[3553] = F(3553, 3553, 1),
    B[34067] = F(34067, 34069, 6),
    r.setClear(0, 0, 0, 1),
    s.setClear(1),
    a.setClear(0),
    k(2929),
    s.setFunc(3),
    j(!1),
    X(1),
    k(2884),
    W(0);
    const H = {
        [ce]: 32774,
        101: 32778,
        102: 32779
    };
    if (i)
        H[103] = 32775,
        H[104] = 32776;
    else {
        const e = t.get("EXT_blend_minmax");
        null !== e && (H[103] = e.MIN_EXT,
        H[104] = e.MAX_EXT)
    }
    const V = {
        200: 0,
        201: 1,
        202: 768,
        204: 770,
        210: 776,
        208: 774,
        206: 772,
        203: 769,
        205: 771,
        209: 775,
        207: 773
    };
    function W(t, n, i, r, s, a, o, l) {
        if (0 !== t) {
            if (!1 === m && (k(3042),
            m = !0),
            5 === t)
                s = s || n,
                a = a || i,
                o = o || r,
                n === g && s === y || (e.blendEquationSeparate(H[n], H[s]),
                g = n,
                y = s),
                i === v && r === x && a === _ && o === b || (e.blendFuncSeparate(V[i], V[r], V[a], V[o]),
                v = i,
                x = r,
                _ = a,
                b = o),
                f = t,
                M = null;
            else if (t !== f || l !== M) {
                if (g === ce && y === ce || (e.blendEquation(32774),
                g = ce,
                y = ce),
                l)
                    switch (t) {
                    case 1:
                        e.blendFuncSeparate(1, 771, 1, 771);
                        break;
                    case 2:
                        e.blendFunc(1, 1);
                        break;
                    case 3:
                        e.blendFuncSeparate(0, 769, 0, 1);
                        break;
                    case 4:
                        e.blendFuncSeparate(0, 768, 0, 770);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", t)
                    }
                else
                    switch (t) {
                    case 1:
                        e.blendFuncSeparate(770, 771, 1, 771);
                        break;
                    case 2:
                        e.blendFunc(770, 1);
                        break;
                    case 3:
                        e.blendFuncSeparate(0, 769, 0, 1);
                        break;
                    case 4:
                        e.blendFunc(0, 768);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", t)
                    }
                v = null,
                x = null,
                _ = null,
                b = null,
                f = t,
                M = l
            }
        } else
            !0 === m && (G(3042),
            m = !1)
    }
    function j(t) {
        w !== t && (t ? e.frontFace(2304) : e.frontFace(2305),
        w = t)
    }
    function X(t) {
        0 !== t ? (k(2884),
        t !== S && (1 === t ? e.cullFace(1029) : 2 === t ? e.cullFace(1028) : e.cullFace(1032))) : G(2884),
        S = t
    }
    function q(t, n, i) {
        t ? (k(32823),
        A === n && E === i || (e.polygonOffset(n, i),
        A = n,
        E = i)) : G(32823)
    }
    function Y(t) {
        void 0 === t && (t = 33984 + C - 1),
        I !== t && (e.activeTexture(t),
        I = t)
    }
    return {
        buffers: {
            color: r,
            depth: s,
            stencil: a
        },
        enable: k,
        disable: G,
        bindFramebuffer: function(t, n) {
            return h[t] !== n && (e.bindFramebuffer(t, n),
            h[t] = n,
            i && (36009 === t && (h[36160] = n),
            36160 === t && (h[36009] = n)),
            !0)
        },
        drawBuffers: function(i, r) {
            let s = d
              , a = !1;
            if (i)
                if (s = u.get(r),
                void 0 === s && (s = [],
                u.set(r, s)),
                i.isWebGLMultipleRenderTargets) {
                    const e = i.texture;
                    if (s.length !== e.length || 36064 !== s[0]) {
                        for (let t = 0, n = e.length; t < n; t++)
                            s[t] = 36064 + t;
                        s.length = e.length,
                        a = !0
                    }
                } else
                    36064 !== s[0] && (s[0] = 36064,
                    a = !0);
            else
                1029 !== s[0] && (s[0] = 1029,
                a = !0);
            a && (n.isWebGL2 ? e.drawBuffers(s) : t.get("WEBGL_draw_buffers").drawBuffersWEBGL(s))
        },
        useProgram: function(t) {
            return p !== t && (e.useProgram(t),
            p = t,
            !0)
        },
        setBlending: W,
        setMaterial: function(e, t) {
            e.side === ae ? G(2884) : k(2884);
            let n = 1 === e.side;
            t && (n = !n),
            j(n),
            1 === e.blending && !1 === e.transparent ? W(0) : W(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha),
            s.setFunc(e.depthFunc),
            s.setTest(e.depthTest),
            s.setMask(e.depthWrite),
            r.setMask(e.colorWrite);
            const i = e.stencilWrite;
            a.setTest(i),
            i && (a.setMask(e.stencilWriteMask),
            a.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask),
            a.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)),
            q(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits),
            !0 === e.alphaToCoverage ? k(32926) : G(32926)
        },
        setFlipSided: j,
        setCullFace: X,
        setLineWidth: function(t) {
            t !== T && (L && e.lineWidth(t),
            T = t)
        },
        setPolygonOffset: q,
        setScissorTest: function(e) {
            e ? k(3089) : G(3089)
        },
        activeTexture: Y,
        bindTexture: function(t, n) {
            null === I && Y();
            let i = D[I];
            void 0 === i && (i = {
                type: void 0,
                texture: void 0
            },
            D[I] = i),
            i.type === t && i.texture === n || (e.bindTexture(t, n || B[t]),
            i.type = t,
            i.texture = n)
        },
        unbindTexture: function() {
            const t = D[I];
            void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null),
            t.type = void 0,
            t.texture = void 0)
        },
        compressedTexImage2D: function() {
            try {
                e.compressedTexImage2D.apply(e, arguments)
            } catch (e) {
                console.error("THREE.WebGLState:", e)
            }
        },
        texImage2D: function() {
            try {
                e.texImage2D.apply(e, arguments)
            } catch (e) {
                console.error("THREE.WebGLState:", e)
            }
        },
        texImage3D: function() {
            try {
                e.texImage3D.apply(e, arguments)
            } catch (e) {
                console.error("THREE.WebGLState:", e)
            }
        },
        updateUBOMapping: function(t, n) {
            let i = l.get(n);
            void 0 === i && (i = new WeakMap,
            l.set(n, i));
            let r = i.get(t);
            void 0 === r && (r = e.getUniformBlockIndex(n, t.name),
            i.set(t, r))
        },
        uniformBlockBinding: function(t, n) {
            const i = l.get(n).get(t);
            o.get(t) !== i && (e.uniformBlockBinding(n, i, t.__bindingPointIndex),
            o.set(t, i))
        },
        texStorage2D: function() {
            try {
                e.texStorage2D.apply(e, arguments)
            } catch (e) {
                console.error("THREE.WebGLState:", e)
            }
        },
        texStorage3D: function() {
            try {
                e.texStorage3D.apply(e, arguments)
            } catch (e) {
                console.error("THREE.WebGLState:", e)
            }
        },
        texSubImage2D: function() {
            try {
                e.texSubImage2D.apply(e, arguments)
            } catch (e) {
                console.error("THREE.WebGLState:", e)
            }
        },
        texSubImage3D: function() {
            try {
                e.texSubImage3D.apply(e, arguments)
            } catch (e) {
                console.error("THREE.WebGLState:", e)
            }
        },
        compressedTexSubImage2D: function() {
            try {
                e.compressedTexSubImage2D.apply(e, arguments)
            } catch (e) {
                console.error("THREE.WebGLState:", e)
            }
        },
        scissor: function(t) {
            !1 === z.equals(t) && (e.scissor(t.x, t.y, t.z, t.w),
            z.copy(t))
        },
        viewport: function(t) {
            !1 === U.equals(t) && (e.viewport(t.x, t.y, t.z, t.w),
            U.copy(t))
        },
        reset: function() {
            e.disable(3042),
            e.disable(2884),
            e.disable(2929),
            e.disable(32823),
            e.disable(3089),
            e.disable(2960),
            e.disable(32926),
            e.blendEquation(32774),
            e.blendFunc(1, 0),
            e.blendFuncSeparate(1, 0, 1, 0),
            e.colorMask(!0, !0, !0, !0),
            e.clearColor(0, 0, 0, 0),
            e.depthMask(!0),
            e.depthFunc(513),
            e.clearDepth(1),
            e.stencilMask(4294967295),
            e.stencilFunc(519, 0, 4294967295),
            e.stencilOp(7680, 7680, 7680),
            e.clearStencil(0),
            e.cullFace(1029),
            e.frontFace(2305),
            e.polygonOffset(0, 0),
            e.activeTexture(33984),
            e.bindFramebuffer(36160, null),
            !0 === i && (e.bindFramebuffer(36009, null),
            e.bindFramebuffer(36008, null)),
            e.useProgram(null),
            e.lineWidth(1),
            e.scissor(0, 0, e.canvas.width, e.canvas.height),
            e.viewport(0, 0, e.canvas.width, e.canvas.height),
            c = {},
            I = null,
            D = {},
            h = {},
            u = new WeakMap,
            d = [],
            p = null,
            m = !1,
            f = null,
            g = null,
            v = null,
            x = null,
            y = null,
            _ = null,
            b = null,
            M = !1,
            w = null,
            S = null,
            T = null,
            A = null,
            E = null,
            z.set(0, 0, e.canvas.width, e.canvas.height),
            U.set(0, 0, e.canvas.width, e.canvas.height),
            r.reset(),
            s.reset(),
            a.reset()
        }
    }
}
function Ya(e, t, n, i, r, s, a) {
    const o = r.isWebGL2
      , l = r.maxTextures
      , c = r.maxCubemapSize
      , h = r.maxTextureSize
      , u = r.maxSamples
      , d = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null
      , p = /OculusBrowser/g.test(navigator.userAgent)
      , m = new WeakMap;
    let f;
    const g = new WeakMap;
    let v = !1;
    try {
        v = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1,1).getContext("2d")
    } catch (e) {}
    function x(e, t) {
        return v ? new OffscreenCanvas(e,t) : Vt("canvas")
    }
    function y(e, t, n, i) {
        let r = 1;
        if ((e.width > i || e.height > i) && (r = i / Math.max(e.width, e.height)),
        r < 1 || !0 === t) {
            if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                const i = t ? Ot : Math.floor
                  , s = i(r * e.width)
                  , a = i(r * e.height);
                void 0 === f && (f = x(s, a));
                const o = n ? x(s, a) : f;
                o.width = s,
                o.height = a;
                return o.getContext("2d").drawImage(e, 0, 0, s, a),
                console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + s + "x" + a + ")."),
                o
            }
            return "data"in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ")."),
            e
        }
        return e
    }
    function _(e) {
        return It(e.width) && It(e.height)
    }
    function b(e, t) {
        return e.generateMipmaps && t && e.minFilter !== _e && e.minFilter !== we
    }
    function M(t) {
        e.generateMipmap(t)
    }
    function w(n, i, r, s, a=!1) {
        if (!1 === o)
            return i;
        if (null !== n) {
            if (void 0 !== e[n])
                return e[n];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
        }
        let l = i;
        return 6403 === i && (5126 === r && (l = 33326),
        5131 === r && (l = 33325),
        5121 === r && (l = 33321)),
        33319 === i && (5126 === r && (l = 33328),
        5131 === r && (l = 33327),
        5121 === r && (l = 33323)),
        6408 === i && (5126 === r && (l = 34836),
        5131 === r && (l = 34842),
        5121 === r && (l = s === gt && !1 === a ? 35907 : 32856),
        32819 === r && (l = 32854),
        32820 === r && (l = 32855)),
        33325 !== l && 33326 !== l && 33327 !== l && 33328 !== l && 34842 !== l && 34836 !== l || t.get("EXT_color_buffer_float"),
        l
    }
    function S(e, t, n) {
        return !0 === b(e, n) || e.isFramebufferTexture && e.minFilter !== _e && e.minFilter !== we ? Math.log2(Math.max(t.width, t.height)) + 1 : void 0 !== e.mipmaps && e.mipmaps.length > 0 ? e.mipmaps.length : e.isCompressedTexture && Array.isArray(e.image) ? t.mipmaps.length : 1
    }
    function T(e) {
        return e === _e || e === be || e === Me ? 9728 : 9729
    }
    function A(e) {
        const t = e.target;
        t.removeEventListener("dispose", A),
        function(e) {
            const t = i.get(e);
            if (void 0 === t.__webglInit)
                return;
            const n = e.source
              , r = g.get(n);
            if (r) {
                const i = r[t.__cacheKey];
                i.usedTimes--,
                0 === i.usedTimes && C(e),
                0 === Object.keys(r).length && g.delete(n)
            }
            i.remove(e)
        }(t),
        t.isVideoTexture && m.delete(t)
    }
    function E(t) {
        const n = t.target;
        n.removeEventListener("dispose", E),
        function(t) {
            const n = t.texture
              , r = i.get(t)
              , s = i.get(n);
            void 0 !== s.__webglTexture && (e.deleteTexture(s.__webglTexture),
            a.memory.textures--);
            t.depthTexture && t.depthTexture.dispose();
            if (t.isWebGLCubeRenderTarget)
                for (let t = 0; t < 6; t++)
                    e.deleteFramebuffer(r.__webglFramebuffer[t]),
                    r.__webglDepthbuffer && e.deleteRenderbuffer(r.__webglDepthbuffer[t]);
            else {
                if (e.deleteFramebuffer(r.__webglFramebuffer),
                r.__webglDepthbuffer && e.deleteRenderbuffer(r.__webglDepthbuffer),
                r.__webglMultisampledFramebuffer && e.deleteFramebuffer(r.__webglMultisampledFramebuffer),
                r.__webglColorRenderbuffer)
                    for (let t = 0; t < r.__webglColorRenderbuffer.length; t++)
                        r.__webglColorRenderbuffer[t] && e.deleteRenderbuffer(r.__webglColorRenderbuffer[t]);
                r.__webglDepthRenderbuffer && e.deleteRenderbuffer(r.__webglDepthRenderbuffer)
            }
            if (t.isWebGLMultipleRenderTargets)
                for (let t = 0, r = n.length; t < r; t++) {
                    const r = i.get(n[t]);
                    r.__webglTexture && (e.deleteTexture(r.__webglTexture),
                    a.memory.textures--),
                    i.remove(n[t])
                }
            i.remove(n),
            i.remove(t)
        }(n)
    }
    function C(t) {
        const n = i.get(t);
        e.deleteTexture(n.__webglTexture);
        const r = t.source;
        delete g.get(r)[n.__cacheKey],
        a.memory.textures--
    }
    let L = 0;
    function R(e, t) {
        const r = i.get(e);
        if (e.isVideoTexture && function(e) {
            const t = a.render.frame;
            m.get(e) !== t && (m.set(e, t),
            e.update())
        }(e),
        !1 === e.isRenderTargetTexture && e.version > 0 && r.__version !== e.version) {
            const n = e.image;
            if (null === n)
                console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else {
                if (!1 !== n.complete)
                    return void N(r, e, t);
                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
            }
        }
        n.activeTexture(33984 + t),
        n.bindTexture(3553, r.__webglTexture)
    }
    const P = {
        [ve]: 10497,
        [xe]: 33071,
        [ye]: 33648
    }
      , I = {
        [_e]: 9728,
        [be]: 9984,
        [Me]: 9986,
        [we]: 9729,
        [Se]: 9985,
        [Te]: 9987
    };
    function D(n, s, a) {
        if (a ? (e.texParameteri(n, 10242, P[s.wrapS]),
        e.texParameteri(n, 10243, P[s.wrapT]),
        32879 !== n && 35866 !== n || e.texParameteri(n, 32882, P[s.wrapR]),
        e.texParameteri(n, 10240, I[s.magFilter]),
        e.texParameteri(n, 10241, I[s.minFilter])) : (e.texParameteri(n, 10242, 33071),
        e.texParameteri(n, 10243, 33071),
        32879 !== n && 35866 !== n || e.texParameteri(n, 32882, 33071),
        s.wrapS === xe && s.wrapT === xe || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),
        e.texParameteri(n, 10240, T(s.magFilter)),
        e.texParameteri(n, 10241, T(s.minFilter)),
        s.minFilter !== _e && s.minFilter !== we && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),
        !0 === t.has("EXT_texture_filter_anisotropic")) {
            const a = t.get("EXT_texture_filter_anisotropic");
            if (s.type === Le && !1 === t.has("OES_texture_float_linear"))
                return;
            if (!1 === o && s.type === Re && !1 === t.has("OES_texture_half_float_linear"))
                return;
            (s.anisotropy > 1 || i.get(s).__currentAnisotropy) && (e.texParameterf(n, a.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, r.getMaxAnisotropy())),
            i.get(s).__currentAnisotropy = s.anisotropy)
        }
    }
    function O(t, n) {
        let i = !1;
        void 0 === t.__webglInit && (t.__webglInit = !0,
        n.addEventListener("dispose", A));
        const r = n.source;
        let s = g.get(r);
        void 0 === s && (s = {},
        g.set(r, s));
        const o = function(e) {
            const t = [];
            return t.push(e.wrapS),
            t.push(e.wrapT),
            t.push(e.magFilter),
            t.push(e.minFilter),
            t.push(e.anisotropy),
            t.push(e.internalFormat),
            t.push(e.format),
            t.push(e.type),
            t.push(e.generateMipmaps),
            t.push(e.premultiplyAlpha),
            t.push(e.flipY),
            t.push(e.unpackAlignment),
            t.push(e.encoding),
            t.join()
        }(n);
        if (o !== t.__cacheKey) {
            void 0 === s[o] && (s[o] = {
                texture: e.createTexture(),
                usedTimes: 0
            },
            a.memory.textures++,
            i = !0),
            s[o].usedTimes++;
            const r = s[t.__cacheKey];
            void 0 !== r && (s[t.__cacheKey].usedTimes--,
            0 === r.usedTimes && C(n)),
            t.__cacheKey = o,
            t.__webglTexture = s[o].texture
        }
        return i
    }
    function N(t, i, r) {
        let a = 3553;
        i.isDataArrayTexture && (a = 35866),
        i.isData3DTexture && (a = 32879);
        const l = O(t, i)
          , c = i.source;
        if (n.activeTexture(33984 + r),
        n.bindTexture(a, t.__webglTexture),
        c.version !== c.__currentVersion || !0 === l) {
            e.pixelStorei(37440, i.flipY),
            e.pixelStorei(37441, i.premultiplyAlpha),
            e.pixelStorei(3317, i.unpackAlignment),
            e.pixelStorei(37443, 0);
            const t = function(e) {
                return !o && (e.wrapS !== xe || e.wrapT !== xe || e.minFilter !== _e && e.minFilter !== we)
            }(i) && !1 === _(i.image);
            let r = y(i.image, t, !1, h);
            r = G(i, r);
            const u = _(r) || o
              , d = s.convert(i.format, i.encoding);
            let p, m = s.convert(i.type), f = w(i.internalFormat, d, m, i.encoding, i.isVideoTexture);
            D(a, i, u);
            const g = i.mipmaps
              , v = o && !0 !== i.isVideoTexture
              , x = void 0 === c.__currentVersion || !0 === l
              , T = S(i, r, u);
            if (i.isDepthTexture)
                f = 6402,
                o ? f = i.type === Le ? 36012 : i.type === Ce ? 33190 : i.type === Pe ? 35056 : 33189 : i.type === Le && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),
                i.format === De && 6402 === f && i.type !== Ee && i.type !== Ce && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
                i.type = Ce,
                m = s.convert(i.type)),
                i.format === Oe && 6402 === f && (f = 34041,
                i.type !== Pe && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),
                i.type = Pe,
                m = s.convert(i.type))),
                x && (v ? n.texStorage2D(3553, 1, f, r.width, r.height) : n.texImage2D(3553, 0, f, r.width, r.height, 0, d, m, null));
            else if (i.isDataTexture)
                if (g.length > 0 && u) {
                    v && x && n.texStorage2D(3553, T, f, g[0].width, g[0].height);
                    for (let e = 0, t = g.length; e < t; e++)
                        p = g[e],
                        v ? n.texSubImage2D(3553, e, 0, 0, p.width, p.height, d, m, p.data) : n.texImage2D(3553, e, f, p.width, p.height, 0, d, m, p.data);
                    i.generateMipmaps = !1
                } else
                    v ? (x && n.texStorage2D(3553, T, f, r.width, r.height),
                    n.texSubImage2D(3553, 0, 0, 0, r.width, r.height, d, m, r.data)) : n.texImage2D(3553, 0, f, r.width, r.height, 0, d, m, r.data);
            else if (i.isCompressedTexture) {
                v && x && n.texStorage2D(3553, T, f, g[0].width, g[0].height);
                for (let e = 0, t = g.length; e < t; e++)
                    p = g[e],
                    i.format !== Ie ? null !== d ? v ? n.compressedTexSubImage2D(3553, e, 0, 0, p.width, p.height, d, p.data) : n.compressedTexImage2D(3553, e, f, p.width, p.height, 0, p.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : v ? n.texSubImage2D(3553, e, 0, 0, p.width, p.height, d, m, p.data) : n.texImage2D(3553, e, f, p.width, p.height, 0, d, m, p.data)
            } else if (i.isDataArrayTexture)
                v ? (x && n.texStorage3D(35866, T, f, r.width, r.height, r.depth),
                n.texSubImage3D(35866, 0, 0, 0, 0, r.width, r.height, r.depth, d, m, r.data)) : n.texImage3D(35866, 0, f, r.width, r.height, r.depth, 0, d, m, r.data);
            else if (i.isData3DTexture)
                v ? (x && n.texStorage3D(32879, T, f, r.width, r.height, r.depth),
                n.texSubImage3D(32879, 0, 0, 0, 0, r.width, r.height, r.depth, d, m, r.data)) : n.texImage3D(32879, 0, f, r.width, r.height, r.depth, 0, d, m, r.data);
            else if (i.isFramebufferTexture) {
                if (x)
                    if (v)
                        n.texStorage2D(3553, T, f, r.width, r.height);
                    else {
                        let e = r.width
                          , t = r.height;
                        for (let i = 0; i < T; i++)
                            n.texImage2D(3553, i, f, e, t, 0, d, m, null),
                            e >>= 1,
                            t >>= 1
                    }
            } else if (g.length > 0 && u) {
                v && x && n.texStorage2D(3553, T, f, g[0].width, g[0].height);
                for (let e = 0, t = g.length; e < t; e++)
                    p = g[e],
                    v ? n.texSubImage2D(3553, e, 0, 0, d, m, p) : n.texImage2D(3553, e, f, d, m, p);
                i.generateMipmaps = !1
            } else
                v ? (x && n.texStorage2D(3553, T, f, r.width, r.height),
                n.texSubImage2D(3553, 0, 0, 0, d, m, r)) : n.texImage2D(3553, 0, f, d, m, r);
            b(i, u) && M(a),
            c.__currentVersion = c.version,
            i.onUpdate && i.onUpdate(i)
        }
        t.__version = i.version
    }
    function z(t, r, a, o, l) {
        const c = s.convert(a.format, a.encoding)
          , h = s.convert(a.type)
          , u = w(a.internalFormat, c, h, a.encoding);
        i.get(r).__hasExternalTextures || (32879 === l || 35866 === l ? n.texImage3D(l, 0, u, r.width, r.height, r.depth, 0, c, h, null) : n.texImage2D(l, 0, u, r.width, r.height, 0, c, h, null)),
        n.bindFramebuffer(36160, t),
        k(r) ? d.framebufferTexture2DMultisampleEXT(36160, o, l, i.get(a).__webglTexture, 0, B(r)) : e.framebufferTexture2D(36160, o, l, i.get(a).__webglTexture, 0),
        n.bindFramebuffer(36160, null)
    }
    function U(t, n, i) {
        if (e.bindRenderbuffer(36161, t),
        n.depthBuffer && !n.stencilBuffer) {
            let r = 33189;
            if (i || k(n)) {
                const t = n.depthTexture;
                t && t.isDepthTexture && (t.type === Le ? r = 36012 : t.type === Ce && (r = 33190));
                const i = B(n);
                k(n) ? d.renderbufferStorageMultisampleEXT(36161, i, r, n.width, n.height) : e.renderbufferStorageMultisample(36161, i, r, n.width, n.height)
            } else
                e.renderbufferStorage(36161, r, n.width, n.height);
            e.framebufferRenderbuffer(36160, 36096, 36161, t)
        } else if (n.depthBuffer && n.stencilBuffer) {
            const r = B(n);
            i && !1 === k(n) ? e.renderbufferStorageMultisample(36161, r, 35056, n.width, n.height) : k(n) ? d.renderbufferStorageMultisampleEXT(36161, r, 35056, n.width, n.height) : e.renderbufferStorage(36161, 34041, n.width, n.height),
            e.framebufferRenderbuffer(36160, 33306, 36161, t)
        } else {
            const t = !0 === n.isWebGLMultipleRenderTargets ? n.texture : [n.texture];
            for (let r = 0; r < t.length; r++) {
                const a = t[r]
                  , o = s.convert(a.format, a.encoding)
                  , l = s.convert(a.type)
                  , c = w(a.internalFormat, o, l, a.encoding)
                  , h = B(n);
                i && !1 === k(n) ? e.renderbufferStorageMultisample(36161, h, c, n.width, n.height) : k(n) ? d.renderbufferStorageMultisampleEXT(36161, h, c, n.width, n.height) : e.renderbufferStorage(36161, c, n.width, n.height)
            }
        }
        e.bindRenderbuffer(36161, null)
    }
    function F(t) {
        const r = i.get(t)
          , s = !0 === t.isWebGLCubeRenderTarget;
        if (t.depthTexture && !r.__autoAllocateDepthBuffer) {
            if (s)
                throw new Error("target.depthTexture not supported in Cube render targets");
            !function(t, r) {
                if (r && r.isWebGLCubeRenderTarget)
                    throw new Error("Depth Texture with cube render targets is not supported");
                if (n.bindFramebuffer(36160, t),
                !r.depthTexture || !r.depthTexture.isDepthTexture)
                    throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                i.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width,
                r.depthTexture.image.height = r.height,
                r.depthTexture.needsUpdate = !0),
                R(r.depthTexture, 0);
                const s = i.get(r.depthTexture).__webglTexture
                  , a = B(r);
                if (r.depthTexture.format === De)
                    k(r) ? d.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, s, 0, a) : e.framebufferTexture2D(36160, 36096, 3553, s, 0);
                else {
                    if (r.depthTexture.format !== Oe)
                        throw new Error("Unknown depthTexture format");
                    k(r) ? d.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, s, 0, a) : e.framebufferTexture2D(36160, 33306, 3553, s, 0)
                }
            }(r.__webglFramebuffer, t)
        } else if (s) {
            r.__webglDepthbuffer = [];
            for (let i = 0; i < 6; i++)
                n.bindFramebuffer(36160, r.__webglFramebuffer[i]),
                r.__webglDepthbuffer[i] = e.createRenderbuffer(),
                U(r.__webglDepthbuffer[i], t, !1)
        } else
            n.bindFramebuffer(36160, r.__webglFramebuffer),
            r.__webglDepthbuffer = e.createRenderbuffer(),
            U(r.__webglDepthbuffer, t, !1);
        n.bindFramebuffer(36160, null)
    }
    function B(e) {
        return Math.min(u, e.samples)
    }
    function k(e) {
        const n = i.get(e);
        return o && e.samples > 0 && !0 === t.has("WEBGL_multisampled_render_to_texture") && !1 !== n.__useRenderToTexture
    }
    function G(e, n) {
        const i = e.encoding
          , r = e.format
          , s = e.type;
        return !0 === e.isCompressedTexture || !0 === e.isVideoTexture || e.format === Mt || i !== ft && (i === gt ? !1 === o ? !0 === t.has("EXT_sRGB") && r === Ie ? (e.format = Mt,
        e.minFilter = we,
        e.generateMipmaps = !1) : n = nn.sRGBToLinear(n) : r === Ie && s === Ae || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", i)),
        n
    }
    this.allocateTextureUnit = function() {
        const e = L;
        return e >= l && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + l),
        L += 1,
        e
    }
    ,
    this.resetTextureUnits = function() {
        L = 0
    }
    ,
    this.setTexture2D = R,
    this.setTexture2DArray = function(e, t) {
        const r = i.get(e);
        e.version > 0 && r.__version !== e.version ? N(r, e, t) : (n.activeTexture(33984 + t),
        n.bindTexture(35866, r.__webglTexture))
    }
    ,
    this.setTexture3D = function(e, t) {
        const r = i.get(e);
        e.version > 0 && r.__version !== e.version ? N(r, e, t) : (n.activeTexture(33984 + t),
        n.bindTexture(32879, r.__webglTexture))
    }
    ,
    this.setTextureCube = function(t, r) {
        const a = i.get(t);
        t.version > 0 && a.__version !== t.version ? function(t, i, r) {
            if (6 !== i.image.length)
                return;
            const a = O(t, i)
              , l = i.source;
            if (n.activeTexture(33984 + r),
            n.bindTexture(34067, t.__webglTexture),
            l.version !== l.__currentVersion || !0 === a) {
                e.pixelStorei(37440, i.flipY),
                e.pixelStorei(37441, i.premultiplyAlpha),
                e.pixelStorei(3317, i.unpackAlignment),
                e.pixelStorei(37443, 0);
                const t = i.isCompressedTexture || i.image[0].isCompressedTexture
                  , r = i.image[0] && i.image[0].isDataTexture
                  , h = [];
                for (let e = 0; e < 6; e++)
                    h[e] = t || r ? r ? i.image[e].image : i.image[e] : y(i.image[e], !1, !0, c),
                    h[e] = G(i, h[e]);
                const u = h[0]
                  , d = _(u) || o
                  , p = s.convert(i.format, i.encoding)
                  , m = s.convert(i.type)
                  , f = w(i.internalFormat, p, m, i.encoding)
                  , g = o && !0 !== i.isVideoTexture
                  , v = void 0 === l.__currentVersion || !0 === a;
                let x, T = S(i, u, d);
                if (D(34067, i, d),
                t) {
                    g && v && n.texStorage2D(34067, T, f, u.width, u.height);
                    for (let e = 0; e < 6; e++) {
                        x = h[e].mipmaps;
                        for (let t = 0; t < x.length; t++) {
                            const r = x[t];
                            i.format !== Ie ? null !== p ? g ? n.compressedTexSubImage2D(34069 + e, t, 0, 0, r.width, r.height, p, r.data) : n.compressedTexImage2D(34069 + e, t, f, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : g ? n.texSubImage2D(34069 + e, t, 0, 0, r.width, r.height, p, m, r.data) : n.texImage2D(34069 + e, t, f, r.width, r.height, 0, p, m, r.data)
                        }
                    }
                } else {
                    x = i.mipmaps,
                    g && v && (x.length > 0 && T++,
                    n.texStorage2D(34067, T, f, h[0].width, h[0].height));
                    for (let e = 0; e < 6; e++)
                        if (r) {
                            g ? n.texSubImage2D(34069 + e, 0, 0, 0, h[e].width, h[e].height, p, m, h[e].data) : n.texImage2D(34069 + e, 0, f, h[e].width, h[e].height, 0, p, m, h[e].data);
                            for (let t = 0; t < x.length; t++) {
                                const i = x[t].image[e].image;
                                g ? n.texSubImage2D(34069 + e, t + 1, 0, 0, i.width, i.height, p, m, i.data) : n.texImage2D(34069 + e, t + 1, f, i.width, i.height, 0, p, m, i.data)
                            }
                        } else {
                            g ? n.texSubImage2D(34069 + e, 0, 0, 0, p, m, h[e]) : n.texImage2D(34069 + e, 0, f, p, m, h[e]);
                            for (let t = 0; t < x.length; t++) {
                                const i = x[t];
                                g ? n.texSubImage2D(34069 + e, t + 1, 0, 0, p, m, i.image[e]) : n.texImage2D(34069 + e, t + 1, f, p, m, i.image[e])
                            }
                        }
                }
                b(i, d) && M(34067),
                l.__currentVersion = l.version,
                i.onUpdate && i.onUpdate(i)
            }
            t.__version = i.version
        }(a, t, r) : (n.activeTexture(33984 + r),
        n.bindTexture(34067, a.__webglTexture))
    }
    ,
    this.rebindTextures = function(e, t, n) {
        const r = i.get(e);
        void 0 !== t && z(r.__webglFramebuffer, e, e.texture, 36064, 3553),
        void 0 !== n && F(e)
    }
    ,
    this.setupRenderTarget = function(t) {
        const l = t.texture
          , c = i.get(t)
          , h = i.get(l);
        t.addEventListener("dispose", E),
        !0 !== t.isWebGLMultipleRenderTargets && (void 0 === h.__webglTexture && (h.__webglTexture = e.createTexture()),
        h.__version = l.version,
        a.memory.textures++);
        const u = !0 === t.isWebGLCubeRenderTarget
          , d = !0 === t.isWebGLMultipleRenderTargets
          , p = _(t) || o;
        if (u) {
            c.__webglFramebuffer = [];
            for (let t = 0; t < 6; t++)
                c.__webglFramebuffer[t] = e.createFramebuffer()
        } else {
            if (c.__webglFramebuffer = e.createFramebuffer(),
            d)
                if (r.drawBuffers) {
                    const n = t.texture;
                    for (let t = 0, r = n.length; t < r; t++) {
                        const r = i.get(n[t]);
                        void 0 === r.__webglTexture && (r.__webglTexture = e.createTexture(),
                        a.memory.textures++)
                    }
                } else
                    console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
            if (o && t.samples > 0 && !1 === k(t)) {
                const i = d ? l : [l];
                c.__webglMultisampledFramebuffer = e.createFramebuffer(),
                c.__webglColorRenderbuffer = [],
                n.bindFramebuffer(36160, c.__webglMultisampledFramebuffer);
                for (let n = 0; n < i.length; n++) {
                    const r = i[n];
                    c.__webglColorRenderbuffer[n] = e.createRenderbuffer(),
                    e.bindRenderbuffer(36161, c.__webglColorRenderbuffer[n]);
                    const a = s.convert(r.format, r.encoding)
                      , o = s.convert(r.type)
                      , l = w(r.internalFormat, a, o, r.encoding)
                      , h = B(t);
                    e.renderbufferStorageMultisample(36161, h, l, t.width, t.height),
                    e.framebufferRenderbuffer(36160, 36064 + n, 36161, c.__webglColorRenderbuffer[n])
                }
                e.bindRenderbuffer(36161, null),
                t.depthBuffer && (c.__webglDepthRenderbuffer = e.createRenderbuffer(),
                U(c.__webglDepthRenderbuffer, t, !0)),
                n.bindFramebuffer(36160, null)
            }
        }
        if (u) {
            n.bindTexture(34067, h.__webglTexture),
            D(34067, l, p);
            for (let e = 0; e < 6; e++)
                z(c.__webglFramebuffer[e], t, l, 36064, 34069 + e);
            b(l, p) && M(34067),
            n.unbindTexture()
        } else if (d) {
            const e = t.texture;
            for (let r = 0, s = e.length; r < s; r++) {
                const s = e[r]
                  , a = i.get(s);
                n.bindTexture(3553, a.__webglTexture),
                D(3553, s, p),
                z(c.__webglFramebuffer, t, s, 36064 + r, 3553),
                b(s, p) && M(3553)
            }
            n.unbindTexture()
        } else {
            let e = 3553;
            (t.isWebGL3DRenderTarget || t.isWebGLArrayRenderTarget) && (o ? e = t.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),
            n.bindTexture(e, h.__webglTexture),
            D(e, l, p),
            z(c.__webglFramebuffer, t, l, 36064, e),
            b(l, p) && M(e),
            n.unbindTexture()
        }
        t.depthBuffer && F(t)
    }
    ,
    this.updateRenderTargetMipmap = function(e) {
        const t = _(e) || o
          , r = !0 === e.isWebGLMultipleRenderTargets ? e.texture : [e.texture];
        for (let s = 0, a = r.length; s < a; s++) {
            const a = r[s];
            if (b(a, t)) {
                const t = e.isWebGLCubeRenderTarget ? 34067 : 3553
                  , r = i.get(a).__webglTexture;
                n.bindTexture(t, r),
                M(t),
                n.unbindTexture()
            }
        }
    }
    ,
    this.updateMultisampleRenderTarget = function(t) {
        if (o && t.samples > 0 && !1 === k(t)) {
            const r = t.isWebGLMultipleRenderTargets ? t.texture : [t.texture]
              , s = t.width
              , a = t.height;
            let o = 16384;
            const l = []
              , c = t.stencilBuffer ? 33306 : 36096
              , h = i.get(t)
              , u = !0 === t.isWebGLMultipleRenderTargets;
            if (u)
                for (let t = 0; t < r.length; t++)
                    n.bindFramebuffer(36160, h.__webglMultisampledFramebuffer),
                    e.framebufferRenderbuffer(36160, 36064 + t, 36161, null),
                    n.bindFramebuffer(36160, h.__webglFramebuffer),
                    e.framebufferTexture2D(36009, 36064 + t, 3553, null, 0);
            n.bindFramebuffer(36008, h.__webglMultisampledFramebuffer),
            n.bindFramebuffer(36009, h.__webglFramebuffer);
            for (let n = 0; n < r.length; n++) {
                l.push(36064 + n),
                t.depthBuffer && l.push(c);
                const d = void 0 !== h.__ignoreDepthValues && h.__ignoreDepthValues;
                if (!1 === d && (t.depthBuffer && (o |= 256),
                t.stencilBuffer && (o |= 1024)),
                u && e.framebufferRenderbuffer(36008, 36064, 36161, h.__webglColorRenderbuffer[n]),
                !0 === d && (e.invalidateFramebuffer(36008, [c]),
                e.invalidateFramebuffer(36009, [c])),
                u) {
                    const t = i.get(r[n]).__webglTexture;
                    e.framebufferTexture2D(36009, 36064, 3553, t, 0)
                }
                e.blitFramebuffer(0, 0, s, a, 0, 0, s, a, o, 9728),
                p && e.invalidateFramebuffer(36008, l)
            }
            if (n.bindFramebuffer(36008, null),
            n.bindFramebuffer(36009, null),
            u)
                for (let t = 0; t < r.length; t++) {
                    n.bindFramebuffer(36160, h.__webglMultisampledFramebuffer),
                    e.framebufferRenderbuffer(36160, 36064 + t, 36161, h.__webglColorRenderbuffer[t]);
                    const s = i.get(r[t]).__webglTexture;
                    n.bindFramebuffer(36160, h.__webglFramebuffer),
                    e.framebufferTexture2D(36009, 36064 + t, 3553, s, 0)
                }
            n.bindFramebuffer(36009, h.__webglMultisampledFramebuffer)
        }
    }
    ,
    this.setupDepthRenderbuffer = F,
    this.setupFrameBufferTexture = z,
    this.useMultisampledRTT = k
}
function Za(e, t, n) {
    const i = n.isWebGL2;
    return {
        convert: function(n, r=null) {
            let s;
            if (n === Ae)
                return 5121;
            if (1017 === n)
                return 32819;
            if (1018 === n)
                return 32820;
            if (1010 === n)
                return 5120;
            if (1011 === n)
                return 5122;
            if (n === Ee)
                return 5123;
            if (1013 === n)
                return 5124;
            if (n === Ce)
                return 5125;
            if (n === Le)
                return 5126;
            if (n === Re)
                return i ? 5131 : (s = t.get("OES_texture_half_float"),
                null !== s ? s.HALF_FLOAT_OES : null);
            if (1021 === n)
                return 6406;
            if (n === Ie)
                return 6408;
            if (1024 === n)
                return 6409;
            if (1025 === n)
                return 6410;
            if (n === De)
                return 6402;
            if (n === Oe)
                return 34041;
            if (1028 === n)
                return 6403;
            if (1022 === n)
                return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"),
                6408;
            if (n === Mt)
                return s = t.get("EXT_sRGB"),
                null !== s ? s.SRGB_ALPHA_EXT : null;
            if (1029 === n)
                return 36244;
            if (1030 === n)
                return 33319;
            if (1031 === n)
                return 33320;
            if (1033 === n)
                return 36249;
            if (n === Ne || n === ze || n === Ue || n === Fe)
                if (r === gt) {
                    if (s = t.get("WEBGL_compressed_texture_s3tc_srgb"),
                    null === s)
                        return null;
                    if (n === Ne)
                        return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    if (n === ze)
                        return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    if (n === Ue)
                        return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    if (n === Fe)
                        return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                } else {
                    if (s = t.get("WEBGL_compressed_texture_s3tc"),
                    null === s)
                        return null;
                    if (n === Ne)
                        return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (n === ze)
                        return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (n === Ue)
                        return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (n === Fe)
                        return s.COMPRESSED_RGBA_S3TC_DXT5_EXT
                }
            if (n === Be || n === ke || n === Ge || n === He) {
                if (s = t.get("WEBGL_compressed_texture_pvrtc"),
                null === s)
                    return null;
                if (n === Be)
                    return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (n === ke)
                    return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (n === Ge)
                    return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (n === He)
                    return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            }
            if (36196 === n)
                return s = t.get("WEBGL_compressed_texture_etc1"),
                null !== s ? s.COMPRESSED_RGB_ETC1_WEBGL : null;
            if (n === Ve || n === We) {
                if (s = t.get("WEBGL_compressed_texture_etc"),
                null === s)
                    return null;
                if (n === Ve)
                    return r === gt ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
                if (n === We)
                    return r === gt ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : s.COMPRESSED_RGBA8_ETC2_EAC
            }
            if (n === je || n === Xe || n === qe || n === Ye || n === Ze || n === Je || n === Ke || n === Qe || n === $e || n === et || n === tt || n === nt || n === it || n === rt) {
                if (s = t.get("WEBGL_compressed_texture_astc"),
                null === s)
                    return null;
                if (n === je)
                    return r === gt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (n === Xe)
                    return r === gt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (n === qe)
                    return r === gt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (n === Ye)
                    return r === gt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (n === Ze)
                    return r === gt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (n === Je)
                    return r === gt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (n === Ke)
                    return r === gt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (n === Qe)
                    return r === gt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (n === $e)
                    return r === gt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (n === et)
                    return r === gt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (n === tt)
                    return r === gt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (n === nt)
                    return r === gt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (n === it)
                    return r === gt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (n === rt)
                    return r === gt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : s.COMPRESSED_RGBA_ASTC_12x12_KHR
            }
            if (n === st) {
                if (s = t.get("EXT_texture_compression_bptc"),
                null === s)
                    return null;
                if (n === st)
                    return r === gt ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : s.COMPRESSED_RGBA_BPTC_UNORM_EXT
            }
            return n === Pe ? i ? 34042 : (s = t.get("WEBGL_depth_texture"),
            null !== s ? s.UNSIGNED_INT_24_8_WEBGL : null) : void 0 !== e[n] ? e[n] : null
        }
    }
}
class Ja extends fr {
    constructor(e=[]) {
        super(),
        this.isArrayCamera = !0,
        this.cameras = e
    }
}
class Ka extends fi {
    constructor() {
        super(),
        this.isGroup = !0,
        this.type = "Group"
    }
}
const Qa = {
    type: "move"
};
class $a {
    constructor() {
        this._targetRay = null,
        this._grip = null,
        this._hand = null
    }
    getHandSpace() {
        return null === this._hand && (this._hand = new Ka,
        this._hand.matrixAutoUpdate = !1,
        this._hand.visible = !1,
        this._hand.joints = {},
        this._hand.inputState = {
            pinching: !1
        }),
        this._hand
    }
    getTargetRaySpace() {
        return null === this._targetRay && (this._targetRay = new Ka,
        this._targetRay.matrixAutoUpdate = !1,
        this._targetRay.visible = !1,
        this._targetRay.hasLinearVelocity = !1,
        this._targetRay.linearVelocity = new pn,
        this._targetRay.hasAngularVelocity = !1,
        this._targetRay.angularVelocity = new pn),
        this._targetRay
    }
    getGripSpace() {
        return null === this._grip && (this._grip = new Ka,
        this._grip.matrixAutoUpdate = !1,
        this._grip.visible = !1,
        this._grip.hasLinearVelocity = !1,
        this._grip.linearVelocity = new pn,
        this._grip.hasAngularVelocity = !1,
        this._grip.angularVelocity = new pn),
        this._grip
    }
    dispatchEvent(e) {
        return null !== this._targetRay && this._targetRay.dispatchEvent(e),
        null !== this._grip && this._grip.dispatchEvent(e),
        null !== this._hand && this._hand.dispatchEvent(e),
        this
    }
    disconnect(e) {
        return this.dispatchEvent({
            type: "disconnected",
            data: e
        }),
        null !== this._targetRay && (this._targetRay.visible = !1),
        null !== this._grip && (this._grip.visible = !1),
        null !== this._hand && (this._hand.visible = !1),
        this
    }
    update(e, t, n) {
        let i = null
          , r = null
          , s = null;
        const a = this._targetRay
          , o = this._grip
          , l = this._hand;
        if (e && "visible-blurred" !== t.session.visibilityState) {
            if (l && e.hand) {
                s = !0;
                for (const i of e.hand.values()) {
                    const e = t.getJointPose(i, n);
                    if (void 0 === l.joints[i.jointName]) {
                        const e = new Ka;
                        e.matrixAutoUpdate = !1,
                        e.visible = !1,
                        l.joints[i.jointName] = e,
                        l.add(e)
                    }
                    const r = l.joints[i.jointName];
                    null !== e && (r.matrix.fromArray(e.transform.matrix),
                    r.matrix.decompose(r.position, r.rotation, r.scale),
                    r.jointRadius = e.radius),
                    r.visible = null !== e
                }
                const i = l.joints["index-finger-tip"]
                  , r = l.joints["thumb-tip"]
                  , a = i.position.distanceTo(r.position)
                  , o = .02
                  , c = .005;
                l.inputState.pinching && a > o + c ? (l.inputState.pinching = !1,
                this.dispatchEvent({
                    type: "pinchend",
                    handedness: e.handedness,
                    target: this
                })) : !l.inputState.pinching && a <= o - c && (l.inputState.pinching = !0,
                this.dispatchEvent({
                    type: "pinchstart",
                    handedness: e.handedness,
                    target: this
                }))
            } else
                null !== o && e.gripSpace && (r = t.getPose(e.gripSpace, n),
                null !== r && (o.matrix.fromArray(r.transform.matrix),
                o.matrix.decompose(o.position, o.rotation, o.scale),
                r.linearVelocity ? (o.hasLinearVelocity = !0,
                o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1,
                r.angularVelocity ? (o.hasAngularVelocity = !0,
                o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1));
            null !== a && (i = t.getPose(e.targetRaySpace, n),
            null === i && null !== r && (i = r),
            null !== i && (a.matrix.fromArray(i.transform.matrix),
            a.matrix.decompose(a.position, a.rotation, a.scale),
            i.linearVelocity ? (a.hasLinearVelocity = !0,
            a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = !1,
            i.angularVelocity ? (a.hasAngularVelocity = !0,
            a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = !1,
            this.dispatchEvent(Qa)))
        }
        return null !== a && (a.visible = null !== i),
        null !== o && (o.visible = null !== r),
        null !== l && (l.visible = null !== s),
        this
    }
}
class eo extends on {
    constructor(e, t, n, i, r, s, a, o, l, c) {
        if ((c = void 0 !== c ? c : De) !== De && c !== Oe)
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        void 0 === n && c === De && (n = Ce),
        void 0 === n && c === Oe && (n = Pe),
        super(null, i, r, s, a, o, c, n, l),
        this.isDepthTexture = !0,
        this.image = {
            width: e,
            height: t
        },
        this.magFilter = void 0 !== a ? a : _e,
        this.minFilter = void 0 !== o ? o : _e,
        this.flipY = !1,
        this.generateMipmaps = !1
    }
}
class to extends wt {
    constructor(e, t) {
        super();
        const n = this;
        let i = null
          , r = 1
          , s = null
          , a = "local-floor"
          , o = null
          , l = null
          , c = null
          , h = null
          , u = null
          , d = null;
        const p = t.getContextAttributes();
        let m = null
          , f = null;
        const g = []
          , v = []
          , x = new fr;
        x.layers.enable(1),
        x.viewport = new ln;
        const y = new fr;
        y.layers.enable(2),
        y.viewport = new ln;
        const _ = [x, y]
          , b = new Ja;
        b.layers.enable(1),
        b.layers.enable(2);
        let M = null
          , w = null;
        function S(e) {
            const t = v.indexOf(e.inputSource);
            if (-1 === t)
                return;
            const n = g[t];
            void 0 !== n && n.dispatchEvent({
                type: e.type,
                data: e.inputSource
            })
        }
        function T() {
            i.removeEventListener("select", S),
            i.removeEventListener("selectstart", S),
            i.removeEventListener("selectend", S),
            i.removeEventListener("squeeze", S),
            i.removeEventListener("squeezestart", S),
            i.removeEventListener("squeezeend", S),
            i.removeEventListener("end", T),
            i.removeEventListener("inputsourceschange", A);
            for (let e = 0; e < g.length; e++) {
                const t = v[e];
                null !== t && (v[e] = null,
                g[e].disconnect(t))
            }
            M = null,
            w = null,
            e.setRenderTarget(m),
            u = null,
            h = null,
            c = null,
            i = null,
            f = null,
            P.stop(),
            n.isPresenting = !1,
            n.dispatchEvent({
                type: "sessionend"
            })
        }
        function A(e) {
            for (let t = 0; t < e.removed.length; t++) {
                const n = e.removed[t]
                  , i = v.indexOf(n);
                i >= 0 && (v[i] = null,
                g[i].dispatchEvent({
                    type: "disconnected",
                    data: n
                }))
            }
            for (let t = 0; t < e.added.length; t++) {
                const n = e.added[t];
                let i = v.indexOf(n);
                if (-1 === i) {
                    for (let e = 0; e < g.length; e++) {
                        if (e >= v.length) {
                            v.push(n),
                            i = e;
                            break
                        }
                        if (null === v[e]) {
                            v[e] = n,
                            i = e;
                            break
                        }
                    }
                    if (-1 === i)
                        break
                }
                const r = g[i];
                r && r.dispatchEvent({
                    type: "connected",
                    data: n
                })
            }
        }
        this.cameraAutoUpdate = !0,
        this.enabled = !1,
        this.isPresenting = !1,
        this.getController = function(e) {
            let t = g[e];
            return void 0 === t && (t = new $a,
            g[e] = t),
            t.getTargetRaySpace()
        }
        ,
        this.getControllerGrip = function(e) {
            let t = g[e];
            return void 0 === t && (t = new $a,
            g[e] = t),
            t.getGripSpace()
        }
        ,
        this.getHand = function(e) {
            let t = g[e];
            return void 0 === t && (t = new $a,
            g[e] = t),
            t.getHandSpace()
        }
        ,
        this.setFramebufferScaleFactor = function(e) {
            r = e,
            !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
        }
        ,
        this.setReferenceSpaceType = function(e) {
            a = e,
            !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
        }
        ,
        this.getReferenceSpace = function() {
            return o || s
        }
        ,
        this.setReferenceSpace = function(e) {
            o = e
        }
        ,
        this.getBaseLayer = function() {
            return null !== h ? h : u
        }
        ,
        this.getBinding = function() {
            return c
        }
        ,
        this.getFrame = function() {
            return d
        }
        ,
        this.getSession = function() {
            return i
        }
        ,
        this.setSession = async function(l) {
            if (i = l,
            null !== i) {
                if (m = e.getRenderTarget(),
                i.addEventListener("select", S),
                i.addEventListener("selectstart", S),
                i.addEventListener("selectend", S),
                i.addEventListener("squeeze", S),
                i.addEventListener("squeezestart", S),
                i.addEventListener("squeezeend", S),
                i.addEventListener("end", T),
                i.addEventListener("inputsourceschange", A),
                !0 !== p.xrCompatible && await t.makeXRCompatible(),
                void 0 === i.renderState.layers || !1 === e.capabilities.isWebGL2) {
                    const n = {
                        antialias: void 0 !== i.renderState.layers || p.antialias,
                        alpha: p.alpha,
                        depth: p.depth,
                        stencil: p.stencil,
                        framebufferScaleFactor: r
                    };
                    u = new XRWebGLLayer(i,t,n),
                    i.updateRenderState({
                        baseLayer: u
                    }),
                    f = new cn(u.framebufferWidth,u.framebufferHeight,{
                        format: Ie,
                        type: Ae,
                        encoding: e.outputEncoding,
                        stencilBuffer: p.stencil
                    })
                } else {
                    let n = null
                      , s = null
                      , a = null;
                    p.depth && (a = p.stencil ? 35056 : 33190,
                    n = p.stencil ? Oe : De,
                    s = p.stencil ? Pe : Ce);
                    const o = {
                        colorFormat: 32856,
                        depthFormat: a,
                        scaleFactor: r
                    };
                    c = new XRWebGLBinding(i,t),
                    h = c.createProjectionLayer(o),
                    i.updateRenderState({
                        layers: [h]
                    }),
                    f = new cn(h.textureWidth,h.textureHeight,{
                        format: Ie,
                        type: Ae,
                        depthTexture: new eo(h.textureWidth,h.textureHeight,s,void 0,void 0,void 0,void 0,void 0,void 0,n),
                        stencilBuffer: p.stencil,
                        encoding: e.outputEncoding,
                        samples: p.antialias ? 4 : 0
                    });
                    e.properties.get(f).__ignoreDepthValues = h.ignoreDepthValues
                }
                f.isXRRenderTarget = !0,
                this.setFoveation(1),
                o = null,
                s = await i.requestReferenceSpace(a),
                P.setContext(i),
                P.start(),
                n.isPresenting = !0,
                n.dispatchEvent({
                    type: "sessionstart"
                })
            }
        }
        ;
        const E = new pn
          , C = new pn;
        function L(e, t) {
            null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix),
            e.matrixWorldInverse.copy(e.matrixWorld).invert()
        }
        this.updateCamera = function(e) {
            if (null === i)
                return;
            b.near = y.near = x.near = e.near,
            b.far = y.far = x.far = e.far,
            M === b.near && w === b.far || (i.updateRenderState({
                depthNear: b.near,
                depthFar: b.far
            }),
            M = b.near,
            w = b.far);
            const t = e.parent
              , n = b.cameras;
            L(b, t);
            for (let e = 0; e < n.length; e++)
                L(n[e], t);
            b.matrixWorld.decompose(b.position, b.quaternion, b.scale),
            e.matrix.copy(b.matrix),
            e.matrix.decompose(e.position, e.quaternion, e.scale);
            const r = e.children;
            for (let e = 0, t = r.length; e < t; e++)
                r[e].updateMatrixWorld(!0);
            2 === n.length ? function(e, t, n) {
                E.setFromMatrixPosition(t.matrixWorld),
                C.setFromMatrixPosition(n.matrixWorld);
                const i = E.distanceTo(C)
                  , r = t.projectionMatrix.elements
                  , s = n.projectionMatrix.elements
                  , a = r[14] / (r[10] - 1)
                  , o = r[14] / (r[10] + 1)
                  , l = (r[9] + 1) / r[5]
                  , c = (r[9] - 1) / r[5]
                  , h = (r[8] - 1) / r[0]
                  , u = (s[8] + 1) / s[0]
                  , d = a * h
                  , p = a * u
                  , m = i / (-h + u)
                  , f = m * -h;
                t.matrixWorld.decompose(e.position, e.quaternion, e.scale),
                e.translateX(f),
                e.translateZ(m),
                e.matrixWorld.compose(e.position, e.quaternion, e.scale),
                e.matrixWorldInverse.copy(e.matrixWorld).invert();
                const g = a + m
                  , v = o + m
                  , x = d - f
                  , y = p + (i - f)
                  , _ = l * o / v * g
                  , b = c * o / v * g;
                e.projectionMatrix.makePerspective(x, y, _, b, g, v)
            }(b, x, y) : b.projectionMatrix.copy(x.projectionMatrix)
        }
        ,
        this.getCamera = function() {
            return b
        }
        ,
        this.getFoveation = function() {
            return null !== h ? h.fixedFoveation : null !== u ? u.fixedFoveation : void 0
        }
        ,
        this.setFoveation = function(e) {
            null !== h && (h.fixedFoveation = e),
            null !== u && void 0 !== u.fixedFoveation && (u.fixedFoveation = e)
        }
        ;
        let R = null;
        const P = new Er;
        P.setAnimationLoop((function(t, n) {
            if (l = n.getViewerPose(o || s),
            d = n,
            null !== l) {
                const t = l.views;
                null !== u && (e.setRenderTargetFramebuffer(f, u.framebuffer),
                e.setRenderTarget(f));
                let n = !1;
                t.length !== b.cameras.length && (b.cameras.length = 0,
                n = !0);
                for (let i = 0; i < t.length; i++) {
                    const r = t[i];
                    let s = null;
                    if (null !== u)
                        s = u.getViewport(r);
                    else {
                        const t = c.getViewSubImage(h, r);
                        s = t.viewport,
                        0 === i && (e.setRenderTargetTextures(f, t.colorTexture, h.ignoreDepthValues ? void 0 : t.depthStencilTexture),
                        e.setRenderTarget(f))
                    }
                    let a = _[i];
                    void 0 === a && (a = new fr,
                    a.layers.enable(i),
                    a.viewport = new ln,
                    _[i] = a),
                    a.matrix.fromArray(r.transform.matrix),
                    a.projectionMatrix.fromArray(r.projectionMatrix),
                    a.viewport.set(s.x, s.y, s.width, s.height),
                    0 === i && b.matrix.copy(a.matrix),
                    !0 === n && b.cameras.push(a)
                }
            }
            for (let e = 0; e < g.length; e++) {
                const t = v[e]
                  , i = g[e];
                null !== t && void 0 !== i && i.update(t, n, o || s)
            }
            R && R(t, n),
            d = null
        }
        )),
        this.setAnimationLoop = function(e) {
            R = e
        }
        ,
        this.dispose = function() {}
    }
}
function no(e, t) {
    function n(n, i) {
        n.opacity.value = i.opacity,
        i.color && n.diffuse.value.copy(i.color),
        i.emissive && n.emissive.value.copy(i.emissive).multiplyScalar(i.emissiveIntensity),
        i.map && (n.map.value = i.map),
        i.alphaMap && (n.alphaMap.value = i.alphaMap),
        i.bumpMap && (n.bumpMap.value = i.bumpMap,
        n.bumpScale.value = i.bumpScale,
        1 === i.side && (n.bumpScale.value *= -1)),
        i.displacementMap && (n.displacementMap.value = i.displacementMap,
        n.displacementScale.value = i.displacementScale,
        n.displacementBias.value = i.displacementBias),
        i.emissiveMap && (n.emissiveMap.value = i.emissiveMap),
        i.normalMap && (n.normalMap.value = i.normalMap,
        n.normalScale.value.copy(i.normalScale),
        1 === i.side && n.normalScale.value.negate()),
        i.specularMap && (n.specularMap.value = i.specularMap),
        i.alphaTest > 0 && (n.alphaTest.value = i.alphaTest);
        const r = t.get(i).envMap;
        if (r && (n.envMap.value = r,
        n.flipEnvMap.value = r.isCubeTexture && !1 === r.isRenderTargetTexture ? -1 : 1,
        n.reflectivity.value = i.reflectivity,
        n.ior.value = i.ior,
        n.refractionRatio.value = i.refractionRatio),
        i.lightMap) {
            n.lightMap.value = i.lightMap;
            const t = !0 !== e.physicallyCorrectLights ? Math.PI : 1;
            n.lightMapIntensity.value = i.lightMapIntensity * t
        }
        let s, a;
        i.aoMap && (n.aoMap.value = i.aoMap,
        n.aoMapIntensity.value = i.aoMapIntensity),
        i.map ? s = i.map : i.specularMap ? s = i.specularMap : i.displacementMap ? s = i.displacementMap : i.normalMap ? s = i.normalMap : i.bumpMap ? s = i.bumpMap : i.roughnessMap ? s = i.roughnessMap : i.metalnessMap ? s = i.metalnessMap : i.alphaMap ? s = i.alphaMap : i.emissiveMap ? s = i.emissiveMap : i.clearcoatMap ? s = i.clearcoatMap : i.clearcoatNormalMap ? s = i.clearcoatNormalMap : i.clearcoatRoughnessMap ? s = i.clearcoatRoughnessMap : i.iridescenceMap ? s = i.iridescenceMap : i.iridescenceThicknessMap ? s = i.iridescenceThicknessMap : i.specularIntensityMap ? s = i.specularIntensityMap : i.specularColorMap ? s = i.specularColorMap : i.transmissionMap ? s = i.transmissionMap : i.thicknessMap ? s = i.thicknessMap : i.sheenColorMap ? s = i.sheenColorMap : i.sheenRoughnessMap && (s = i.sheenRoughnessMap),
        void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture),
        !0 === s.matrixAutoUpdate && s.updateMatrix(),
        n.uvTransform.value.copy(s.matrix)),
        i.aoMap ? a = i.aoMap : i.lightMap && (a = i.lightMap),
        void 0 !== a && (a.isWebGLRenderTarget && (a = a.texture),
        !0 === a.matrixAutoUpdate && a.updateMatrix(),
        n.uv2Transform.value.copy(a.matrix))
    }
    return {
        refreshFogUniforms: function(e, t) {
            e.fogColor.value.copy(t.color),
            t.isFog ? (e.fogNear.value = t.near,
            e.fogFar.value = t.far) : t.isFogExp2 && (e.fogDensity.value = t.density)
        },
        refreshMaterialUniforms: function(e, i, r, s, a) {
            i.isMeshBasicMaterial || i.isMeshLambertMaterial ? n(e, i) : i.isMeshToonMaterial ? (n(e, i),
            function(e, t) {
                t.gradientMap && (e.gradientMap.value = t.gradientMap)
            }(e, i)) : i.isMeshPhongMaterial ? (n(e, i),
            function(e, t) {
                e.specular.value.copy(t.specular),
                e.shininess.value = Math.max(t.shininess, 1e-4)
            }(e, i)) : i.isMeshStandardMaterial ? (n(e, i),
            function(e, n) {
                e.roughness.value = n.roughness,
                e.metalness.value = n.metalness,
                n.roughnessMap && (e.roughnessMap.value = n.roughnessMap);
                n.metalnessMap && (e.metalnessMap.value = n.metalnessMap);
                const i = t.get(n).envMap;
                i && (e.envMapIntensity.value = n.envMapIntensity)
            }(e, i),
            i.isMeshPhysicalMaterial && function(e, t, n) {
                e.ior.value = t.ior,
                t.sheen > 0 && (e.sheenColor.value.copy(t.sheenColor).multiplyScalar(t.sheen),
                e.sheenRoughness.value = t.sheenRoughness,
                t.sheenColorMap && (e.sheenColorMap.value = t.sheenColorMap),
                t.sheenRoughnessMap && (e.sheenRoughnessMap.value = t.sheenRoughnessMap));
                t.clearcoat > 0 && (e.clearcoat.value = t.clearcoat,
                e.clearcoatRoughness.value = t.clearcoatRoughness,
                t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap),
                t.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap),
                t.clearcoatNormalMap && (e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale),
                e.clearcoatNormalMap.value = t.clearcoatNormalMap,
                1 === t.side && e.clearcoatNormalScale.value.negate()));
                t.iridescence > 0 && (e.iridescence.value = t.iridescence,
                e.iridescenceIOR.value = t.iridescenceIOR,
                e.iridescenceThicknessMinimum.value = t.iridescenceThicknessRange[0],
                e.iridescenceThicknessMaximum.value = t.iridescenceThicknessRange[1],
                t.iridescenceMap && (e.iridescenceMap.value = t.iridescenceMap),
                t.iridescenceThicknessMap && (e.iridescenceThicknessMap.value = t.iridescenceThicknessMap));
                t.transmission > 0 && (e.transmission.value = t.transmission,
                e.transmissionSamplerMap.value = n.texture,
                e.transmissionSamplerSize.value.set(n.width, n.height),
                t.transmissionMap && (e.transmissionMap.value = t.transmissionMap),
                e.thickness.value = t.thickness,
                t.thicknessMap && (e.thicknessMap.value = t.thicknessMap),
                e.attenuationDistance.value = t.attenuationDistance,
                e.attenuationColor.value.copy(t.attenuationColor));
                e.specularIntensity.value = t.specularIntensity,
                e.specularColor.value.copy(t.specularColor),
                t.specularIntensityMap && (e.specularIntensityMap.value = t.specularIntensityMap);
                t.specularColorMap && (e.specularColorMap.value = t.specularColorMap)
            }(e, i, a)) : i.isMeshMatcapMaterial ? (n(e, i),
            function(e, t) {
                t.matcap && (e.matcap.value = t.matcap)
            }(e, i)) : i.isMeshDepthMaterial ? n(e, i) : i.isMeshDistanceMaterial ? (n(e, i),
            function(e, t) {
                e.referencePosition.value.copy(t.referencePosition),
                e.nearDistance.value = t.nearDistance,
                e.farDistance.value = t.farDistance
            }(e, i)) : i.isMeshNormalMaterial ? n(e, i) : i.isLineBasicMaterial ? (function(e, t) {
                e.diffuse.value.copy(t.color),
                e.opacity.value = t.opacity
            }(e, i),
            i.isLineDashedMaterial && function(e, t) {
                e.dashSize.value = t.dashSize,
                e.totalSize.value = t.dashSize + t.gapSize,
                e.scale.value = t.scale
            }(e, i)) : i.isPointsMaterial ? function(e, t, n, i) {
                e.diffuse.value.copy(t.color),
                e.opacity.value = t.opacity,
                e.size.value = t.size * n,
                e.scale.value = .5 * i,
                t.map && (e.map.value = t.map);
                t.alphaMap && (e.alphaMap.value = t.alphaMap);
                t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest);
                let r;
                t.map ? r = t.map : t.alphaMap && (r = t.alphaMap);
                void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(),
                e.uvTransform.value.copy(r.matrix))
            }(e, i, r, s) : i.isSpriteMaterial ? function(e, t) {
                e.diffuse.value.copy(t.color),
                e.opacity.value = t.opacity,
                e.rotation.value = t.rotation,
                t.map && (e.map.value = t.map);
                t.alphaMap && (e.alphaMap.value = t.alphaMap);
                t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest);
                let n;
                t.map ? n = t.map : t.alphaMap && (n = t.alphaMap);
                void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(),
                e.uvTransform.value.copy(n.matrix))
            }(e, i) : i.isShadowMaterial ? (e.color.value.copy(i.color),
            e.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = !1)
        }
    }
}
function io(e, t, n, i) {
    let r = {}
      , s = {}
      , a = [];
    const o = n.isWebGL2 ? e.getParameter(35375) : 0;
    function l(e, t, n) {
        const i = e.value;
        if (void 0 === n[t])
            return n[t] = "number" == typeof i ? i : i.clone(),
            !0;
        if ("number" == typeof i) {
            if (n[t] !== i)
                return n[t] = i,
                !0
        } else {
            const e = n[t];
            if (!1 === e.equals(i))
                return e.copy(i),
                !0
        }
        return !1
    }
    function c(e) {
        const t = e.value
          , n = {
            boundary: 0,
            storage: 0
        };
        return "number" == typeof t ? (n.boundary = 4,
        n.storage = 4) : t.isVector2 ? (n.boundary = 8,
        n.storage = 8) : t.isVector3 || t.isColor ? (n.boundary = 16,
        n.storage = 12) : t.isVector4 ? (n.boundary = 16,
        n.storage = 16) : t.isMatrix3 ? (n.boundary = 48,
        n.storage = 48) : t.isMatrix4 ? (n.boundary = 64,
        n.storage = 64) : t.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", t),
        n
    }
    function h(t) {
        const n = t.target;
        n.removeEventListener("dispose", h);
        const i = a.indexOf(n.__bindingPointIndex);
        a.splice(i, 1),
        e.deleteBuffer(r[n.id]),
        delete r[n.id],
        delete s[n.id]
    }
    return {
        bind: function(e, t) {
            const n = t.program;
            i.uniformBlockBinding(e, n)
        },
        update: function(n, u) {
            let d = r[n.id];
            void 0 === d && (!function(e) {
                const t = e.uniforms;
                let n = 0;
                const i = 16;
                let r = 0;
                for (let e = 0, s = t.length; e < s; e++) {
                    const s = t[e]
                      , a = c(s);
                    if (s.__data = new Float32Array(a.storage / Float32Array.BYTES_PER_ELEMENT),
                    s.__offset = n,
                    e > 0) {
                        r = n % i;
                        0 !== r && i - r - a.boundary < 0 && (n += i - r,
                        s.__offset = n)
                    }
                    n += a.storage
                }
                r = n % i,
                r > 0 && (n += i - r);
                e.__size = n,
                e.__cache = {}
            }(n),
            d = function(t) {
                const n = function() {
                    for (let e = 0; e < o; e++)
                        if (-1 === a.indexOf(e))
                            return a.push(e),
                            e;
                    return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),
                    0
                }();
                t.__bindingPointIndex = n;
                const i = e.createBuffer()
                  , r = t.__size
                  , s = t.usage;
                return e.bindBuffer(35345, i),
                e.bufferData(35345, r, s),
                e.bindBuffer(35345, null),
                e.bindBufferBase(35345, n, i),
                i
            }(n),
            r[n.id] = d,
            n.addEventListener("dispose", h));
            const p = u.program;
            i.updateUBOMapping(n, p);
            const m = t.render.frame;
            s[n.id] !== m && (!function(t) {
                const n = r[t.id]
                  , i = t.uniforms
                  , s = t.__cache;
                e.bindBuffer(35345, n);
                for (let t = 0, n = i.length; t < n; t++) {
                    const n = i[t];
                    if (!0 === l(n, t, s)) {
                        const t = n.value
                          , i = n.__offset;
                        "number" == typeof t ? (n.__data[0] = t,
                        e.bufferSubData(35345, i, n.__data)) : (n.value.isMatrix3 ? (n.__data[0] = n.value.elements[0],
                        n.__data[1] = n.value.elements[1],
                        n.__data[2] = n.value.elements[2],
                        n.__data[3] = n.value.elements[0],
                        n.__data[4] = n.value.elements[3],
                        n.__data[5] = n.value.elements[4],
                        n.__data[6] = n.value.elements[5],
                        n.__data[7] = n.value.elements[0],
                        n.__data[8] = n.value.elements[6],
                        n.__data[9] = n.value.elements[7],
                        n.__data[10] = n.value.elements[8],
                        n.__data[11] = n.value.elements[0]) : t.toArray(n.__data),
                        e.bufferSubData(35345, i, n.__data))
                    }
                }
                e.bindBuffer(35345, null)
            }(n),
            s[n.id] = m)
        },
        dispose: function() {
            for (const t in r)
                e.deleteBuffer(r[t]);
            a = [],
            r = {},
            s = {}
        }
    }
}
function ro(e={}) {
    this.isWebGLRenderer = !0;
    const t = void 0 !== e.canvas ? e.canvas : function() {
        const e = Vt("canvas");
        return e.style.display = "block",
        e
    }()
      , n = void 0 !== e.context ? e.context : null
      , i = void 0 === e.depth || e.depth
      , r = void 0 === e.stencil || e.stencil
      , s = void 0 !== e.antialias && e.antialias
      , a = void 0 === e.premultipliedAlpha || e.premultipliedAlpha
      , o = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer
      , l = void 0 !== e.powerPreference ? e.powerPreference : "default"
      , c = void 0 !== e.failIfMajorPerformanceCaveat && e.failIfMajorPerformanceCaveat;
    let h;
    h = null !== n ? n.getContextAttributes().alpha : void 0 !== e.alpha && e.alpha;
    let u = null
      , d = null;
    const p = []
      , m = [];
    this.domElement = t,
    this.debug = {
        checkShaderErrors: !0
    },
    this.autoClear = !0,
    this.autoClearColor = !0,
    this.autoClearDepth = !0,
    this.autoClearStencil = !0,
    this.sortObjects = !0,
    this.clippingPlanes = [],
    this.localClippingEnabled = !1,
    this.outputEncoding = ft,
    this.physicallyCorrectLights = !1,
    this.toneMapping = 0,
    this.toneMappingExposure = 1,
    Object.defineProperties(this, {
        gammaFactor: {
            get: function() {
                return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."),
                2
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")
            }
        }
    });
    const f = this;
    let g = !1
      , v = 0
      , x = 0
      , y = null
      , _ = -1
      , b = null;
    const M = new ln
      , w = new ln;
    let S = null
      , T = t.width
      , A = t.height
      , E = 1
      , C = null
      , L = null;
    const R = new ln(0,0,T,A)
      , P = new ln(0,0,T,A);
    let I = !1;
    const D = new Ar;
    let O = !1
      , N = !1
      , z = null;
    const U = new Wn
      , F = new Ft
      , B = new pn
      , k = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0
    };
    function G() {
        return null === y ? E : 1
    }
    let H, V, W, j, X, q, Y, Z, J, K, Q, $, te, ne, ie, re, se, oe, le, ce, he, ue, de, pe, me = n;
    function fe(e, n) {
        for (let i = 0; i < e.length; i++) {
            const r = e[i]
              , s = t.getContext(r, n);
            if (null !== s)
                return s
        }
        return null
    }
    try {
        const e = {
            alpha: !0,
            depth: i,
            stencil: r,
            antialias: s,
            premultipliedAlpha: a,
            preserveDrawingBuffer: o,
            powerPreference: l,
            failIfMajorPerformanceCaveat: c
        };
        if ("setAttribute"in t && t.setAttribute("data-engine", `three.js r${ee}`),
        t.addEventListener("webglcontextlost", xe, !1),
        t.addEventListener("webglcontextrestored", ye, !1),
        t.addEventListener("webglcontextcreationerror", _e, !1),
        null === me) {
            const t = ["webgl2", "webgl", "experimental-webgl"];
            if (!0 === f.isWebGL1Renderer && t.shift(),
            me = fe(t, e),
            null === me)
                throw fe(t) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
        }
        void 0 === me.getShaderPrecisionFormat && (me.getShaderPrecisionFormat = function() {
            return {
                rangeMin: 1,
                rangeMax: 1,
                precision: 1
            }
        }
        )
    } catch (e) {
        throw console.error("THREE.WebGLRenderer: " + e.message),
        e
    }
    function ge() {
        H = new ts(me),
        V = new zr(me,H,e),
        H.init(V),
        ue = new Za(me,H,V),
        W = new qa(me,H,V),
        j = new rs,
        X = new Da,
        q = new Ya(me,H,W,X,V,ue,j),
        Y = new Fr(f),
        Z = new es(f),
        J = new Cr(me,V),
        de = new Or(me,H,J,V),
        K = new ns(me,J,j,de),
        Q = new ls(me,K,J,j),
        le = new os(me,V,q),
        re = new Ur(X),
        $ = new Ia(f,Y,Z,H,V,de,re),
        te = new no(f,X),
        ne = new Ua,
        ie = new Va(H,V),
        oe = new Dr(f,Y,W,Q,h,a),
        se = new Xa(f,Q,V),
        pe = new io(me,j,V,W),
        ce = new Nr(me,H,j,V),
        he = new is(me,H,j,V),
        j.programs = $.programs,
        f.capabilities = V,
        f.extensions = H,
        f.properties = X,
        f.renderLists = ne,
        f.shadowMap = se,
        f.state = W,
        f.info = j
    }
    ge();
    const ve = new to(f,me);
    function xe(e) {
        e.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        g = !0
    }
    function ye() {
        console.log("THREE.WebGLRenderer: Context Restored."),
        g = !1;
        const e = j.autoReset
          , t = se.enabled
          , n = se.autoUpdate
          , i = se.needsUpdate
          , r = se.type;
        ge(),
        j.autoReset = e,
        se.enabled = t,
        se.autoUpdate = n,
        se.needsUpdate = i,
        se.type = r
    }
    function _e(e) {
        console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", e.statusMessage)
    }
    function be(e) {
        const t = e.target;
        t.removeEventListener("dispose", be),
        function(e) {
            (function(e) {
                const t = X.get(e).programs;
                void 0 !== t && (t.forEach((function(e) {
                    $.releaseProgram(e)
                }
                )),
                e.isShaderMaterial && $.releaseShaderCache(e))
            }
            )(e),
            X.remove(e)
        }(t)
    }
    this.xr = ve,
    this.getContext = function() {
        return me
    }
    ,
    this.getContextAttributes = function() {
        return me.getContextAttributes()
    }
    ,
    this.forceContextLoss = function() {
        const e = H.get("WEBGL_lose_context");
        e && e.loseContext()
    }
    ,
    this.forceContextRestore = function() {
        const e = H.get("WEBGL_lose_context");
        e && e.restoreContext()
    }
    ,
    this.getPixelRatio = function() {
        return E
    }
    ,
    this.setPixelRatio = function(e) {
        void 0 !== e && (E = e,
        this.setSize(T, A, !1))
    }
    ,
    this.getSize = function(e) {
        return e.set(T, A)
    }
    ,
    this.setSize = function(e, n, i) {
        ve.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (T = e,
        A = n,
        t.width = Math.floor(e * E),
        t.height = Math.floor(n * E),
        !1 !== i && (t.style.width = e + "px",
        t.style.height = n + "px"),
        this.setViewport(0, 0, e, n))
    }
    ,
    this.getDrawingBufferSize = function(e) {
        return e.set(T * E, A * E).floor()
    }
    ,
    this.setDrawingBufferSize = function(e, n, i) {
        T = e,
        A = n,
        E = i,
        t.width = Math.floor(e * i),
        t.height = Math.floor(n * i),
        this.setViewport(0, 0, e, n)
    }
    ,
    this.getCurrentViewport = function(e) {
        return e.copy(M)
    }
    ,
    this.getViewport = function(e) {
        return e.copy(R)
    }
    ,
    this.setViewport = function(e, t, n, i) {
        e.isVector4 ? R.set(e.x, e.y, e.z, e.w) : R.set(e, t, n, i),
        W.viewport(M.copy(R).multiplyScalar(E).floor())
    }
    ,
    this.getScissor = function(e) {
        return e.copy(P)
    }
    ,
    this.setScissor = function(e, t, n, i) {
        e.isVector4 ? P.set(e.x, e.y, e.z, e.w) : P.set(e, t, n, i),
        W.scissor(w.copy(P).multiplyScalar(E).floor())
    }
    ,
    this.getScissorTest = function() {
        return I
    }
    ,
    this.setScissorTest = function(e) {
        W.setScissorTest(I = e)
    }
    ,
    this.setOpaqueSort = function(e) {
        C = e
    }
    ,
    this.setTransparentSort = function(e) {
        L = e
    }
    ,
    this.getClearColor = function(e) {
        return e.copy(oe.getClearColor())
    }
    ,
    this.setClearColor = function() {
        oe.setClearColor.apply(oe, arguments)
    }
    ,
    this.getClearAlpha = function() {
        return oe.getClearAlpha()
    }
    ,
    this.setClearAlpha = function() {
        oe.setClearAlpha.apply(oe, arguments)
    }
    ,
    this.clear = function(e=!0, t=!0, n=!0) {
        let i = 0;
        e && (i |= 16384),
        t && (i |= 256),
        n && (i |= 1024),
        me.clear(i)
    }
    ,
    this.clearColor = function() {
        this.clear(!0, !1, !1)
    }
    ,
    this.clearDepth = function() {
        this.clear(!1, !0, !1)
    }
    ,
    this.clearStencil = function() {
        this.clear(!1, !1, !0)
    }
    ,
    this.dispose = function() {
        t.removeEventListener("webglcontextlost", xe, !1),
        t.removeEventListener("webglcontextrestored", ye, !1),
        t.removeEventListener("webglcontextcreationerror", _e, !1),
        ne.dispose(),
        ie.dispose(),
        X.dispose(),
        Y.dispose(),
        Z.dispose(),
        Q.dispose(),
        de.dispose(),
        pe.dispose(),
        $.dispose(),
        ve.dispose(),
        ve.removeEventListener("sessionstart", we),
        ve.removeEventListener("sessionend", Se),
        z && (z.dispose(),
        z = null),
        Ee.stop()
    }
    ,
    this.renderBufferDirect = function(e, t, n, i, r, s) {
        null === t && (t = k);
        const a = r.isMesh && r.matrixWorld.determinant() < 0
          , o = function(e, t, n, i, r) {
            !0 !== t.isScene && (t = k);
            q.resetTextureUnits();
            const s = t.fog
              , a = i.isMeshStandardMaterial ? t.environment : null
              , o = null === y ? f.outputEncoding : !0 === y.isXRRenderTarget ? y.texture.encoding : ft
              , l = (i.isMeshStandardMaterial ? Z : Y).get(i.envMap || a)
              , c = !0 === i.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize
              , h = !!i.normalMap && !!n.attributes.tangent
              , u = !!n.morphAttributes.position
              , p = !!n.morphAttributes.normal
              , m = !!n.morphAttributes.color
              , g = i.toneMapped ? f.toneMapping : 0
              , v = n.morphAttributes.position || n.morphAttributes.normal || n.morphAttributes.color
              , x = void 0 !== v ? v.length : 0
              , M = X.get(i)
              , w = d.state.lights;
            if (!0 === O && (!0 === N || e !== b)) {
                const t = e === b && i.id === _;
                re.setState(i, e, t)
            }
            let S = !1;
            i.version === M.__version ? M.needsLights && M.lightsStateVersion !== w.state.version || M.outputEncoding !== o || r.isInstancedMesh && !1 === M.instancing ? S = !0 : r.isInstancedMesh || !0 !== M.instancing ? r.isSkinnedMesh && !1 === M.skinning ? S = !0 : r.isSkinnedMesh || !0 !== M.skinning ? M.envMap !== l || !0 === i.fog && M.fog !== s ? S = !0 : void 0 === M.numClippingPlanes || M.numClippingPlanes === re.numPlanes && M.numIntersection === re.numIntersection ? (M.vertexAlphas !== c || M.vertexTangents !== h || M.morphTargets !== u || M.morphNormals !== p || M.morphColors !== m || M.toneMapping !== g || !0 === V.isWebGL2 && M.morphTargetsCount !== x) && (S = !0) : S = !0 : S = !0 : S = !0 : (S = !0,
            M.__version = i.version);
            let T = M.currentProgram;
            !0 === S && (T = Ne(i, t, r));
            let C = !1
              , L = !1
              , R = !1;
            const P = T.getUniforms()
              , I = M.uniforms;
            W.useProgram(T.program) && (C = !0,
            L = !0,
            R = !0);
            i.id !== _ && (_ = i.id,
            L = !0);
            if (C || b !== e) {
                if (P.setValue(me, "projectionMatrix", e.projectionMatrix),
                V.logarithmicDepthBuffer && P.setValue(me, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)),
                b !== e && (b = e,
                L = !0,
                R = !0),
                i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshStandardMaterial || i.envMap) {
                    const t = P.map.cameraPosition;
                    void 0 !== t && t.setValue(me, B.setFromMatrixPosition(e.matrixWorld))
                }
                (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && P.setValue(me, "isOrthographic", !0 === e.isOrthographicCamera),
                (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.isShadowMaterial || r.isSkinnedMesh) && P.setValue(me, "viewMatrix", e.matrixWorldInverse)
            }
            if (r.isSkinnedMesh) {
                P.setOptional(me, r, "bindMatrix"),
                P.setOptional(me, r, "bindMatrixInverse");
                const e = r.skeleton;
                e && (V.floatVertexTextures ? (null === e.boneTexture && e.computeBoneTexture(),
                P.setValue(me, "boneTexture", e.boneTexture, q),
                P.setValue(me, "boneTextureSize", e.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))
            }
            const D = n.morphAttributes;
            (void 0 !== D.position || void 0 !== D.normal || void 0 !== D.color && !0 === V.isWebGL2) && le.update(r, n, i, T);
            (L || M.receiveShadow !== r.receiveShadow) && (M.receiveShadow = r.receiveShadow,
            P.setValue(me, "receiveShadow", r.receiveShadow));
            i.isMeshGouraudMaterial && null !== i.envMap && (I.envMap.value = l,
            I.flipEnvMap.value = l.isCubeTexture && !1 === l.isRenderTargetTexture ? -1 : 1);
            L && (P.setValue(me, "toneMappingExposure", f.toneMappingExposure),
            M.needsLights && (F = R,
            (U = I).ambientLightColor.needsUpdate = F,
            U.lightProbe.needsUpdate = F,
            U.directionalLights.needsUpdate = F,
            U.directionalLightShadows.needsUpdate = F,
            U.pointLights.needsUpdate = F,
            U.pointLightShadows.needsUpdate = F,
            U.spotLights.needsUpdate = F,
            U.spotLightShadows.needsUpdate = F,
            U.rectAreaLights.needsUpdate = F,
            U.hemisphereLights.needsUpdate = F),
            s && !0 === i.fog && te.refreshFogUniforms(I, s),
            te.refreshMaterialUniforms(I, i, E, A, z),
            da.upload(me, M.uniformsList, I, q));
            var U, F;
            i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (da.upload(me, M.uniformsList, I, q),
            i.uniformsNeedUpdate = !1);
            i.isSpriteMaterial && P.setValue(me, "center", r.center);
            if (P.setValue(me, "modelViewMatrix", r.modelViewMatrix),
            P.setValue(me, "normalMatrix", r.normalMatrix),
            P.setValue(me, "modelMatrix", r.matrixWorld),
            i.isShaderMaterial || i.isRawShaderMaterial) {
                const e = i.uniformsGroups;
                for (let t = 0, n = e.length; t < n; t++)
                    if (V.isWebGL2) {
                        const n = e[t];
                        pe.update(n, T),
                        pe.bind(n, T)
                    } else
                        console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")
            }
            return T
        }(e, t, n, i, r);
        W.setMaterial(i, a);
        let l = n.index;
        const c = n.attributes.position;
        if (null === l) {
            if (void 0 === c || 0 === c.count)
                return
        } else if (0 === l.count)
            return;
        let h, u = 1;
        !0 === i.wireframe && (l = K.getWireframeAttribute(n),
        u = 2),
        de.setup(r, i, o, n, l);
        let p = ce;
        null !== l && (h = J.get(l),
        p = he,
        p.setIndex(h));
        const m = null !== l ? l.count : c.count
          , g = n.drawRange.start * u
          , v = n.drawRange.count * u
          , x = null !== s ? s.start * u : 0
          , M = null !== s ? s.count * u : Infinity
          , w = Math.max(g, x)
          , S = Math.min(m, g + v, x + M) - 1
          , T = Math.max(0, S - w + 1);
        if (0 !== T) {
            if (r.isMesh)
                !0 === i.wireframe ? (W.setLineWidth(i.wireframeLinewidth * G()),
                p.setMode(1)) : p.setMode(4);
            else if (r.isLine) {
                let e = i.linewidth;
                void 0 === e && (e = 1),
                W.setLineWidth(e * G()),
                r.isLineSegments ? p.setMode(1) : r.isLineLoop ? p.setMode(2) : p.setMode(3)
            } else
                r.isPoints ? p.setMode(0) : r.isSprite && p.setMode(4);
            if (r.isInstancedMesh)
                p.renderInstances(w, T, r.count);
            else if (n.isInstancedBufferGeometry) {
                const e = Math.min(n.instanceCount, n._maxInstanceCount);
                p.renderInstances(w, T, e)
            } else
                p.render(w, T)
        }
    }
    ,
    this.compile = function(e, t) {
        function n(e, t, n) {
            !0 === e.transparent && e.side === ae ? (e.side = 1,
            e.needsUpdate = !0,
            Ne(e, t, n),
            e.side = 0,
            e.needsUpdate = !0,
            Ne(e, t, n),
            e.side = ae) : Ne(e, t, n)
        }
        d = ie.get(e),
        d.init(),
        m.push(d),
        e.traverseVisible((function(e) {
            e.isLight && e.layers.test(t.layers) && (d.pushLight(e),
            e.castShadow && d.pushShadow(e))
        }
        )),
        d.setupLights(f.physicallyCorrectLights),
        e.traverse((function(t) {
            const i = t.material;
            if (i)
                if (Array.isArray(i))
                    for (let r = 0; r < i.length; r++) {
                        n(i[r], e, t)
                    }
                else
                    n(i, e, t)
        }
        )),
        m.pop(),
        d = null
    }
    ;
    let Me = null;
    function we() {
        Ee.stop()
    }
    function Se() {
        Ee.start()
    }
    const Ee = new Er;
    function Ce(e, t, n, i) {
        if (!1 === e.visible)
            return;
        if (e.layers.test(t.layers))
            if (e.isGroup)
                n = e.renderOrder;
            else if (e.isLOD)
                !0 === e.autoUpdate && e.update(t);
            else if (e.isLight)
                d.pushLight(e),
                e.castShadow && d.pushShadow(e);
            else if (e.isSprite) {
                if (!e.frustumCulled || D.intersectsSprite(e)) {
                    i && B.setFromMatrixPosition(e.matrixWorld).applyMatrix4(U);
                    const t = Q.update(e)
                      , r = e.material;
                    r.visible && u.push(e, t, r, n, B.z, null)
                }
            } else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.frame !== j.render.frame && (e.skeleton.update(),
            e.skeleton.frame = j.render.frame),
            !e.frustumCulled || D.intersectsObject(e))) {
                i && B.setFromMatrixPosition(e.matrixWorld).applyMatrix4(U);
                const t = Q.update(e)
                  , r = e.material;
                if (Array.isArray(r)) {
                    const i = t.groups;
                    for (let s = 0, a = i.length; s < a; s++) {
                        const a = i[s]
                          , o = r[a.materialIndex];
                        o && o.visible && u.push(e, t, o, n, B.z, a)
                    }
                } else
                    r.visible && u.push(e, t, r, n, B.z, null)
            }
        const r = e.children;
        for (let e = 0, s = r.length; e < s; e++)
            Ce(r[e], t, n, i)
    }
    function Pe(e, t, n, i) {
        const r = e.opaque
          , a = e.transmissive
          , o = e.transparent;
        d.setupLightsView(n),
        a.length > 0 && function(e, t, n) {
            const i = V.isWebGL2;
            null === z && (z = new cn(1,1,{
                generateMipmaps: !0,
                type: H.has("EXT_color_buffer_half_float") ? Re : Ae,
                minFilter: Te,
                samples: i && !0 === s ? 4 : 0
            }));
            f.getDrawingBufferSize(F),
            i ? z.setSize(F.x, F.y) : z.setSize(Ot(F.x), Ot(F.y));
            const r = f.getRenderTarget();
            f.setRenderTarget(z),
            f.clear();
            const a = f.toneMapping;
            f.toneMapping = 0,
            De(e, t, n),
            f.toneMapping = a,
            q.updateMultisampleRenderTarget(z),
            q.updateRenderTargetMipmap(z),
            f.setRenderTarget(r)
        }(r, t, n),
        i && W.viewport(M.copy(i)),
        r.length > 0 && De(r, t, n),
        a.length > 0 && De(a, t, n),
        o.length > 0 && De(o, t, n),
        W.buffers.depth.setTest(!0),
        W.buffers.depth.setMask(!0),
        W.buffers.color.setMask(!0),
        W.setPolygonOffset(!1)
    }
    function De(e, t, n) {
        const i = !0 === t.isScene ? t.overrideMaterial : null;
        for (let r = 0, s = e.length; r < s; r++) {
            const s = e[r]
              , a = s.object
              , o = s.geometry
              , l = null === i ? s.material : i
              , c = s.group;
            a.layers.test(n.layers) && Oe(a, t, n, o, l, c)
        }
    }
    function Oe(e, t, n, i, r, s) {
        e.onBeforeRender(f, t, n, i, r, s),
        e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld),
        e.normalMatrix.getNormalMatrix(e.modelViewMatrix),
        r.onBeforeRender(f, t, n, i, e, s),
        !0 === r.transparent && r.side === ae ? (r.side = 1,
        r.needsUpdate = !0,
        f.renderBufferDirect(n, t, i, r, e, s),
        r.side = 0,
        r.needsUpdate = !0,
        f.renderBufferDirect(n, t, i, r, e, s),
        r.side = ae) : f.renderBufferDirect(n, t, i, r, e, s),
        e.onAfterRender(f, t, n, i, r, s)
    }
    function Ne(e, t, n) {
        !0 !== t.isScene && (t = k);
        const i = X.get(e)
          , r = d.state.lights
          , s = d.state.shadowsArray
          , a = r.state.version
          , o = $.getParameters(e, r.state, s, t, n)
          , l = $.getProgramCacheKey(o);
        let c = i.programs;
        i.environment = e.isMeshStandardMaterial ? t.environment : null,
        i.fog = t.fog,
        i.envMap = (e.isMeshStandardMaterial ? Z : Y).get(e.envMap || i.environment),
        void 0 === c && (e.addEventListener("dispose", be),
        c = new Map,
        i.programs = c);
        let h = c.get(l);
        if (void 0 !== h) {
            if (i.currentProgram === h && i.lightsStateVersion === a)
                return ze(e, o),
                h
        } else
            o.uniforms = $.getUniforms(e),
            e.onBuild(n, o, f),
            e.onBeforeCompile(o, f),
            h = $.acquireProgram(o, l),
            c.set(l, h),
            i.uniforms = o.uniforms;
        const u = i.uniforms;
        (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (u.clippingPlanes = re.uniform),
        ze(e, o),
        i.needsLights = function(e) {
            return e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights
        }(e),
        i.lightsStateVersion = a,
        i.needsLights && (u.ambientLightColor.value = r.state.ambient,
        u.lightProbe.value = r.state.probe,
        u.directionalLights.value = r.state.directional,
        u.directionalLightShadows.value = r.state.directionalShadow,
        u.spotLights.value = r.state.spot,
        u.spotLightShadows.value = r.state.spotShadow,
        u.rectAreaLights.value = r.state.rectArea,
        u.ltc_1.value = r.state.rectAreaLTC1,
        u.ltc_2.value = r.state.rectAreaLTC2,
        u.pointLights.value = r.state.point,
        u.pointLightShadows.value = r.state.pointShadow,
        u.hemisphereLights.value = r.state.hemi,
        u.directionalShadowMap.value = r.state.directionalShadowMap,
        u.directionalShadowMatrix.value = r.state.directionalShadowMatrix,
        u.spotShadowMap.value = r.state.spotShadowMap,
        u.spotLightMatrix.value = r.state.spotLightMatrix,
        u.spotLightMap.value = r.state.spotLightMap,
        u.pointShadowMap.value = r.state.pointShadowMap,
        u.pointShadowMatrix.value = r.state.pointShadowMatrix);
        const p = h.getUniforms()
          , m = da.seqWithValue(p.seq, u);
        return i.currentProgram = h,
        i.uniformsList = m,
        h
    }
    function ze(e, t) {
        const n = X.get(e);
        n.outputEncoding = t.outputEncoding,
        n.instancing = t.instancing,
        n.skinning = t.skinning,
        n.morphTargets = t.morphTargets,
        n.morphNormals = t.morphNormals,
        n.morphColors = t.morphColors,
        n.morphTargetsCount = t.morphTargetsCount,
        n.numClippingPlanes = t.numClippingPlanes,
        n.numIntersection = t.numClipIntersection,
        n.vertexAlphas = t.vertexAlphas,
        n.vertexTangents = t.vertexTangents,
        n.toneMapping = t.toneMapping
    }
    Ee.setAnimationLoop((function(e) {
        Me && Me(e)
    }
    )),
    "undefined" != typeof self && Ee.setContext(self),
    this.setAnimationLoop = function(e) {
        Me = e,
        ve.setAnimationLoop(e),
        null === e ? Ee.stop() : Ee.start()
    }
    ,
    ve.addEventListener("sessionstart", we),
    ve.addEventListener("sessionend", Se),
    this.render = function(e, t) {
        if (void 0 !== t && !0 !== t.isCamera)
            return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        if (!0 === g)
            return;
        !0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(),
        null === t.parent && !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(),
        !0 === ve.enabled && !0 === ve.isPresenting && (!0 === ve.cameraAutoUpdate && ve.updateCamera(t),
        t = ve.getCamera()),
        !0 === e.isScene && e.onBeforeRender(f, e, t, y),
        d = ie.get(e, m.length),
        d.init(),
        m.push(d),
        U.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
        D.setFromProjectionMatrix(U),
        N = this.localClippingEnabled,
        O = re.init(this.clippingPlanes, N, t),
        u = ne.get(e, p.length),
        u.init(),
        p.push(u),
        Ce(e, t, 0, f.sortObjects),
        u.finish(),
        !0 === f.sortObjects && u.sort(C, L),
        !0 === O && re.beginShadows();
        const n = d.state.shadowsArray;
        if (se.render(n, e, t),
        !0 === O && re.endShadows(),
        !0 === this.info.autoReset && this.info.reset(),
        oe.render(u, e),
        d.setupLights(f.physicallyCorrectLights),
        t.isArrayCamera) {
            const n = t.cameras;
            for (let t = 0, i = n.length; t < i; t++) {
                const i = n[t];
                Pe(u, e, i, i.viewport)
            }
        } else
            Pe(u, e, t);
        null !== y && (q.updateMultisampleRenderTarget(y),
        q.updateRenderTargetMipmap(y)),
        !0 === e.isScene && e.onAfterRender(f, e, t),
        de.resetDefaultState(),
        _ = -1,
        b = null,
        m.pop(),
        d = m.length > 0 ? m[m.length - 1] : null,
        p.pop(),
        u = p.length > 0 ? p[p.length - 1] : null
    }
    ,
    this.getActiveCubeFace = function() {
        return v
    }
    ,
    this.getActiveMipmapLevel = function() {
        return x
    }
    ,
    this.getRenderTarget = function() {
        return y
    }
    ,
    this.setRenderTargetTextures = function(e, t, n) {
        X.get(e.texture).__webglTexture = t,
        X.get(e.depthTexture).__webglTexture = n;
        const i = X.get(e);
        i.__hasExternalTextures = !0,
        i.__hasExternalTextures && (i.__autoAllocateDepthBuffer = void 0 === n,
        i.__autoAllocateDepthBuffer || !0 === H.has("WEBGL_multisampled_render_to_texture") && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),
        i.__useRenderToTexture = !1))
    }
    ,
    this.setRenderTargetFramebuffer = function(e, t) {
        const n = X.get(e);
        n.__webglFramebuffer = t,
        n.__useDefaultFramebuffer = void 0 === t
    }
    ,
    this.setRenderTarget = function(e, t=0, n=0) {
        y = e,
        v = t,
        x = n;
        let i = !0;
        if (e) {
            const t = X.get(e);
            void 0 !== t.__useDefaultFramebuffer ? (W.bindFramebuffer(36160, null),
            i = !1) : void 0 === t.__webglFramebuffer ? q.setupRenderTarget(e) : t.__hasExternalTextures && q.rebindTextures(e, X.get(e.texture).__webglTexture, X.get(e.depthTexture).__webglTexture)
        }
        let r = null
          , s = !1
          , a = !1;
        if (e) {
            const n = e.texture;
            (n.isData3DTexture || n.isDataArrayTexture) && (a = !0);
            const i = X.get(e).__webglFramebuffer;
            e.isWebGLCubeRenderTarget ? (r = i[t],
            s = !0) : r = V.isWebGL2 && e.samples > 0 && !1 === q.useMultisampledRTT(e) ? X.get(e).__webglMultisampledFramebuffer : i,
            M.copy(e.viewport),
            w.copy(e.scissor),
            S = e.scissorTest
        } else
            M.copy(R).multiplyScalar(E).floor(),
            w.copy(P).multiplyScalar(E).floor(),
            S = I;
        if (W.bindFramebuffer(36160, r) && V.drawBuffers && i && W.drawBuffers(e, r),
        W.viewport(M),
        W.scissor(w),
        W.setScissorTest(S),
        s) {
            const i = X.get(e.texture);
            me.framebufferTexture2D(36160, 36064, 34069 + t, i.__webglTexture, n)
        } else if (a) {
            const i = X.get(e.texture)
              , r = t || 0;
            me.framebufferTextureLayer(36160, 36064, i.__webglTexture, n || 0, r)
        }
        _ = -1
    }
    ,
    this.readRenderTargetPixels = function(e, t, n, i, r, s, a) {
        if (!e || !e.isWebGLRenderTarget)
            return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        let o = X.get(e).__webglFramebuffer;
        if (e.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]),
        o) {
            W.bindFramebuffer(36160, o);
            try {
                const a = e.texture
                  , o = a.format
                  , l = a.type;
                if (o !== Ie && ue.convert(o) !== me.getParameter(35739))
                    return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                const c = l === Re && (H.has("EXT_color_buffer_half_float") || V.isWebGL2 && H.has("EXT_color_buffer_float"));
                if (!(l === Ae || ue.convert(l) === me.getParameter(35738) || l === Le && (V.isWebGL2 || H.has("OES_texture_float") || H.has("WEBGL_color_buffer_float")) || c))
                    return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                t >= 0 && t <= e.width - i && n >= 0 && n <= e.height - r && me.readPixels(t, n, i, r, ue.convert(o), ue.convert(l), s)
            } finally {
                const e = null !== y ? X.get(y).__webglFramebuffer : null;
                W.bindFramebuffer(36160, e)
            }
        }
    }
    ,
    this.copyFramebufferToTexture = function(e, t, n=0) {
        const i = Math.pow(2, -n)
          , r = Math.floor(t.image.width * i)
          , s = Math.floor(t.image.height * i);
        q.setTexture2D(t, 0),
        me.copyTexSubImage2D(3553, n, 0, 0, e.x, e.y, r, s),
        W.unbindTexture()
    }
    ,
    this.copyTextureToTexture = function(e, t, n, i=0) {
        const r = t.image.width
          , s = t.image.height
          , a = ue.convert(n.format)
          , o = ue.convert(n.type);
        q.setTexture2D(n, 0),
        me.pixelStorei(37440, n.flipY),
        me.pixelStorei(37441, n.premultiplyAlpha),
        me.pixelStorei(3317, n.unpackAlignment),
        t.isDataTexture ? me.texSubImage2D(3553, i, e.x, e.y, r, s, a, o, t.image.data) : t.isCompressedTexture ? me.compressedTexSubImage2D(3553, i, e.x, e.y, t.mipmaps[0].width, t.mipmaps[0].height, a, t.mipmaps[0].data) : me.texSubImage2D(3553, i, e.x, e.y, a, o, t.image),
        0 === i && n.generateMipmaps && me.generateMipmap(3553),
        W.unbindTexture()
    }
    ,
    this.copyTextureToTexture3D = function(e, t, n, i, r=0) {
        if (f.isWebGL1Renderer)
            return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
        const s = e.max.x - e.min.x + 1
          , a = e.max.y - e.min.y + 1
          , o = e.max.z - e.min.z + 1
          , l = ue.convert(i.format)
          , c = ue.convert(i.type);
        let h;
        if (i.isData3DTexture)
            q.setTexture3D(i, 0),
            h = 32879;
        else {
            if (!i.isDataArrayTexture)
                return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
            q.setTexture2DArray(i, 0),
            h = 35866
        }
        me.pixelStorei(37440, i.flipY),
        me.pixelStorei(37441, i.premultiplyAlpha),
        me.pixelStorei(3317, i.unpackAlignment);
        const u = me.getParameter(3314)
          , d = me.getParameter(32878)
          , p = me.getParameter(3316)
          , m = me.getParameter(3315)
          , g = me.getParameter(32877)
          , v = n.isCompressedTexture ? n.mipmaps[0] : n.image;
        me.pixelStorei(3314, v.width),
        me.pixelStorei(32878, v.height),
        me.pixelStorei(3316, e.min.x),
        me.pixelStorei(3315, e.min.y),
        me.pixelStorei(32877, e.min.z),
        n.isDataTexture || n.isData3DTexture ? me.texSubImage3D(h, r, t.x, t.y, t.z, s, a, o, l, c, v.data) : n.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),
        me.compressedTexSubImage3D(h, r, t.x, t.y, t.z, s, a, o, l, v.data)) : me.texSubImage3D(h, r, t.x, t.y, t.z, s, a, o, l, c, v),
        me.pixelStorei(3314, u),
        me.pixelStorei(32878, d),
        me.pixelStorei(3316, p),
        me.pixelStorei(3315, m),
        me.pixelStorei(32877, g),
        0 === r && i.generateMipmaps && me.generateMipmap(h),
        W.unbindTexture()
    }
    ,
    this.initTexture = function(e) {
        e.isCubeTexture ? q.setTextureCube(e, 0) : e.isData3DTexture ? q.setTexture3D(e, 0) : e.isDataArrayTexture ? q.setTexture2DArray(e, 0) : q.setTexture2D(e, 0),
        W.unbindTexture()
    }
    ,
    this.resetState = function() {
        v = 0,
        x = 0,
        y = null,
        W.reset(),
        de.reset()
    }
    ,
    "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
        detail: this
    }))
}
class so extends ro {
}
so.prototype.isWebGL1Renderer = !0;
class ao {
    constructor(e, t=25e-5) {
        this.isFogExp2 = !0,
        this.name = "",
        this.color = new en(e),
        this.density = t
    }
    clone() {
        return new ao(this.color,this.density)
    }
    toJSON() {
        return {
            type: "FogExp2",
            color: this.color.getHex(),
            density: this.density
        }
    }
}
class oo {
    constructor(e, t=1, n=1e3) {
        this.isFog = !0,
        this.name = "",
        this.color = new en(e),
        this.near = t,
        this.far = n
    }
    clone() {
        return new oo(this.color,this.near,this.far)
    }
    toJSON() {
        return {
            type: "Fog",
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        }
    }
}
class lo extends fi {
    constructor() {
        super(),
        this.isScene = !0,
        this.type = "Scene",
        this.background = null,
        this.environment = null,
        this.fog = null,
        this.overrideMaterial = null,
        "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    copy(e, t) {
        return super.copy(e, t),
        null !== e.background && (this.background = e.background.clone()),
        null !== e.environment && (this.environment = e.environment.clone()),
        null !== e.fog && (this.fog = e.fog.clone()),
        null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return null !== this.fog && (t.object.fog = this.fog.toJSON()),
        t
    }
    get autoUpdate() {
        return console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."),
        this.matrixWorldAutoUpdate
    }
    set autoUpdate(e) {
        console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."),
        this.matrixWorldAutoUpdate = e
    }
}
class co {
    constructor(e, t) {
        this.isInterleavedBuffer = !0,
        this.array = e,
        this.stride = t,
        this.count = void 0 !== e ? e.length / t : 0,
        this.usage = _t,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.version = 0,
        this.uuid = Ct()
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        !0 === e && this.version++
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    copy(e) {
        return this.array = new e.array.constructor(e.array),
        this.count = e.count,
        this.stride = e.stride,
        this.usage = e.usage,
        this
    }
    copyAt(e, t, n) {
        e *= this.stride,
        n *= t.stride;
        for (let i = 0, r = this.stride; i < r; i++)
            this.array[e + i] = t.array[n + i];
        return this
    }
    set(e, t=0) {
        return this.array.set(e, t),
        this
    }
    clone(e) {
        void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
        void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Ct()),
        void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
        const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid])
          , n = new this.constructor(t,this.stride);
        return n.setUsage(this.usage),
        n
    }
    onUpload(e) {
        return this.onUploadCallback = e,
        this
    }
    toJSON(e) {
        return void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
        void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Ct()),
        void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))),
        {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
        }
    }
}
const ho = new pn;
class uo {
    constructor(e, t, n, i=!1) {
        this.isInterleavedBufferAttribute = !0,
        this.name = "",
        this.data = e,
        this.itemSize = t,
        this.offset = n,
        this.normalized = !0 === i
    }
    get count() {
        return this.data.count
    }
    get array() {
        return this.data.array
    }
    set needsUpdate(e) {
        this.data.needsUpdate = e
    }
    applyMatrix4(e) {
        for (let t = 0, n = this.data.count; t < n; t++)
            ho.fromBufferAttribute(this, t),
            ho.applyMatrix4(e),
            this.setXYZ(t, ho.x, ho.y, ho.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, n = this.count; t < n; t++)
            ho.fromBufferAttribute(this, t),
            ho.applyNormalMatrix(e),
            this.setXYZ(t, ho.x, ho.y, ho.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, n = this.count; t < n; t++)
            ho.fromBufferAttribute(this, t),
            ho.transformDirection(e),
            this.setXYZ(t, ho.x, ho.y, ho.z);
        return this
    }
    setX(e, t) {
        return this.normalized && (t = zt(t, this.array)),
        this.data.array[e * this.data.stride + this.offset] = t,
        this
    }
    setY(e, t) {
        return this.normalized && (t = zt(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 1] = t,
        this
    }
    setZ(e, t) {
        return this.normalized && (t = zt(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 2] = t,
        this
    }
    setW(e, t) {
        return this.normalized && (t = zt(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 3] = t,
        this
    }
    getX(e) {
        let t = this.data.array[e * this.data.stride + this.offset];
        return this.normalized && (t = Nt(t, this.array)),
        t
    }
    getY(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 1];
        return this.normalized && (t = Nt(t, this.array)),
        t
    }
    getZ(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 2];
        return this.normalized && (t = Nt(t, this.array)),
        t
    }
    getW(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 3];
        return this.normalized && (t = Nt(t, this.array)),
        t
    }
    setXY(e, t, n) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = zt(t, this.array),
        n = zt(n, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = n,
        this
    }
    setXYZ(e, t, n, i) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = zt(t, this.array),
        n = zt(n, this.array),
        i = zt(i, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = n,
        this.data.array[e + 2] = i,
        this
    }
    setXYZW(e, t, n, i, r) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = zt(t, this.array),
        n = zt(n, this.array),
        i = zt(i, this.array),
        r = zt(r, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = n,
        this.data.array[e + 2] = i,
        this.data.array[e + 3] = r,
        this
    }
    clone(e) {
        if (void 0 === e) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will deinterleave buffer data.");
            const e = [];
            for (let t = 0; t < this.count; t++) {
                const n = t * this.data.stride + this.offset;
                for (let t = 0; t < this.itemSize; t++)
                    e.push(this.data.array[n + t])
            }
            return new Ii(new this.array.constructor(e),this.itemSize,this.normalized)
        }
        return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
        void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
        new uo(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)
    }
    toJSON(e) {
        if (void 0 === e) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will deinterleave buffer data.");
            const e = [];
            for (let t = 0; t < this.count; t++) {
                const n = t * this.data.stride + this.offset;
                for (let t = 0; t < this.itemSize; t++)
                    e.push(this.data.array[n + t])
            }
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: e,
                normalized: this.normalized
            }
        }
        return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
        void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
        {
            isInterleavedBufferAttribute: !0,
            itemSize: this.itemSize,
            data: this.data.uuid,
            offset: this.offset,
            normalized: this.normalized
        }
    }
}
class po extends Ci {
    constructor(e) {
        super(),
        this.isSpriteMaterial = !0,
        this.type = "SpriteMaterial",
        this.color = new en(16777215),
        this.map = null,
        this.alphaMap = null,
        this.rotation = 0,
        this.sizeAttenuation = !0,
        this.transparent = !0,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.rotation = e.rotation,
        this.sizeAttenuation = e.sizeAttenuation,
        this.fog = e.fog,
        this
    }
}
let mo;
const fo = new pn
  , go = new pn
  , vo = new pn
  , xo = new Ft
  , yo = new Ft
  , _o = new Wn
  , bo = new pn
  , Mo = new pn
  , wo = new pn
  , So = new Ft
  , To = new Ft
  , Ao = new Ft;
class Eo extends fi {
    constructor(e) {
        if (super(),
        this.isSprite = !0,
        this.type = "Sprite",
        void 0 === mo) {
            mo = new Vi;
            const e = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1])
              , t = new co(e,5);
            mo.setIndex([0, 1, 2, 0, 2, 3]),
            mo.setAttribute("position", new uo(t,3,0,!1)),
            mo.setAttribute("uv", new uo(t,2,3,!1))
        }
        this.geometry = mo,
        this.material = void 0 !== e ? e : new po,
        this.center = new Ft(.5,.5)
    }
    raycast(e, t) {
        null === e.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),
        go.setFromMatrixScale(this.matrixWorld),
        _o.copy(e.camera.matrixWorld),
        this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld),
        vo.setFromMatrixPosition(this.modelViewMatrix),
        e.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && go.multiplyScalar(-vo.z);
        const n = this.material.rotation;
        let i, r;
        0 !== n && (r = Math.cos(n),
        i = Math.sin(n));
        const s = this.center;
        Co(bo.set(-.5, -.5, 0), vo, s, go, i, r),
        Co(Mo.set(.5, -.5, 0), vo, s, go, i, r),
        Co(wo.set(.5, .5, 0), vo, s, go, i, r),
        So.set(0, 0),
        To.set(1, 0),
        Ao.set(1, 1);
        let a = e.ray.intersectTriangle(bo, Mo, wo, !1, fo);
        if (null === a && (Co(Mo.set(-.5, .5, 0), vo, s, go, i, r),
        To.set(0, 1),
        a = e.ray.intersectTriangle(bo, wo, Mo, !1, fo),
        null === a))
            return;
        const o = e.ray.origin.distanceTo(fo);
        o < e.near || o > e.far || t.push({
            distance: o,
            point: fo.clone(),
            uv: Ai.getUV(fo, bo, Mo, wo, So, To, Ao, new Ft),
            face: null,
            object: this
        })
    }
    copy(e, t) {
        return super.copy(e, t),
        void 0 !== e.center && this.center.copy(e.center),
        this.material = e.material,
        this
    }
}
function Co(e, t, n, i, r, s) {
    xo.subVectors(e, n).addScalar(.5).multiply(i),
    void 0 !== r ? (yo.x = s * xo.x - r * xo.y,
    yo.y = r * xo.x + s * xo.y) : yo.copy(xo),
    e.copy(t),
    e.x += yo.x,
    e.y += yo.y,
    e.applyMatrix4(_o)
}
const Lo = new pn
  , Ro = new pn;
class Po extends fi {
    constructor() {
        super(),
        this._currentLevel = 0,
        this.type = "LOD",
        Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            },
            isLOD: {
                value: !0
            }
        }),
        this.autoUpdate = !0
    }
    copy(e) {
        super.copy(e, !1);
        const t = e.levels;
        for (let e = 0, n = t.length; e < n; e++) {
            const n = t[e];
            this.addLevel(n.object.clone(), n.distance)
        }
        return this.autoUpdate = e.autoUpdate,
        this
    }
    addLevel(e, t=0) {
        t = Math.abs(t);
        const n = this.levels;
        let i;
        for (i = 0; i < n.length && !(t < n[i].distance); i++)
            ;
        return n.splice(i, 0, {
            distance: t,
            object: e
        }),
        this.add(e),
        this
    }
    getCurrentLevel() {
        return this._currentLevel
    }
    getObjectForDistance(e) {
        const t = this.levels;
        if (t.length > 0) {
            let n, i;
            for (n = 1,
            i = t.length; n < i && !(e < t[n].distance); n++)
                ;
            return t[n - 1].object
        }
        return null
    }
    raycast(e, t) {
        if (this.levels.length > 0) {
            Lo.setFromMatrixPosition(this.matrixWorld);
            const n = e.ray.origin.distanceTo(Lo);
            this.getObjectForDistance(n).raycast(e, t)
        }
    }
    update(e) {
        const t = this.levels;
        if (t.length > 1) {
            Lo.setFromMatrixPosition(e.matrixWorld),
            Ro.setFromMatrixPosition(this.matrixWorld);
            const n = Lo.distanceTo(Ro) / e.zoom;
            let i, r;
            for (t[0].object.visible = !0,
            i = 1,
            r = t.length; i < r && n >= t[i].distance; i++)
                t[i - 1].object.visible = !1,
                t[i].object.visible = !0;
            for (this._currentLevel = i - 1; i < r; i++)
                t[i].object.visible = !1
        }
    }
    toJSON(e) {
        const t = super.toJSON(e);
        !1 === this.autoUpdate && (t.object.autoUpdate = !1),
        t.object.levels = [];
        const n = this.levels;
        for (let e = 0, i = n.length; e < i; e++) {
            const i = n[e];
            t.object.levels.push({
                object: i.object.uuid,
                distance: i.distance
            })
        }
        return t
    }
}
const Io = new pn
  , Do = new ln
  , Oo = new ln
  , No = new pn
  , zo = new Wn;
class Uo extends or {
    constructor(e, t) {
        super(e, t),
        this.isSkinnedMesh = !0,
        this.type = "SkinnedMesh",
        this.bindMode = "attached",
        this.bindMatrix = new Wn,
        this.bindMatrixInverse = new Wn
    }
    copy(e, t) {
        return super.copy(e, t),
        this.bindMode = e.bindMode,
        this.bindMatrix.copy(e.bindMatrix),
        this.bindMatrixInverse.copy(e.bindMatrixInverse),
        this.skeleton = e.skeleton,
        this
    }
    bind(e, t) {
        this.skeleton = e,
        void 0 === t && (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        t = this.matrixWorld),
        this.bindMatrix.copy(t),
        this.bindMatrixInverse.copy(t).invert()
    }
    pose() {
        this.skeleton.pose()
    }
    normalizeSkinWeights() {
        const e = new ln
          , t = this.geometry.attributes.skinWeight;
        for (let n = 0, i = t.count; n < i; n++) {
            e.fromBufferAttribute(t, n);
            const i = 1 / e.manhattanLength();
            Infinity !== i ? e.multiplyScalar(i) : e.set(1, 0, 0, 0),
            t.setXYZW(n, e.x, e.y, e.z, e.w)
        }
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
        "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
    }
    boneTransform(e, t) {
        const n = this.skeleton
          , i = this.geometry;
        Do.fromBufferAttribute(i.attributes.skinIndex, e),
        Oo.fromBufferAttribute(i.attributes.skinWeight, e),
        Io.copy(t).applyMatrix4(this.bindMatrix),
        t.set(0, 0, 0);
        for (let e = 0; e < 4; e++) {
            const i = Oo.getComponent(e);
            if (0 !== i) {
                const r = Do.getComponent(e);
                zo.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]),
                t.addScaledVector(No.copy(Io).applyMatrix4(zo), i)
            }
        }
        return t.applyMatrix4(this.bindMatrixInverse)
    }
}
class Fo extends fi {
    constructor() {
        super(),
        this.isBone = !0,
        this.type = "Bone"
    }
}
class Bo extends on {
    constructor(e=null, t=1, n=1, i, r, s, a, o, l=1003, c=1003, h, u) {
        super(null, s, a, o, l, c, i, r, h, u),
        this.isDataTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: n
        },
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
const ko = new Wn
  , Go = new Wn;
class Ho {
    constructor(e=[], t=[]) {
        this.uuid = Ct(),
        this.bones = e.slice(0),
        this.boneInverses = t,
        this.boneMatrices = null,
        this.boneTexture = null,
        this.boneTextureSize = 0,
        this.frame = -1,
        this.init()
    }
    init() {
        const e = this.bones
          , t = this.boneInverses;
        if (this.boneMatrices = new Float32Array(16 * e.length),
        0 === t.length)
            this.calculateInverses();
        else if (e.length !== t.length) {
            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),
            this.boneInverses = [];
            for (let e = 0, t = this.bones.length; e < t; e++)
                this.boneInverses.push(new Wn)
        }
    }
    calculateInverses() {
        this.boneInverses.length = 0;
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const t = new Wn;
            this.bones[e] && t.copy(this.bones[e].matrixWorld).invert(),
            this.boneInverses.push(t)
        }
    }
    pose() {
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const t = this.bones[e];
            t && t.matrixWorld.copy(this.boneInverses[e]).invert()
        }
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const t = this.bones[e];
            t && (t.parent && t.parent.isBone ? (t.matrix.copy(t.parent.matrixWorld).invert(),
            t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld),
            t.matrix.decompose(t.position, t.quaternion, t.scale))
        }
    }
    update() {
        const e = this.bones
          , t = this.boneInverses
          , n = this.boneMatrices
          , i = this.boneTexture;
        for (let i = 0, r = e.length; i < r; i++) {
            const r = e[i] ? e[i].matrixWorld : Go;
            ko.multiplyMatrices(r, t[i]),
            ko.toArray(n, 16 * i)
        }
        null !== i && (i.needsUpdate = !0)
    }
    clone() {
        return new Ho(this.bones,this.boneInverses)
    }
    computeBoneTexture() {
        let e = Math.sqrt(4 * this.bones.length);
        e = Dt(e),
        e = Math.max(e, 4);
        const t = new Float32Array(e * e * 4);
        t.set(this.boneMatrices);
        const n = new Bo(t,e,e,Ie,Le);
        return n.needsUpdate = !0,
        this.boneMatrices = t,
        this.boneTexture = n,
        this.boneTextureSize = e,
        this
    }
    getBoneByName(e) {
        for (let t = 0, n = this.bones.length; t < n; t++) {
            const n = this.bones[t];
            if (n.name === e)
                return n
        }
    }
    dispose() {
        null !== this.boneTexture && (this.boneTexture.dispose(),
        this.boneTexture = null)
    }
    fromJSON(e, t) {
        this.uuid = e.uuid;
        for (let n = 0, i = e.bones.length; n < i; n++) {
            const i = e.bones[n];
            let r = t[i];
            void 0 === r && (console.warn("THREE.Skeleton: No bone found with UUID:", i),
            r = new Fo),
            this.bones.push(r),
            this.boneInverses.push((new Wn).fromArray(e.boneInverses[n]))
        }
        return this.init(),
        this
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.5,
                type: "Skeleton",
                generator: "Skeleton.toJSON"
            },
            bones: [],
            boneInverses: []
        };
        e.uuid = this.uuid;
        const t = this.bones
          , n = this.boneInverses;
        for (let i = 0, r = t.length; i < r; i++) {
            const r = t[i];
            e.bones.push(r.uuid);
            const s = n[i];
            e.boneInverses.push(s.toArray())
        }
        return e
    }
}
class Vo extends Ii {
    constructor(e, t, n, i=1) {
        super(e, t, n),
        this.isInstancedBufferAttribute = !0,
        this.meshPerAttribute = i
    }
    copy(e) {
        return super.copy(e),
        this.meshPerAttribute = e.meshPerAttribute,
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.meshPerAttribute = this.meshPerAttribute,
        e.isInstancedBufferAttribute = !0,
        e
    }
}
const Wo = new Wn
  , jo = new Wn
  , Xo = []
  , qo = new or;
class Yo extends or {
    constructor(e, t, n) {
        super(e, t),
        this.isInstancedMesh = !0,
        this.instanceMatrix = new Vo(new Float32Array(16 * n),16),
        this.instanceColor = null,
        this.count = n,
        this.frustumCulled = !1
    }
    copy(e, t) {
        return super.copy(e, t),
        this.instanceMatrix.copy(e.instanceMatrix),
        null !== e.instanceColor && (this.instanceColor = e.instanceColor.clone()),
        this.count = e.count,
        this
    }
    getColorAt(e, t) {
        t.fromArray(this.instanceColor.array, 3 * e)
    }
    getMatrixAt(e, t) {
        t.fromArray(this.instanceMatrix.array, 16 * e)
    }
    raycast(e, t) {
        const n = this.matrixWorld
          , i = this.count;
        if (qo.geometry = this.geometry,
        qo.material = this.material,
        void 0 !== qo.material)
            for (let r = 0; r < i; r++) {
                this.getMatrixAt(r, Wo),
                jo.multiplyMatrices(n, Wo),
                qo.matrixWorld = jo,
                qo.raycast(e, Xo);
                for (let e = 0, n = Xo.length; e < n; e++) {
                    const n = Xo[e];
                    n.instanceId = r,
                    n.object = this,
                    t.push(n)
                }
                Xo.length = 0
            }
    }
    setColorAt(e, t) {
        null === this.instanceColor && (this.instanceColor = new Vo(new Float32Array(3 * this.instanceMatrix.count),3)),
        t.toArray(this.instanceColor.array, 3 * e)
    }
    setMatrixAt(e, t) {
        t.toArray(this.instanceMatrix.array, 16 * e)
    }
    updateMorphTargets() {}
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
class Zo extends Ci {
    constructor(e) {
        super(),
        this.isLineBasicMaterial = !0,
        this.type = "LineBasicMaterial",
        this.color = new en(16777215),
        this.linewidth = 1,
        this.linecap = "round",
        this.linejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.linewidth = e.linewidth,
        this.linecap = e.linecap,
        this.linejoin = e.linejoin,
        this.fog = e.fog,
        this
    }
}
const Jo = new pn
  , Ko = new pn
  , Qo = new Wn
  , $o = new Vn
  , el = new Nn;
class tl extends fi {
    constructor(e=new Vi, t=new Zo) {
        super(),
        this.isLine = !0,
        this.type = "Line",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.material = e.material,
        this.geometry = e.geometry,
        this
    }
    computeLineDistances() {
        const e = this.geometry;
        if (null === e.index) {
            const t = e.attributes.position
              , n = [0];
            for (let e = 1, i = t.count; e < i; e++)
                Jo.fromBufferAttribute(t, e - 1),
                Ko.fromBufferAttribute(t, e),
                n[e] = n[e - 1],
                n[e] += Jo.distanceTo(Ko);
            e.setAttribute("lineDistance", new Ni(n,1))
        } else
            console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
    raycast(e, t) {
        const n = this.geometry
          , i = this.matrixWorld
          , r = e.params.Line.threshold
          , s = n.drawRange;
        if (null === n.boundingSphere && n.computeBoundingSphere(),
        el.copy(n.boundingSphere),
        el.applyMatrix4(i),
        el.radius += r,
        !1 === e.ray.intersectsSphere(el))
            return;
        Qo.copy(i).invert(),
        $o.copy(e.ray).applyMatrix4(Qo);
        const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3)
          , o = a * a
          , l = new pn
          , c = new pn
          , h = new pn
          , u = new pn
          , d = this.isLineSegments ? 2 : 1
          , p = n.index
          , m = n.attributes.position;
        if (null !== p) {
            for (let n = Math.max(0, s.start), i = Math.min(p.count, s.start + s.count) - 1; n < i; n += d) {
                const i = p.getX(n)
                  , r = p.getX(n + 1);
                l.fromBufferAttribute(m, i),
                c.fromBufferAttribute(m, r);
                if ($o.distanceSqToSegment(l, c, u, h) > o)
                    continue;
                u.applyMatrix4(this.matrixWorld);
                const s = e.ray.origin.distanceTo(u);
                s < e.near || s > e.far || t.push({
                    distance: s,
                    point: h.clone().applyMatrix4(this.matrixWorld),
                    index: n,
                    face: null,
                    faceIndex: null,
                    object: this
                })
            }
        } else {
            for (let n = Math.max(0, s.start), i = Math.min(m.count, s.start + s.count) - 1; n < i; n += d) {
                l.fromBufferAttribute(m, n),
                c.fromBufferAttribute(m, n + 1);
                if ($o.distanceSqToSegment(l, c, u, h) > o)
                    continue;
                u.applyMatrix4(this.matrixWorld);
                const i = e.ray.origin.distanceTo(u);
                i < e.near || i > e.far || t.push({
                    distance: i,
                    point: h.clone().applyMatrix4(this.matrixWorld),
                    index: n,
                    face: null,
                    faceIndex: null,
                    object: this
                })
            }
        }
    }
    updateMorphTargets() {
        const e = this.geometry.morphAttributes
          , t = Object.keys(e);
        if (t.length > 0) {
            const n = e[t[0]];
            if (void 0 !== n) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let e = 0, t = n.length; e < t; e++) {
                    const t = n[e].name || String(e);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[t] = e
                }
            }
        }
    }
}
const nl = new pn
  , il = new pn;
class rl extends tl {
    constructor(e, t) {
        super(e, t),
        this.isLineSegments = !0,
        this.type = "LineSegments"
    }
    computeLineDistances() {
        const e = this.geometry;
        if (null === e.index) {
            const t = e.attributes.position
              , n = [];
            for (let e = 0, i = t.count; e < i; e += 2)
                nl.fromBufferAttribute(t, e),
                il.fromBufferAttribute(t, e + 1),
                n[e] = 0 === e ? 0 : n[e - 1],
                n[e + 1] = n[e] + nl.distanceTo(il);
            e.setAttribute("lineDistance", new Ni(n,1))
        } else
            console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
}
class sl extends tl {
    constructor(e, t) {
        super(e, t),
        this.isLineLoop = !0,
        this.type = "LineLoop"
    }
}
class al extends Ci {
    constructor(e) {
        super(),
        this.isPointsMaterial = !0,
        this.type = "PointsMaterial",
        this.color = new en(16777215),
        this.map = null,
        this.alphaMap = null,
        this.size = 1,
        this.sizeAttenuation = !0,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.size = e.size,
        this.sizeAttenuation = e.sizeAttenuation,
        this.fog = e.fog,
        this
    }
}
const ol = new Wn
  , ll = new Vn
  , cl = new Nn
  , hl = new pn;
class ul extends fi {
    constructor(e=new Vi, t=new al) {
        super(),
        this.isPoints = !0,
        this.type = "Points",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.material = e.material,
        this.geometry = e.geometry,
        this
    }
    raycast(e, t) {
        const n = this.geometry
          , i = this.matrixWorld
          , r = e.params.Points.threshold
          , s = n.drawRange;
        if (null === n.boundingSphere && n.computeBoundingSphere(),
        cl.copy(n.boundingSphere),
        cl.applyMatrix4(i),
        cl.radius += r,
        !1 === e.ray.intersectsSphere(cl))
            return;
        ol.copy(i).invert(),
        ll.copy(e.ray).applyMatrix4(ol);
        const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3)
          , o = a * a
          , l = n.index
          , c = n.attributes.position;
        if (null !== l) {
            for (let n = Math.max(0, s.start), r = Math.min(l.count, s.start + s.count); n < r; n++) {
                const r = l.getX(n);
                hl.fromBufferAttribute(c, r),
                dl(hl, r, o, i, e, t, this)
            }
        } else {
            for (let n = Math.max(0, s.start), r = Math.min(c.count, s.start + s.count); n < r; n++)
                hl.fromBufferAttribute(c, n),
                dl(hl, n, o, i, e, t, this)
        }
    }
    updateMorphTargets() {
        const e = this.geometry.morphAttributes
          , t = Object.keys(e);
        if (t.length > 0) {
            const n = e[t[0]];
            if (void 0 !== n) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let e = 0, t = n.length; e < t; e++) {
                    const t = n[e].name || String(e);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[t] = e
                }
            }
        }
    }
}
function dl(e, t, n, i, r, s, a) {
    const o = ll.distanceSqToPoint(e);
    if (o < n) {
        const n = new pn;
        ll.closestPointToPoint(e, n),
        n.applyMatrix4(i);
        const l = r.ray.origin.distanceTo(n);
        if (l < r.near || l > r.far)
            return;
        s.push({
            distance: l,
            distanceToRay: Math.sqrt(o),
            point: n,
            index: t,
            face: null,
            object: a
        })
    }
}
class pl extends on {
    constructor(e, t, n, i, r, s, a, o, l) {
        super(e, t, n, i, r, s, a, o, l),
        this.isVideoTexture = !0,
        this.minFilter = void 0 !== s ? s : we,
        this.magFilter = void 0 !== r ? r : we,
        this.generateMipmaps = !1;
        const c = this;
        "requestVideoFrameCallback"in e && e.requestVideoFrameCallback((function t() {
            c.needsUpdate = !0,
            e.requestVideoFrameCallback(t)
        }
        ))
    }
    clone() {
        return new this.constructor(this.image).copy(this)
    }
    update() {
        const e = this.image;
        !1 === "requestVideoFrameCallback"in e && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
    }
}
class ml extends on {
    constructor(e, t, n, i, r, s, a, o, l, c, h, u) {
        super(null, s, a, o, l, c, i, r, h, u),
        this.isCompressedTexture = !0,
        this.image = {
            width: t,
            height: n
        },
        this.mipmaps = e,
        this.flipY = !1,
        this.generateMipmaps = !1
    }
}
class fl extends on {
    constructor(e, t, n, i, r, s, a, o, l) {
        super(e, t, n, i, r, s, a, o, l),
        this.isCanvasTexture = !0,
        this.needsUpdate = !0
    }
}
class gl {
    constructor() {
        this.type = "Curve",
        this.arcLengthDivisions = 200
    }
    getPoint() {
        return console.warn("THREE.Curve: .getPoint() not implemented."),
        null
    }
    getPointAt(e, t) {
        const n = this.getUtoTmapping(e);
        return this.getPoint(n, t)
    }
    getPoints(e=5) {
        const t = [];
        for (let n = 0; n <= e; n++)
            t.push(this.getPoint(n / e));
        return t
    }
    getSpacedPoints(e=5) {
        const t = [];
        for (let n = 0; n <= e; n++)
            t.push(this.getPointAt(n / e));
        return t
    }
    getLength() {
        const e = this.getLengths();
        return e[e.length - 1]
    }
    getLengths(e=this.arcLengthDivisions) {
        if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
            return this.cacheArcLengths;
        this.needsUpdate = !1;
        const t = [];
        let n, i = this.getPoint(0), r = 0;
        t.push(0);
        for (let s = 1; s <= e; s++)
            n = this.getPoint(s / e),
            r += n.distanceTo(i),
            t.push(r),
            i = n;
        return this.cacheArcLengths = t,
        t
    }
    updateArcLengths() {
        this.needsUpdate = !0,
        this.getLengths()
    }
    getUtoTmapping(e, t) {
        const n = this.getLengths();
        let i = 0;
        const r = n.length;
        let s;
        s = t || e * n[r - 1];
        let a, o = 0, l = r - 1;
        for (; o <= l; )
            if (i = Math.floor(o + (l - o) / 2),
            a = n[i] - s,
            a < 0)
                o = i + 1;
            else {
                if (!(a > 0)) {
                    l = i;
                    break
                }
                l = i - 1
            }
        if (i = l,
        n[i] === s)
            return i / (r - 1);
        const c = n[i];
        return (i + (s - c) / (n[i + 1] - c)) / (r - 1)
    }
    getTangent(e, t) {
        const n = 1e-4;
        let i = e - n
          , r = e + n;
        i < 0 && (i = 0),
        r > 1 && (r = 1);
        const s = this.getPoint(i)
          , a = this.getPoint(r)
          , o = t || (s.isVector2 ? new Ft : new pn);
        return o.copy(a).sub(s).normalize(),
        o
    }
    getTangentAt(e, t) {
        const n = this.getUtoTmapping(e);
        return this.getTangent(n, t)
    }
    computeFrenetFrames(e, t) {
        const n = new pn
          , i = []
          , r = []
          , s = []
          , a = new pn
          , o = new Wn;
        for (let t = 0; t <= e; t++) {
            const n = t / e;
            i[t] = this.getTangentAt(n, new pn)
        }
        r[0] = new pn,
        s[0] = new pn;
        let l = Number.MAX_VALUE;
        const c = Math.abs(i[0].x)
          , h = Math.abs(i[0].y)
          , u = Math.abs(i[0].z);
        c <= l && (l = c,
        n.set(1, 0, 0)),
        h <= l && (l = h,
        n.set(0, 1, 0)),
        u <= l && n.set(0, 0, 1),
        a.crossVectors(i[0], n).normalize(),
        r[0].crossVectors(i[0], a),
        s[0].crossVectors(i[0], r[0]);
        for (let t = 1; t <= e; t++) {
            if (r[t] = r[t - 1].clone(),
            s[t] = s[t - 1].clone(),
            a.crossVectors(i[t - 1], i[t]),
            a.length() > Number.EPSILON) {
                a.normalize();
                const e = Math.acos(Lt(i[t - 1].dot(i[t]), -1, 1));
                r[t].applyMatrix4(o.makeRotationAxis(a, e))
            }
            s[t].crossVectors(i[t], r[t])
        }
        if (!0 === t) {
            let t = Math.acos(Lt(r[0].dot(r[e]), -1, 1));
            t /= e,
            i[0].dot(a.crossVectors(r[0], r[e])) > 0 && (t = -t);
            for (let n = 1; n <= e; n++)
                r[n].applyMatrix4(o.makeRotationAxis(i[n], t * n)),
                s[n].crossVectors(i[n], r[n])
        }
        return {
            tangents: i,
            normals: r,
            binormals: s
        }
    }
    clone() {
        return (new this.constructor).copy(this)
    }
    copy(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions,
        this
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.5,
                type: "Curve",
                generator: "Curve.toJSON"
            }
        };
        return e.arcLengthDivisions = this.arcLengthDivisions,
        e.type = this.type,
        e
    }
    fromJSON(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions,
        this
    }
}
class vl extends gl {
    constructor(e=0, t=0, n=1, i=1, r=0, s=2 * Math.PI, a=!1, o=0) {
        super(),
        this.isEllipseCurve = !0,
        this.type = "EllipseCurve",
        this.aX = e,
        this.aY = t,
        this.xRadius = n,
        this.yRadius = i,
        this.aStartAngle = r,
        this.aEndAngle = s,
        this.aClockwise = a,
        this.aRotation = o
    }
    getPoint(e, t) {
        const n = t || new Ft
          , i = 2 * Math.PI;
        let r = this.aEndAngle - this.aStartAngle;
        const s = Math.abs(r) < Number.EPSILON;
        for (; r < 0; )
            r += i;
        for (; r > i; )
            r -= i;
        r < Number.EPSILON && (r = s ? 0 : i),
        !0 !== this.aClockwise || s || (r === i ? r = -i : r -= i);
        const a = this.aStartAngle + e * r;
        let o = this.aX + this.xRadius * Math.cos(a)
          , l = this.aY + this.yRadius * Math.sin(a);
        if (0 !== this.aRotation) {
            const e = Math.cos(this.aRotation)
              , t = Math.sin(this.aRotation)
              , n = o - this.aX
              , i = l - this.aY;
            o = n * e - i * t + this.aX,
            l = n * t + i * e + this.aY
        }
        return n.set(o, l)
    }
    copy(e) {
        return super.copy(e),
        this.aX = e.aX,
        this.aY = e.aY,
        this.xRadius = e.xRadius,
        this.yRadius = e.yRadius,
        this.aStartAngle = e.aStartAngle,
        this.aEndAngle = e.aEndAngle,
        this.aClockwise = e.aClockwise,
        this.aRotation = e.aRotation,
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.aX = this.aX,
        e.aY = this.aY,
        e.xRadius = this.xRadius,
        e.yRadius = this.yRadius,
        e.aStartAngle = this.aStartAngle,
        e.aEndAngle = this.aEndAngle,
        e.aClockwise = this.aClockwise,
        e.aRotation = this.aRotation,
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.aX = e.aX,
        this.aY = e.aY,
        this.xRadius = e.xRadius,
        this.yRadius = e.yRadius,
        this.aStartAngle = e.aStartAngle,
        this.aEndAngle = e.aEndAngle,
        this.aClockwise = e.aClockwise,
        this.aRotation = e.aRotation,
        this
    }
}
class xl extends vl {
    constructor(e, t, n, i, r, s) {
        super(e, t, n, n, i, r, s),
        this.isArcCurve = !0,
        this.type = "ArcCurve"
    }
}
function yl() {
    let e = 0
      , t = 0
      , n = 0
      , i = 0;
    function r(r, s, a, o) {
        e = r,
        t = a,
        n = -3 * r + 3 * s - 2 * a - o,
        i = 2 * r - 2 * s + a + o
    }
    return {
        initCatmullRom: function(e, t, n, i, s) {
            r(t, n, s * (n - e), s * (i - t))
        },
        initNonuniformCatmullRom: function(e, t, n, i, s, a, o) {
            let l = (t - e) / s - (n - e) / (s + a) + (n - t) / a
              , c = (n - t) / a - (i - t) / (a + o) + (i - n) / o;
            l *= a,
            c *= a,
            r(t, n, l, c)
        },
        calc: function(r) {
            const s = r * r;
            return e + t * r + n * s + i * (s * r)
        }
    }
}
const _l = new pn
  , bl = new yl
  , Ml = new yl
  , wl = new yl;
class Sl extends gl {
    constructor(e=[], t=!1, n="centripetal", i=.5) {
        super(),
        this.isCatmullRomCurve3 = !0,
        this.type = "CatmullRomCurve3",
        this.points = e,
        this.closed = t,
        this.curveType = n,
        this.tension = i
    }
    getPoint(e, t=new pn) {
        const n = t
          , i = this.points
          , r = i.length
          , s = (r - (this.closed ? 0 : 1)) * e;
        let a, o, l = Math.floor(s), c = s - l;
        this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r : 0 === c && l === r - 1 && (l = r - 2,
        c = 1),
        this.closed || l > 0 ? a = i[(l - 1) % r] : (_l.subVectors(i[0], i[1]).add(i[0]),
        a = _l);
        const h = i[l % r]
          , u = i[(l + 1) % r];
        if (this.closed || l + 2 < r ? o = i[(l + 2) % r] : (_l.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]),
        o = _l),
        "centripetal" === this.curveType || "chordal" === this.curveType) {
            const e = "chordal" === this.curveType ? .5 : .25;
            let t = Math.pow(a.distanceToSquared(h), e)
              , n = Math.pow(h.distanceToSquared(u), e)
              , i = Math.pow(u.distanceToSquared(o), e);
            n < 1e-4 && (n = 1),
            t < 1e-4 && (t = n),
            i < 1e-4 && (i = n),
            bl.initNonuniformCatmullRom(a.x, h.x, u.x, o.x, t, n, i),
            Ml.initNonuniformCatmullRom(a.y, h.y, u.y, o.y, t, n, i),
            wl.initNonuniformCatmullRom(a.z, h.z, u.z, o.z, t, n, i)
        } else
            "catmullrom" === this.curveType && (bl.initCatmullRom(a.x, h.x, u.x, o.x, this.tension),
            Ml.initCatmullRom(a.y, h.y, u.y, o.y, this.tension),
            wl.initCatmullRom(a.z, h.z, u.z, o.z, this.tension));
        return n.set(bl.calc(c), Ml.calc(c), wl.calc(c)),
        n
    }
    copy(e) {
        super.copy(e),
        this.points = [];
        for (let t = 0, n = e.points.length; t < n; t++) {
            const n = e.points[t];
            this.points.push(n.clone())
        }
        return this.closed = e.closed,
        this.curveType = e.curveType,
        this.tension = e.tension,
        this
    }
    toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, n = this.points.length; t < n; t++) {
            const n = this.points[t];
            e.points.push(n.toArray())
        }
        return e.closed = this.closed,
        e.curveType = this.curveType,
        e.tension = this.tension,
        e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.points = [];
        for (let t = 0, n = e.points.length; t < n; t++) {
            const n = e.points[t];
            this.points.push((new pn).fromArray(n))
        }
        return this.closed = e.closed,
        this.curveType = e.curveType,
        this.tension = e.tension,
        this
    }
}
function Tl(e, t, n, i, r) {
    const s = .5 * (i - t)
      , a = .5 * (r - n)
      , o = e * e;
    return (2 * n - 2 * i + s + a) * (e * o) + (-3 * n + 3 * i - 2 * s - a) * o + s * e + n
}
function Al(e, t, n, i) {
    return function(e, t) {
        const n = 1 - e;
        return n * n * t
    }(e, t) + function(e, t) {
        return 2 * (1 - e) * e * t
    }(e, n) + function(e, t) {
        return e * e * t
    }(e, i)
}
function El(e, t, n, i, r) {
    return function(e, t) {
        const n = 1 - e;
        return n * n * n * t
    }(e, t) + function(e, t) {
        const n = 1 - e;
        return 3 * n * n * e * t
    }(e, n) + function(e, t) {
        return 3 * (1 - e) * e * e * t
    }(e, i) + function(e, t) {
        return e * e * e * t
    }(e, r)
}
class Cl extends gl {
    constructor(e=new Ft, t=new Ft, n=new Ft, i=new Ft) {
        super(),
        this.isCubicBezierCurve = !0,
        this.type = "CubicBezierCurve",
        this.v0 = e,
        this.v1 = t,
        this.v2 = n,
        this.v3 = i
    }
    getPoint(e, t=new Ft) {
        const n = t
          , i = this.v0
          , r = this.v1
          , s = this.v2
          , a = this.v3;
        return n.set(El(e, i.x, r.x, s.x, a.x), El(e, i.y, r.y, s.y, a.y)),
        n
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e.v3 = this.v3.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this
    }
}
class Ll extends gl {
    constructor(e=new pn, t=new pn, n=new pn, i=new pn) {
        super(),
        this.isCubicBezierCurve3 = !0,
        this.type = "CubicBezierCurve3",
        this.v0 = e,
        this.v1 = t,
        this.v2 = n,
        this.v3 = i
    }
    getPoint(e, t=new pn) {
        const n = t
          , i = this.v0
          , r = this.v1
          , s = this.v2
          , a = this.v3;
        return n.set(El(e, i.x, r.x, s.x, a.x), El(e, i.y, r.y, s.y, a.y), El(e, i.z, r.z, s.z, a.z)),
        n
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e.v3 = this.v3.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this
    }
}
class Rl extends gl {
    constructor(e=new Ft, t=new Ft) {
        super(),
        this.isLineCurve = !0,
        this.type = "LineCurve",
        this.v1 = e,
        this.v2 = t
    }
    getPoint(e, t=new Ft) {
        const n = t;
        return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1),
        n.multiplyScalar(e).add(this.v1)),
        n
    }
    getPointAt(e, t) {
        return this.getPoint(e, t)
    }
    getTangent(e, t) {
        const n = t || new Ft;
        return n.copy(this.v2).sub(this.v1).normalize(),
        n
    }
    copy(e) {
        return super.copy(e),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class Pl extends gl {
    constructor(e=new pn, t=new pn) {
        super(),
        this.isLineCurve3 = !0,
        this.type = "LineCurve3",
        this.v1 = e,
        this.v2 = t
    }
    getPoint(e, t=new pn) {
        const n = t;
        return 1 === e ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1),
        n.multiplyScalar(e).add(this.v1)),
        n
    }
    getPointAt(e, t) {
        return this.getPoint(e, t)
    }
    copy(e) {
        return super.copy(e),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class Il extends gl {
    constructor(e=new Ft, t=new Ft, n=new Ft) {
        super(),
        this.isQuadraticBezierCurve = !0,
        this.type = "QuadraticBezierCurve",
        this.v0 = e,
        this.v1 = t,
        this.v2 = n
    }
    getPoint(e, t=new Ft) {
        const n = t
          , i = this.v0
          , r = this.v1
          , s = this.v2;
        return n.set(Al(e, i.x, r.x, s.x), Al(e, i.y, r.y, s.y)),
        n
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class Dl extends gl {
    constructor(e=new pn, t=new pn, n=new pn) {
        super(),
        this.isQuadraticBezierCurve3 = !0,
        this.type = "QuadraticBezierCurve3",
        this.v0 = e,
        this.v1 = t,
        this.v2 = n
    }
    getPoint(e, t=new pn) {
        const n = t
          , i = this.v0
          , r = this.v1
          , s = this.v2;
        return n.set(Al(e, i.x, r.x, s.x), Al(e, i.y, r.y, s.y), Al(e, i.z, r.z, s.z)),
        n
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class Ol extends gl {
    constructor(e=[]) {
        super(),
        this.isSplineCurve = !0,
        this.type = "SplineCurve",
        this.points = e
    }
    getPoint(e, t=new Ft) {
        const n = t
          , i = this.points
          , r = (i.length - 1) * e
          , s = Math.floor(r)
          , a = r - s
          , o = i[0 === s ? s : s - 1]
          , l = i[s]
          , c = i[s > i.length - 2 ? i.length - 1 : s + 1]
          , h = i[s > i.length - 3 ? i.length - 1 : s + 2];
        return n.set(Tl(a, o.x, l.x, c.x, h.x), Tl(a, o.y, l.y, c.y, h.y)),
        n
    }
    copy(e) {
        super.copy(e),
        this.points = [];
        for (let t = 0, n = e.points.length; t < n; t++) {
            const n = e.points[t];
            this.points.push(n.clone())
        }
        return this
    }
    toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, n = this.points.length; t < n; t++) {
            const n = this.points[t];
            e.points.push(n.toArray())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.points = [];
        for (let t = 0, n = e.points.length; t < n; t++) {
            const n = e.points[t];
            this.points.push((new Ft).fromArray(n))
        }
        return this
    }
}
var Nl = Object.freeze({
    __proto__: null,
    ArcCurve: xl,
    CatmullRomCurve3: Sl,
    CubicBezierCurve: Cl,
    CubicBezierCurve3: Ll,
    EllipseCurve: vl,
    LineCurve: Rl,
    LineCurve3: Pl,
    QuadraticBezierCurve: Il,
    QuadraticBezierCurve3: Dl,
    SplineCurve: Ol
});
class zl extends gl {
    constructor() {
        super(),
        this.type = "CurvePath",
        this.curves = [],
        this.autoClose = !1
    }
    add(e) {
        this.curves.push(e)
    }
    closePath() {
        const e = this.curves[0].getPoint(0)
          , t = this.curves[this.curves.length - 1].getPoint(1);
        e.equals(t) || this.curves.push(new Rl(t,e))
    }
    getPoint(e, t) {
        const n = e * this.getLength()
          , i = this.getCurveLengths();
        let r = 0;
        for (; r < i.length; ) {
            if (i[r] >= n) {
                const e = i[r] - n
                  , s = this.curves[r]
                  , a = s.getLength()
                  , o = 0 === a ? 0 : 1 - e / a;
                return s.getPointAt(o, t)
            }
            r++
        }
        return null
    }
    getLength() {
        const e = this.getCurveLengths();
        return e[e.length - 1]
    }
    updateArcLengths() {
        this.needsUpdate = !0,
        this.cacheLengths = null,
        this.getCurveLengths()
    }
    getCurveLengths() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
            return this.cacheLengths;
        const e = [];
        let t = 0;
        for (let n = 0, i = this.curves.length; n < i; n++)
            t += this.curves[n].getLength(),
            e.push(t);
        return this.cacheLengths = e,
        e
    }
    getSpacedPoints(e=40) {
        const t = [];
        for (let n = 0; n <= e; n++)
            t.push(this.getPoint(n / e));
        return this.autoClose && t.push(t[0]),
        t
    }
    getPoints(e=12) {
        const t = [];
        let n;
        for (let i = 0, r = this.curves; i < r.length; i++) {
            const s = r[i]
              , a = s.isEllipseCurve ? 2 * e : s.isLineCurve || s.isLineCurve3 ? 1 : s.isSplineCurve ? e * s.points.length : e
              , o = s.getPoints(a);
            for (let e = 0; e < o.length; e++) {
                const i = o[e];
                n && n.equals(i) || (t.push(i),
                n = i)
            }
        }
        return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]),
        t
    }
    copy(e) {
        super.copy(e),
        this.curves = [];
        for (let t = 0, n = e.curves.length; t < n; t++) {
            const n = e.curves[t];
            this.curves.push(n.clone())
        }
        return this.autoClose = e.autoClose,
        this
    }
    toJSON() {
        const e = super.toJSON();
        e.autoClose = this.autoClose,
        e.curves = [];
        for (let t = 0, n = this.curves.length; t < n; t++) {
            const n = this.curves[t];
            e.curves.push(n.toJSON())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.autoClose = e.autoClose,
        this.curves = [];
        for (let t = 0, n = e.curves.length; t < n; t++) {
            const n = e.curves[t];
            this.curves.push((new Nl[n.type]).fromJSON(n))
        }
        return this
    }
}
class Ul extends zl {
    constructor(e) {
        super(),
        this.type = "Path",
        this.currentPoint = new Ft,
        e && this.setFromPoints(e)
    }
    setFromPoints(e) {
        this.moveTo(e[0].x, e[0].y);
        for (let t = 1, n = e.length; t < n; t++)
            this.lineTo(e[t].x, e[t].y);
        return this
    }
    moveTo(e, t) {
        return this.currentPoint.set(e, t),
        this
    }
    lineTo(e, t) {
        const n = new Rl(this.currentPoint.clone(),new Ft(e,t));
        return this.curves.push(n),
        this.currentPoint.set(e, t),
        this
    }
    quadraticCurveTo(e, t, n, i) {
        const r = new Il(this.currentPoint.clone(),new Ft(e,t),new Ft(n,i));
        return this.curves.push(r),
        this.currentPoint.set(n, i),
        this
    }
    bezierCurveTo(e, t, n, i, r, s) {
        const a = new Cl(this.currentPoint.clone(),new Ft(e,t),new Ft(n,i),new Ft(r,s));
        return this.curves.push(a),
        this.currentPoint.set(r, s),
        this
    }
    splineThru(e) {
        const t = [this.currentPoint.clone()].concat(e)
          , n = new Ol(t);
        return this.curves.push(n),
        this.currentPoint.copy(e[e.length - 1]),
        this
    }
    arc(e, t, n, i, r, s) {
        const a = this.currentPoint.x
          , o = this.currentPoint.y;
        return this.absarc(e + a, t + o, n, i, r, s),
        this
    }
    absarc(e, t, n, i, r, s) {
        return this.absellipse(e, t, n, n, i, r, s),
        this
    }
    ellipse(e, t, n, i, r, s, a, o) {
        const l = this.currentPoint.x
          , c = this.currentPoint.y;
        return this.absellipse(e + l, t + c, n, i, r, s, a, o),
        this
    }
    absellipse(e, t, n, i, r, s, a, o) {
        const l = new vl(e,t,n,i,r,s,a,o);
        if (this.curves.length > 0) {
            const e = l.getPoint(0);
            e.equals(this.currentPoint) || this.lineTo(e.x, e.y)
        }
        this.curves.push(l);
        const c = l.getPoint(1);
        return this.currentPoint.copy(c),
        this
    }
    copy(e) {
        return super.copy(e),
        this.currentPoint.copy(e.currentPoint),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.currentPoint = this.currentPoint.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.currentPoint.fromArray(e.currentPoint),
        this
    }
}
class Fl extends Vi {
    constructor(e=[new Ft(0,-.5), new Ft(.5,0), new Ft(0,.5)], t=12, n=0, i=2 * Math.PI) {
        super(),
        this.type = "LatheGeometry",
        this.parameters = {
            points: e,
            segments: t,
            phiStart: n,
            phiLength: i
        },
        t = Math.floor(t),
        i = Lt(i, 0, 2 * Math.PI);
        const r = []
          , s = []
          , a = []
          , o = []
          , l = []
          , c = 1 / t
          , h = new pn
          , u = new Ft
          , d = new pn
          , p = new pn
          , m = new pn;
        let f = 0
          , g = 0;
        for (let t = 0; t <= e.length - 1; t++)
            switch (t) {
            case 0:
                f = e[t + 1].x - e[t].x,
                g = e[t + 1].y - e[t].y,
                d.x = 1 * g,
                d.y = -f,
                d.z = 0 * g,
                m.copy(d),
                d.normalize(),
                o.push(d.x, d.y, d.z);
                break;
            case e.length - 1:
                o.push(m.x, m.y, m.z);
                break;
            default:
                f = e[t + 1].x - e[t].x,
                g = e[t + 1].y - e[t].y,
                d.x = 1 * g,
                d.y = -f,
                d.z = 0 * g,
                p.copy(d),
                d.x += m.x,
                d.y += m.y,
                d.z += m.z,
                d.normalize(),
                o.push(d.x, d.y, d.z),
                m.copy(p)
            }
        for (let r = 0; r <= t; r++) {
            const d = n + r * c * i
              , p = Math.sin(d)
              , m = Math.cos(d);
            for (let n = 0; n <= e.length - 1; n++) {
                h.x = e[n].x * p,
                h.y = e[n].y,
                h.z = e[n].x * m,
                s.push(h.x, h.y, h.z),
                u.x = r / t,
                u.y = n / (e.length - 1),
                a.push(u.x, u.y);
                const i = o[3 * n + 0] * p
                  , c = o[3 * n + 1]
                  , d = o[3 * n + 0] * m;
                l.push(i, c, d)
            }
        }
        for (let n = 0; n < t; n++)
            for (let t = 0; t < e.length - 1; t++) {
                const i = t + n * e.length
                  , s = i
                  , a = i + e.length
                  , o = i + e.length + 1
                  , l = i + 1;
                r.push(s, a, l),
                r.push(o, l, a)
            }
        this.setIndex(r),
        this.setAttribute("position", new Ni(s,3)),
        this.setAttribute("uv", new Ni(a,2)),
        this.setAttribute("normal", new Ni(l,3))
    }
    static fromJSON(e) {
        return new Fl(e.points,e.segments,e.phiStart,e.phiLength)
    }
}
class Bl extends Fl {
    constructor(e=1, t=1, n=4, i=8) {
        const r = new Ul;
        r.absarc(0, -t / 2, e, 1.5 * Math.PI, 0),
        r.absarc(0, t / 2, e, 0, .5 * Math.PI),
        super(r.getPoints(n), i),
        this.type = "CapsuleGeometry",
        this.parameters = {
            radius: e,
            height: t,
            capSegments: n,
            radialSegments: i
        }
    }
    static fromJSON(e) {
        return new Bl(e.radius,e.length,e.capSegments,e.radialSegments)
    }
}
class kl extends Vi {
    constructor(e=1, t=8, n=0, i=2 * Math.PI) {
        super(),
        this.type = "CircleGeometry",
        this.parameters = {
            radius: e,
            segments: t,
            thetaStart: n,
            thetaLength: i
        },
        t = Math.max(3, t);
        const r = []
          , s = []
          , a = []
          , o = []
          , l = new pn
          , c = new Ft;
        s.push(0, 0, 0),
        a.push(0, 0, 1),
        o.push(.5, .5);
        for (let r = 0, h = 3; r <= t; r++,
        h += 3) {
            const u = n + r / t * i;
            l.x = e * Math.cos(u),
            l.y = e * Math.sin(u),
            s.push(l.x, l.y, l.z),
            a.push(0, 0, 1),
            c.x = (s[h] / e + 1) / 2,
            c.y = (s[h + 1] / e + 1) / 2,
            o.push(c.x, c.y)
        }
        for (let e = 1; e <= t; e++)
            r.push(e, e + 1, 0);
        this.setIndex(r),
        this.setAttribute("position", new Ni(s,3)),
        this.setAttribute("normal", new Ni(a,3)),
        this.setAttribute("uv", new Ni(o,2))
    }
    static fromJSON(e) {
        return new kl(e.radius,e.segments,e.thetaStart,e.thetaLength)
    }
}
class Gl extends Vi {
    constructor(e=1, t=1, n=1, i=8, r=1, s=!1, a=0, o=2 * Math.PI) {
        super(),
        this.type = "CylinderGeometry",
        this.parameters = {
            radiusTop: e,
            radiusBottom: t,
            height: n,
            radialSegments: i,
            heightSegments: r,
            openEnded: s,
            thetaStart: a,
            thetaLength: o
        };
        const l = this;
        i = Math.floor(i),
        r = Math.floor(r);
        const c = []
          , h = []
          , u = []
          , d = [];
        let p = 0;
        const m = []
          , f = n / 2;
        let g = 0;
        function v(n) {
            const r = p
              , s = new Ft
              , m = new pn;
            let v = 0;
            const x = !0 === n ? e : t
              , y = !0 === n ? 1 : -1;
            for (let e = 1; e <= i; e++)
                h.push(0, f * y, 0),
                u.push(0, y, 0),
                d.push(.5, .5),
                p++;
            const _ = p;
            for (let e = 0; e <= i; e++) {
                const t = e / i * o + a
                  , n = Math.cos(t)
                  , r = Math.sin(t);
                m.x = x * r,
                m.y = f * y,
                m.z = x * n,
                h.push(m.x, m.y, m.z),
                u.push(0, y, 0),
                s.x = .5 * n + .5,
                s.y = .5 * r * y + .5,
                d.push(s.x, s.y),
                p++
            }
            for (let e = 0; e < i; e++) {
                const t = r + e
                  , i = _ + e;
                !0 === n ? c.push(i, i + 1, t) : c.push(i + 1, i, t),
                v += 3
            }
            l.addGroup(g, v, !0 === n ? 1 : 2),
            g += v
        }
        !function() {
            const s = new pn
              , v = new pn;
            let x = 0;
            const y = (t - e) / n;
            for (let l = 0; l <= r; l++) {
                const c = []
                  , g = l / r
                  , x = g * (t - e) + e;
                for (let e = 0; e <= i; e++) {
                    const t = e / i
                      , r = t * o + a
                      , l = Math.sin(r)
                      , m = Math.cos(r);
                    v.x = x * l,
                    v.y = -g * n + f,
                    v.z = x * m,
                    h.push(v.x, v.y, v.z),
                    s.set(l, y, m).normalize(),
                    u.push(s.x, s.y, s.z),
                    d.push(t, 1 - g),
                    c.push(p++)
                }
                m.push(c)
            }
            for (let e = 0; e < i; e++)
                for (let t = 0; t < r; t++) {
                    const n = m[t][e]
                      , i = m[t + 1][e]
                      , r = m[t + 1][e + 1]
                      , s = m[t][e + 1];
                    c.push(n, i, s),
                    c.push(i, r, s),
                    x += 6
                }
            l.addGroup(g, x, 0),
            g += x
        }(),
        !1 === s && (e > 0 && v(!0),
        t > 0 && v(!1)),
        this.setIndex(c),
        this.setAttribute("position", new Ni(h,3)),
        this.setAttribute("normal", new Ni(u,3)),
        this.setAttribute("uv", new Ni(d,2))
    }
    static fromJSON(e) {
        return new Gl(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)
    }
}
class Hl extends Gl {
    constructor(e=1, t=1, n=8, i=1, r=!1, s=0, a=2 * Math.PI) {
        super(0, e, t, n, i, r, s, a),
        this.type = "ConeGeometry",
        this.parameters = {
            radius: e,
            height: t,
            radialSegments: n,
            heightSegments: i,
            openEnded: r,
            thetaStart: s,
            thetaLength: a
        }
    }
    static fromJSON(e) {
        return new Hl(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)
    }
}
class Vl extends Vi {
    constructor(e=[], t=[], n=1, i=0) {
        super(),
        this.type = "PolyhedronGeometry",
        this.parameters = {
            vertices: e,
            indices: t,
            radius: n,
            detail: i
        };
        const r = []
          , s = [];
        function a(e, t, n, i) {
            const r = i + 1
              , s = [];
            for (let i = 0; i <= r; i++) {
                s[i] = [];
                const a = e.clone().lerp(n, i / r)
                  , o = t.clone().lerp(n, i / r)
                  , l = r - i;
                for (let e = 0; e <= l; e++)
                    s[i][e] = 0 === e && i === r ? a : a.clone().lerp(o, e / l)
            }
            for (let e = 0; e < r; e++)
                for (let t = 0; t < 2 * (r - e) - 1; t++) {
                    const n = Math.floor(t / 2);
                    t % 2 == 0 ? (o(s[e][n + 1]),
                    o(s[e + 1][n]),
                    o(s[e][n])) : (o(s[e][n + 1]),
                    o(s[e + 1][n + 1]),
                    o(s[e + 1][n]))
                }
        }
        function o(e) {
            r.push(e.x, e.y, e.z)
        }
        function l(t, n) {
            const i = 3 * t;
            n.x = e[i + 0],
            n.y = e[i + 1],
            n.z = e[i + 2]
        }
        function c(e, t, n, i) {
            i < 0 && 1 === e.x && (s[t] = e.x - 1),
            0 === n.x && 0 === n.z && (s[t] = i / 2 / Math.PI + .5)
        }
        function h(e) {
            return Math.atan2(e.z, -e.x)
        }
        !function(e) {
            const n = new pn
              , i = new pn
              , r = new pn;
            for (let s = 0; s < t.length; s += 3)
                l(t[s + 0], n),
                l(t[s + 1], i),
                l(t[s + 2], r),
                a(n, i, r, e)
        }(i),
        function(e) {
            const t = new pn;
            for (let n = 0; n < r.length; n += 3)
                t.x = r[n + 0],
                t.y = r[n + 1],
                t.z = r[n + 2],
                t.normalize().multiplyScalar(e),
                r[n + 0] = t.x,
                r[n + 1] = t.y,
                r[n + 2] = t.z
        }(n),
        function() {
            const e = new pn;
            for (let n = 0; n < r.length; n += 3) {
                e.x = r[n + 0],
                e.y = r[n + 1],
                e.z = r[n + 2];
                const i = h(e) / 2 / Math.PI + .5
                  , a = (t = e,
                Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z)) / Math.PI + .5);
                s.push(i, 1 - a)
            }
            var t;
            (function() {
                const e = new pn
                  , t = new pn
                  , n = new pn
                  , i = new pn
                  , a = new Ft
                  , o = new Ft
                  , l = new Ft;
                for (let u = 0, d = 0; u < r.length; u += 9,
                d += 6) {
                    e.set(r[u + 0], r[u + 1], r[u + 2]),
                    t.set(r[u + 3], r[u + 4], r[u + 5]),
                    n.set(r[u + 6], r[u + 7], r[u + 8]),
                    a.set(s[d + 0], s[d + 1]),
                    o.set(s[d + 2], s[d + 3]),
                    l.set(s[d + 4], s[d + 5]),
                    i.copy(e).add(t).add(n).divideScalar(3);
                    const p = h(i);
                    c(a, d + 0, e, p),
                    c(o, d + 2, t, p),
                    c(l, d + 4, n, p)
                }
            }
            )(),
            function() {
                for (let e = 0; e < s.length; e += 6) {
                    const t = s[e + 0]
                      , n = s[e + 2]
                      , i = s[e + 4]
                      , r = Math.max(t, n, i)
                      , a = Math.min(t, n, i);
                    r > .9 && a < .1 && (t < .2 && (s[e + 0] += 1),
                    n < .2 && (s[e + 2] += 1),
                    i < .2 && (s[e + 4] += 1))
                }
            }()
        }(),
        this.setAttribute("position", new Ni(r,3)),
        this.setAttribute("normal", new Ni(r.slice(),3)),
        this.setAttribute("uv", new Ni(s,2)),
        0 === i ? this.computeVertexNormals() : this.normalizeNormals()
    }
    static fromJSON(e) {
        return new Vl(e.vertices,e.indices,e.radius,e.details)
    }
}
class Wl extends Vl {
    constructor(e=1, t=0) {
        const n = (1 + Math.sqrt(5)) / 2
          , i = 1 / n;
        super([-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, 0, -n, 0, -i, n, 0, -i, -n, 0, i, n, 0, i], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t),
        this.type = "DodecahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new Wl(e.radius,e.detail)
    }
}
const jl = new pn
  , Xl = new pn
  , ql = new pn
  , Yl = new Ai;
class Zl extends Vi {
    constructor(e=null, t=1) {
        if (super(),
        this.type = "EdgesGeometry",
        this.parameters = {
            geometry: e,
            thresholdAngle: t
        },
        null !== e) {
            const n = 4
              , i = Math.pow(10, n)
              , r = Math.cos(At * t)
              , s = e.getIndex()
              , a = e.getAttribute("position")
              , o = s ? s.count : a.count
              , l = [0, 0, 0]
              , c = ["a", "b", "c"]
              , h = new Array(3)
              , u = {}
              , d = [];
            for (let e = 0; e < o; e += 3) {
                s ? (l[0] = s.getX(e),
                l[1] = s.getX(e + 1),
                l[2] = s.getX(e + 2)) : (l[0] = e,
                l[1] = e + 1,
                l[2] = e + 2);
                const {a: t, b: n, c: o} = Yl;
                if (t.fromBufferAttribute(a, l[0]),
                n.fromBufferAttribute(a, l[1]),
                o.fromBufferAttribute(a, l[2]),
                Yl.getNormal(ql),
                h[0] = `${Math.round(t.x * i)},${Math.round(t.y * i)},${Math.round(t.z * i)}`,
                h[1] = `${Math.round(n.x * i)},${Math.round(n.y * i)},${Math.round(n.z * i)}`,
                h[2] = `${Math.round(o.x * i)},${Math.round(o.y * i)},${Math.round(o.z * i)}`,
                h[0] !== h[1] && h[1] !== h[2] && h[2] !== h[0])
                    for (let e = 0; e < 3; e++) {
                        const t = (e + 1) % 3
                          , n = h[e]
                          , i = h[t]
                          , s = Yl[c[e]]
                          , a = Yl[c[t]]
                          , o = `${n}_${i}`
                          , p = `${i}_${n}`;
                        p in u && u[p] ? (ql.dot(u[p].normal) <= r && (d.push(s.x, s.y, s.z),
                        d.push(a.x, a.y, a.z)),
                        u[p] = null) : o in u || (u[o] = {
                            index0: l[e],
                            index1: l[t],
                            normal: ql.clone()
                        })
                    }
            }
            for (const e in u)
                if (u[e]) {
                    const {index0: t, index1: n} = u[e];
                    jl.fromBufferAttribute(a, t),
                    Xl.fromBufferAttribute(a, n),
                    d.push(jl.x, jl.y, jl.z),
                    d.push(Xl.x, Xl.y, Xl.z)
                }
            this.setAttribute("position", new Ni(d,3))
        }
    }
}
class Jl extends Ul {
    constructor(e) {
        super(e),
        this.uuid = Ct(),
        this.type = "Shape",
        this.holes = []
    }
    getPointsHoles(e) {
        const t = [];
        for (let n = 0, i = this.holes.length; n < i; n++)
            t[n] = this.holes[n].getPoints(e);
        return t
    }
    extractPoints(e) {
        return {
            shape: this.getPoints(e),
            holes: this.getPointsHoles(e)
        }
    }
    copy(e) {
        super.copy(e),
        this.holes = [];
        for (let t = 0, n = e.holes.length; t < n; t++) {
            const n = e.holes[t];
            this.holes.push(n.clone())
        }
        return this
    }
    toJSON() {
        const e = super.toJSON();
        e.uuid = this.uuid,
        e.holes = [];
        for (let t = 0, n = this.holes.length; t < n; t++) {
            const n = this.holes[t];
            e.holes.push(n.toJSON())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.uuid = e.uuid,
        this.holes = [];
        for (let t = 0, n = e.holes.length; t < n; t++) {
            const n = e.holes[t];
            this.holes.push((new Ul).fromJSON(n))
        }
        return this
    }
}
const Kl = function(e, t, n=2) {
    const i = t && t.length
      , r = i ? t[0] * n : e.length;
    let s = Ql(e, 0, r, n, !0);
    const a = [];
    if (!s || s.next === s.prev)
        return a;
    let o, l, c, h, u, d, p;
    if (i && (s = function(e, t, n, i) {
        const r = [];
        let s, a, o, l, c;
        for (s = 0,
        a = t.length; s < a; s++)
            o = t[s] * i,
            l = s < a - 1 ? t[s + 1] * i : e.length,
            c = Ql(e, o, l, i, !1),
            c === c.next && (c.steiner = !0),
            r.push(cc(c));
        for (r.sort(sc),
        s = 0; s < r.length; s++)
            ac(r[s], n),
            n = $l(n, n.next);
        return n
    }(e, t, s, n)),
    e.length > 80 * n) {
        o = c = e[0],
        l = h = e[1];
        for (let t = n; t < r; t += n)
            u = e[t],
            d = e[t + 1],
            u < o && (o = u),
            d < l && (l = d),
            u > c && (c = u),
            d > h && (h = d);
        p = Math.max(c - o, h - l),
        p = 0 !== p ? 1 / p : 0
    }
    return ec(s, a, n, o, l, p),
    a
};
function Ql(e, t, n, i, r) {
    let s, a;
    if (r === function(e, t, n, i) {
        let r = 0;
        for (let s = t, a = n - i; s < n; s += i)
            r += (e[a] - e[s]) * (e[s + 1] + e[a + 1]),
            a = s;
        return r
    }(e, t, n, i) > 0)
        for (s = t; s < n; s += i)
            a = yc(s, e[s], e[s + 1], a);
    else
        for (s = n - i; s >= t; s -= i)
            a = yc(s, e[s], e[s + 1], a);
    return a && pc(a, a.next) && (_c(a),
    a = a.next),
    a
}
function $l(e, t) {
    if (!e)
        return e;
    t || (t = e);
    let n, i = e;
    do {
        if (n = !1,
        i.steiner || !pc(i, i.next) && 0 !== dc(i.prev, i, i.next))
            i = i.next;
        else {
            if (_c(i),
            i = t = i.prev,
            i === i.next)
                break;
            n = !0
        }
    } while (n || i !== t);
    return t
}
function ec(e, t, n, i, r, s, a) {
    if (!e)
        return;
    !a && s && function(e, t, n, i) {
        let r = e;
        do {
            null === r.z && (r.z = lc(r.x, r.y, t, n, i)),
            r.prevZ = r.prev,
            r.nextZ = r.next,
            r = r.next
        } while (r !== e);
        r.prevZ.nextZ = null,
        r.prevZ = null,
        function(e) {
            let t, n, i, r, s, a, o, l, c = 1;
            do {
                for (n = e,
                e = null,
                s = null,
                a = 0; n; ) {
                    for (a++,
                    i = n,
                    o = 0,
                    t = 0; t < c && (o++,
                    i = i.nextZ,
                    i); t++)
                        ;
                    for (l = c; o > 0 || l > 0 && i; )
                        0 !== o && (0 === l || !i || n.z <= i.z) ? (r = n,
                        n = n.nextZ,
                        o--) : (r = i,
                        i = i.nextZ,
                        l--),
                        s ? s.nextZ = r : e = r,
                        r.prevZ = s,
                        s = r;
                    n = i
                }
                s.nextZ = null,
                c *= 2
            } while (a > 1)
        }(r)
    }(e, i, r, s);
    let o, l, c = e;
    for (; e.prev !== e.next; )
        if (o = e.prev,
        l = e.next,
        s ? nc(e, i, r, s) : tc(e))
            t.push(o.i / n),
            t.push(e.i / n),
            t.push(l.i / n),
            _c(e),
            e = l.next,
            c = l.next;
        else if ((e = l) === c) {
            a ? 1 === a ? ec(e = ic($l(e), t, n), t, n, i, r, s, 2) : 2 === a && rc(e, t, n, i, r, s) : ec($l(e), t, n, i, r, s, 1);
            break
        }
}
function tc(e) {
    const t = e.prev
      , n = e
      , i = e.next;
    if (dc(t, n, i) >= 0)
        return !1;
    let r = e.next.next;
    for (; r !== e.prev; ) {
        if (hc(t.x, t.y, n.x, n.y, i.x, i.y, r.x, r.y) && dc(r.prev, r, r.next) >= 0)
            return !1;
        r = r.next
    }
    return !0
}
function nc(e, t, n, i) {
    const r = e.prev
      , s = e
      , a = e.next;
    if (dc(r, s, a) >= 0)
        return !1;
    const o = r.x < s.x ? r.x < a.x ? r.x : a.x : s.x < a.x ? s.x : a.x
      , l = r.y < s.y ? r.y < a.y ? r.y : a.y : s.y < a.y ? s.y : a.y
      , c = r.x > s.x ? r.x > a.x ? r.x : a.x : s.x > a.x ? s.x : a.x
      , h = r.y > s.y ? r.y > a.y ? r.y : a.y : s.y > a.y ? s.y : a.y
      , u = lc(o, l, t, n, i)
      , d = lc(c, h, t, n, i);
    let p = e.prevZ
      , m = e.nextZ;
    for (; p && p.z >= u && m && m.z <= d; ) {
        if (p !== e.prev && p !== e.next && hc(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) && dc(p.prev, p, p.next) >= 0)
            return !1;
        if (p = p.prevZ,
        m !== e.prev && m !== e.next && hc(r.x, r.y, s.x, s.y, a.x, a.y, m.x, m.y) && dc(m.prev, m, m.next) >= 0)
            return !1;
        m = m.nextZ
    }
    for (; p && p.z >= u; ) {
        if (p !== e.prev && p !== e.next && hc(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) && dc(p.prev, p, p.next) >= 0)
            return !1;
        p = p.prevZ
    }
    for (; m && m.z <= d; ) {
        if (m !== e.prev && m !== e.next && hc(r.x, r.y, s.x, s.y, a.x, a.y, m.x, m.y) && dc(m.prev, m, m.next) >= 0)
            return !1;
        m = m.nextZ
    }
    return !0
}
function ic(e, t, n) {
    let i = e;
    do {
        const r = i.prev
          , s = i.next.next;
        !pc(r, s) && mc(r, i, i.next, s) && vc(r, s) && vc(s, r) && (t.push(r.i / n),
        t.push(i.i / n),
        t.push(s.i / n),
        _c(i),
        _c(i.next),
        i = e = s),
        i = i.next
    } while (i !== e);
    return $l(i)
}
function rc(e, t, n, i, r, s) {
    let a = e;
    do {
        let e = a.next.next;
        for (; e !== a.prev; ) {
            if (a.i !== e.i && uc(a, e)) {
                let o = xc(a, e);
                return a = $l(a, a.next),
                o = $l(o, o.next),
                ec(a, t, n, i, r, s),
                void ec(o, t, n, i, r, s)
            }
            e = e.next
        }
        a = a.next
    } while (a !== e)
}
function sc(e, t) {
    return e.x - t.x
}
function ac(e, t) {
    if (t = function(e, t) {
        let n = t;
        const i = e.x
          , r = e.y;
        let s, a = -Infinity;
        do {
            if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
                const e = n.x + (r - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                if (e <= i && e > a) {
                    if (a = e,
                    e === i) {
                        if (r === n.y)
                            return n;
                        if (r === n.next.y)
                            return n.next
                    }
                    s = n.x < n.next.x ? n : n.next
                }
            }
            n = n.next
        } while (n !== t);
        if (!s)
            return null;
        if (i === a)
            return s;
        const o = s
          , l = s.x
          , c = s.y;
        let h, u = Infinity;
        n = s;
        do {
            i >= n.x && n.x >= l && i !== n.x && hc(r < c ? i : a, r, l, c, r < c ? a : i, r, n.x, n.y) && (h = Math.abs(r - n.y) / (i - n.x),
            vc(n, e) && (h < u || h === u && (n.x > s.x || n.x === s.x && oc(s, n))) && (s = n,
            u = h)),
            n = n.next
        } while (n !== o);
        return s
    }(e, t),
    t) {
        const n = xc(t, e);
        $l(t, t.next),
        $l(n, n.next)
    }
}
function oc(e, t) {
    return dc(e.prev, e, t.prev) < 0 && dc(t.next, e, e.next) < 0
}
function lc(e, t, n, i, r) {
    return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
}
function cc(e) {
    let t = e
      , n = e;
    do {
        (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t),
        t = t.next
    } while (t !== e);
    return n
}
function hc(e, t, n, i, r, s, a, o) {
    return (r - a) * (t - o) - (e - a) * (s - o) >= 0 && (e - a) * (i - o) - (n - a) * (t - o) >= 0 && (n - a) * (s - o) - (r - a) * (i - o) >= 0
}
function uc(e, t) {
    return e.next.i !== t.i && e.prev.i !== t.i && !function(e, t) {
        let n = e;
        do {
            if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && mc(n, n.next, e, t))
                return !0;
            n = n.next
        } while (n !== e);
        return !1
    }(e, t) && (vc(e, t) && vc(t, e) && function(e, t) {
        let n = e
          , i = !1;
        const r = (e.x + t.x) / 2
          , s = (e.y + t.y) / 2;
        do {
            n.y > s != n.next.y > s && n.next.y !== n.y && r < (n.next.x - n.x) * (s - n.y) / (n.next.y - n.y) + n.x && (i = !i),
            n = n.next
        } while (n !== e);
        return i
    }(e, t) && (dc(e.prev, e, t.prev) || dc(e, t.prev, t)) || pc(e, t) && dc(e.prev, e, e.next) > 0 && dc(t.prev, t, t.next) > 0)
}
function dc(e, t, n) {
    return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y)
}
function pc(e, t) {
    return e.x === t.x && e.y === t.y
}
function mc(e, t, n, i) {
    const r = gc(dc(e, t, n))
      , s = gc(dc(e, t, i))
      , a = gc(dc(n, i, e))
      , o = gc(dc(n, i, t));
    return r !== s && a !== o || (!(0 !== r || !fc(e, n, t)) || (!(0 !== s || !fc(e, i, t)) || (!(0 !== a || !fc(n, e, i)) || !(0 !== o || !fc(n, t, i)))))
}
function fc(e, t, n) {
    return t.x <= Math.max(e.x, n.x) && t.x >= Math.min(e.x, n.x) && t.y <= Math.max(e.y, n.y) && t.y >= Math.min(e.y, n.y)
}
function gc(e) {
    return e > 0 ? 1 : e < 0 ? -1 : 0
}
function vc(e, t) {
    return dc(e.prev, e, e.next) < 0 ? dc(e, t, e.next) >= 0 && dc(e, e.prev, t) >= 0 : dc(e, t, e.prev) < 0 || dc(e, e.next, t) < 0
}
function xc(e, t) {
    const n = new bc(e.i,e.x,e.y)
      , i = new bc(t.i,t.x,t.y)
      , r = e.next
      , s = t.prev;
    return e.next = t,
    t.prev = e,
    n.next = r,
    r.prev = n,
    i.next = n,
    n.prev = i,
    s.next = i,
    i.prev = s,
    i
}
function yc(e, t, n, i) {
    const r = new bc(e,t,n);
    return i ? (r.next = i.next,
    r.prev = i,
    i.next.prev = r,
    i.next = r) : (r.prev = r,
    r.next = r),
    r
}
function _c(e) {
    e.next.prev = e.prev,
    e.prev.next = e.next,
    e.prevZ && (e.prevZ.nextZ = e.nextZ),
    e.nextZ && (e.nextZ.prevZ = e.prevZ)
}
function bc(e, t, n) {
    this.i = e,
    this.x = t,
    this.y = n,
    this.prev = null,
    this.next = null,
    this.z = null,
    this.prevZ = null,
    this.nextZ = null,
    this.steiner = !1
}
class Mc {
    static area(e) {
        const t = e.length;
        let n = 0;
        for (let i = t - 1, r = 0; r < t; i = r++)
            n += e[i].x * e[r].y - e[r].x * e[i].y;
        return .5 * n
    }
    static isClockWise(e) {
        return Mc.area(e) < 0
    }
    static triangulateShape(e, t) {
        const n = []
          , i = []
          , r = [];
        wc(e),
        Sc(n, e);
        let s = e.length;
        t.forEach(wc);
        for (let e = 0; e < t.length; e++)
            i.push(s),
            s += t[e].length,
            Sc(n, t[e]);
        const a = Kl(n, i);
        for (let e = 0; e < a.length; e += 3)
            r.push(a.slice(e, e + 3));
        return r
    }
}
function wc(e) {
    const t = e.length;
    t > 2 && e[t - 1].equals(e[0]) && e.pop()
}
function Sc(e, t) {
    for (let n = 0; n < t.length; n++)
        e.push(t[n].x),
        e.push(t[n].y)
}
class Tc extends Vi {
    constructor(e=new Jl([new Ft(.5,.5), new Ft(-.5,.5), new Ft(-.5,-.5), new Ft(.5,-.5)]), t={}) {
        super(),
        this.type = "ExtrudeGeometry",
        this.parameters = {
            shapes: e,
            options: t
        },
        e = Array.isArray(e) ? e : [e];
        const n = this
          , i = []
          , r = [];
        for (let t = 0, n = e.length; t < n; t++) {
            s(e[t])
        }
        function s(e) {
            const s = []
              , a = void 0 !== t.curveSegments ? t.curveSegments : 12
              , o = void 0 !== t.steps ? t.steps : 1
              , l = void 0 !== t.depth ? t.depth : 1;
            let c = void 0 === t.bevelEnabled || t.bevelEnabled
              , h = void 0 !== t.bevelThickness ? t.bevelThickness : .2
              , u = void 0 !== t.bevelSize ? t.bevelSize : h - .1
              , d = void 0 !== t.bevelOffset ? t.bevelOffset : 0
              , p = void 0 !== t.bevelSegments ? t.bevelSegments : 3;
            const m = t.extrudePath
              , f = void 0 !== t.UVGenerator ? t.UVGenerator : Ac;
            let g, v, x, y, _, b = !1;
            m && (g = m.getSpacedPoints(o),
            b = !0,
            c = !1,
            v = m.computeFrenetFrames(o, !1),
            x = new pn,
            y = new pn,
            _ = new pn),
            c || (p = 0,
            h = 0,
            u = 0,
            d = 0);
            const M = e.extractPoints(a);
            let w = M.shape;
            const S = M.holes;
            if (!Mc.isClockWise(w)) {
                w = w.reverse();
                for (let e = 0, t = S.length; e < t; e++) {
                    const t = S[e];
                    Mc.isClockWise(t) && (S[e] = t.reverse())
                }
            }
            const T = Mc.triangulateShape(w, S)
              , A = w;
            for (let e = 0, t = S.length; e < t; e++) {
                const t = S[e];
                w = w.concat(t)
            }
            function E(e, t, n) {
                return t || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                t.clone().multiplyScalar(n).add(e)
            }
            const C = w.length
              , L = T.length;
            function R(e, t, n) {
                let i, r, s;
                const a = e.x - t.x
                  , o = e.y - t.y
                  , l = n.x - e.x
                  , c = n.y - e.y
                  , h = a * a + o * o
                  , u = a * c - o * l;
                if (Math.abs(u) > Number.EPSILON) {
                    const u = Math.sqrt(h)
                      , d = Math.sqrt(l * l + c * c)
                      , p = t.x - o / u
                      , m = t.y + a / u
                      , f = ((n.x - c / d - p) * c - (n.y + l / d - m) * l) / (a * c - o * l);
                    i = p + a * f - e.x,
                    r = m + o * f - e.y;
                    const g = i * i + r * r;
                    if (g <= 2)
                        return new Ft(i,r);
                    s = Math.sqrt(g / 2)
                } else {
                    let e = !1;
                    a > Number.EPSILON ? l > Number.EPSILON && (e = !0) : a < -Number.EPSILON ? l < -Number.EPSILON && (e = !0) : Math.sign(o) === Math.sign(c) && (e = !0),
                    e ? (i = -o,
                    r = a,
                    s = Math.sqrt(h)) : (i = a,
                    r = o,
                    s = Math.sqrt(h / 2))
                }
                return new Ft(i / s,r / s)
            }
            const P = [];
            for (let e = 0, t = A.length, n = t - 1, i = e + 1; e < t; e++,
            n++,
            i++)
                n === t && (n = 0),
                i === t && (i = 0),
                P[e] = R(A[e], A[n], A[i]);
            const I = [];
            let D, O = P.concat();
            for (let e = 0, t = S.length; e < t; e++) {
                const t = S[e];
                D = [];
                for (let e = 0, n = t.length, i = n - 1, r = e + 1; e < n; e++,
                i++,
                r++)
                    i === n && (i = 0),
                    r === n && (r = 0),
                    D[e] = R(t[e], t[i], t[r]);
                I.push(D),
                O = O.concat(D)
            }
            for (let e = 0; e < p; e++) {
                const t = e / p
                  , n = h * Math.cos(t * Math.PI / 2)
                  , i = u * Math.sin(t * Math.PI / 2) + d;
                for (let e = 0, t = A.length; e < t; e++) {
                    const t = E(A[e], P[e], i);
                    U(t.x, t.y, -n)
                }
                for (let e = 0, t = S.length; e < t; e++) {
                    const t = S[e];
                    D = I[e];
                    for (let e = 0, r = t.length; e < r; e++) {
                        const r = E(t[e], D[e], i);
                        U(r.x, r.y, -n)
                    }
                }
            }
            const N = u + d;
            for (let e = 0; e < C; e++) {
                const t = c ? E(w[e], O[e], N) : w[e];
                b ? (y.copy(v.normals[0]).multiplyScalar(t.x),
                x.copy(v.binormals[0]).multiplyScalar(t.y),
                _.copy(g[0]).add(y).add(x),
                U(_.x, _.y, _.z)) : U(t.x, t.y, 0)
            }
            for (let e = 1; e <= o; e++)
                for (let t = 0; t < C; t++) {
                    const n = c ? E(w[t], O[t], N) : w[t];
                    b ? (y.copy(v.normals[e]).multiplyScalar(n.x),
                    x.copy(v.binormals[e]).multiplyScalar(n.y),
                    _.copy(g[e]).add(y).add(x),
                    U(_.x, _.y, _.z)) : U(n.x, n.y, l / o * e)
                }
            for (let e = p - 1; e >= 0; e--) {
                const t = e / p
                  , n = h * Math.cos(t * Math.PI / 2)
                  , i = u * Math.sin(t * Math.PI / 2) + d;
                for (let e = 0, t = A.length; e < t; e++) {
                    const t = E(A[e], P[e], i);
                    U(t.x, t.y, l + n)
                }
                for (let e = 0, t = S.length; e < t; e++) {
                    const t = S[e];
                    D = I[e];
                    for (let e = 0, r = t.length; e < r; e++) {
                        const r = E(t[e], D[e], i);
                        b ? U(r.x, r.y + g[o - 1].y, g[o - 1].x + n) : U(r.x, r.y, l + n)
                    }
                }
            }
            function z(e, t) {
                let n = e.length;
                for (; --n >= 0; ) {
                    const i = n;
                    let r = n - 1;
                    r < 0 && (r = e.length - 1);
                    for (let e = 0, n = o + 2 * p; e < n; e++) {
                        const n = C * e
                          , s = C * (e + 1);
                        B(t + i + n, t + r + n, t + r + s, t + i + s)
                    }
                }
            }
            function U(e, t, n) {
                s.push(e),
                s.push(t),
                s.push(n)
            }
            function F(e, t, r) {
                k(e),
                k(t),
                k(r);
                const s = i.length / 3
                  , a = f.generateTopUV(n, i, s - 3, s - 2, s - 1);
                G(a[0]),
                G(a[1]),
                G(a[2])
            }
            function B(e, t, r, s) {
                k(e),
                k(t),
                k(s),
                k(t),
                k(r),
                k(s);
                const a = i.length / 3
                  , o = f.generateSideWallUV(n, i, a - 6, a - 3, a - 2, a - 1);
                G(o[0]),
                G(o[1]),
                G(o[3]),
                G(o[1]),
                G(o[2]),
                G(o[3])
            }
            function k(e) {
                i.push(s[3 * e + 0]),
                i.push(s[3 * e + 1]),
                i.push(s[3 * e + 2])
            }
            function G(e) {
                r.push(e.x),
                r.push(e.y)
            }
            !function() {
                const e = i.length / 3;
                if (c) {
                    let e = 0
                      , t = C * e;
                    for (let e = 0; e < L; e++) {
                        const n = T[e];
                        F(n[2] + t, n[1] + t, n[0] + t)
                    }
                    e = o + 2 * p,
                    t = C * e;
                    for (let e = 0; e < L; e++) {
                        const n = T[e];
                        F(n[0] + t, n[1] + t, n[2] + t)
                    }
                } else {
                    for (let e = 0; e < L; e++) {
                        const t = T[e];
                        F(t[2], t[1], t[0])
                    }
                    for (let e = 0; e < L; e++) {
                        const t = T[e];
                        F(t[0] + C * o, t[1] + C * o, t[2] + C * o)
                    }
                }
                n.addGroup(e, i.length / 3 - e, 0)
            }(),
            function() {
                const e = i.length / 3;
                let t = 0;
                z(A, t),
                t += A.length;
                for (let e = 0, n = S.length; e < n; e++) {
                    const n = S[e];
                    z(n, t),
                    t += n.length
                }
                n.addGroup(e, i.length / 3 - e, 1)
            }()
        }
        this.setAttribute("position", new Ni(i,3)),
        this.setAttribute("uv", new Ni(r,2)),
        this.computeVertexNormals()
    }
    toJSON() {
        const e = super.toJSON();
        return function(e, t, n) {
            if (n.shapes = [],
            Array.isArray(e))
                for (let t = 0, i = e.length; t < i; t++) {
                    const i = e[t];
                    n.shapes.push(i.uuid)
                }
            else
                n.shapes.push(e.uuid);
            n.options = Object.assign({}, t),
            void 0 !== t.extrudePath && (n.options.extrudePath = t.extrudePath.toJSON());
            return n
        }(this.parameters.shapes, this.parameters.options, e)
    }
    static fromJSON(e, t) {
        const n = [];
        for (let i = 0, r = e.shapes.length; i < r; i++) {
            const r = t[e.shapes[i]];
            n.push(r)
        }
        const i = e.options.extrudePath;
        return void 0 !== i && (e.options.extrudePath = (new Nl[i.type]).fromJSON(i)),
        new Tc(n,e.options)
    }
}
const Ac = {
    generateTopUV: function(e, t, n, i, r) {
        const s = t[3 * n]
          , a = t[3 * n + 1]
          , o = t[3 * i]
          , l = t[3 * i + 1]
          , c = t[3 * r]
          , h = t[3 * r + 1];
        return [new Ft(s,a), new Ft(o,l), new Ft(c,h)]
    },
    generateSideWallUV: function(e, t, n, i, r, s) {
        const a = t[3 * n]
          , o = t[3 * n + 1]
          , l = t[3 * n + 2]
          , c = t[3 * i]
          , h = t[3 * i + 1]
          , u = t[3 * i + 2]
          , d = t[3 * r]
          , p = t[3 * r + 1]
          , m = t[3 * r + 2]
          , f = t[3 * s]
          , g = t[3 * s + 1]
          , v = t[3 * s + 2];
        return Math.abs(o - h) < Math.abs(a - c) ? [new Ft(a,1 - l), new Ft(c,1 - u), new Ft(d,1 - m), new Ft(f,1 - v)] : [new Ft(o,1 - l), new Ft(h,1 - u), new Ft(p,1 - m), new Ft(g,1 - v)]
    }
};
class Ec extends Vl {
    constructor(e=1, t=0) {
        const n = (1 + Math.sqrt(5)) / 2;
        super([-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t),
        this.type = "IcosahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new Ec(e.radius,e.detail)
    }
}
class Cc extends Vl {
    constructor(e=1, t=0) {
        super([1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t),
        this.type = "OctahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new Cc(e.radius,e.detail)
    }
}
class Lc extends Vi {
    constructor(e=.5, t=1, n=8, i=1, r=0, s=2 * Math.PI) {
        super(),
        this.type = "RingGeometry",
        this.parameters = {
            innerRadius: e,
            outerRadius: t,
            thetaSegments: n,
            phiSegments: i,
            thetaStart: r,
            thetaLength: s
        },
        n = Math.max(3, n);
        const a = []
          , o = []
          , l = []
          , c = [];
        let h = e;
        const u = (t - e) / (i = Math.max(1, i))
          , d = new pn
          , p = new Ft;
        for (let e = 0; e <= i; e++) {
            for (let e = 0; e <= n; e++) {
                const i = r + e / n * s;
                d.x = h * Math.cos(i),
                d.y = h * Math.sin(i),
                o.push(d.x, d.y, d.z),
                l.push(0, 0, 1),
                p.x = (d.x / t + 1) / 2,
                p.y = (d.y / t + 1) / 2,
                c.push(p.x, p.y)
            }
            h += u
        }
        for (let e = 0; e < i; e++) {
            const t = e * (n + 1);
            for (let e = 0; e < n; e++) {
                const i = e + t
                  , r = i
                  , s = i + n + 1
                  , o = i + n + 2
                  , l = i + 1;
                a.push(r, s, l),
                a.push(s, o, l)
            }
        }
        this.setIndex(a),
        this.setAttribute("position", new Ni(o,3)),
        this.setAttribute("normal", new Ni(l,3)),
        this.setAttribute("uv", new Ni(c,2))
    }
    static fromJSON(e) {
        return new Lc(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)
    }
}
class Rc extends Vi {
    constructor(e=new Jl([new Ft(0,.5), new Ft(-.5,-.5), new Ft(.5,-.5)]), t=12) {
        super(),
        this.type = "ShapeGeometry",
        this.parameters = {
            shapes: e,
            curveSegments: t
        };
        const n = []
          , i = []
          , r = []
          , s = [];
        let a = 0
          , o = 0;
        if (!1 === Array.isArray(e))
            l(e);
        else
            for (let t = 0; t < e.length; t++)
                l(e[t]),
                this.addGroup(a, o, t),
                a += o,
                o = 0;
        function l(e) {
            const a = i.length / 3
              , l = e.extractPoints(t);
            let c = l.shape;
            const h = l.holes;
            !1 === Mc.isClockWise(c) && (c = c.reverse());
            for (let e = 0, t = h.length; e < t; e++) {
                const t = h[e];
                !0 === Mc.isClockWise(t) && (h[e] = t.reverse())
            }
            const u = Mc.triangulateShape(c, h);
            for (let e = 0, t = h.length; e < t; e++) {
                const t = h[e];
                c = c.concat(t)
            }
            for (let e = 0, t = c.length; e < t; e++) {
                const t = c[e];
                i.push(t.x, t.y, 0),
                r.push(0, 0, 1),
                s.push(t.x, t.y)
            }
            for (let e = 0, t = u.length; e < t; e++) {
                const t = u[e]
                  , i = t[0] + a
                  , r = t[1] + a
                  , s = t[2] + a;
                n.push(i, r, s),
                o += 3
            }
        }
        this.setIndex(n),
        this.setAttribute("position", new Ni(i,3)),
        this.setAttribute("normal", new Ni(r,3)),
        this.setAttribute("uv", new Ni(s,2))
    }
    toJSON() {
        const e = super.toJSON();
        return function(e, t) {
            if (t.shapes = [],
            Array.isArray(e))
                for (let n = 0, i = e.length; n < i; n++) {
                    const i = e[n];
                    t.shapes.push(i.uuid)
                }
            else
                t.shapes.push(e.uuid);
            return t
        }(this.parameters.shapes, e)
    }
    static fromJSON(e, t) {
        const n = [];
        for (let i = 0, r = e.shapes.length; i < r; i++) {
            const r = t[e.shapes[i]];
            n.push(r)
        }
        return new Rc(n,e.curveSegments)
    }
}
class Pc extends Vi {
    constructor(e=1, t=32, n=16, i=0, r=2 * Math.PI, s=0, a=Math.PI) {
        super(),
        this.type = "SphereGeometry",
        this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: n,
            phiStart: i,
            phiLength: r,
            thetaStart: s,
            thetaLength: a
        },
        t = Math.max(3, Math.floor(t)),
        n = Math.max(2, Math.floor(n));
        const o = Math.min(s + a, Math.PI);
        let l = 0;
        const c = []
          , h = new pn
          , u = new pn
          , d = []
          , p = []
          , m = []
          , f = [];
        for (let d = 0; d <= n; d++) {
            const g = []
              , v = d / n;
            let x = 0;
            0 == d && 0 == s ? x = .5 / t : d == n && o == Math.PI && (x = -.5 / t);
            for (let n = 0; n <= t; n++) {
                const o = n / t;
                h.x = -e * Math.cos(i + o * r) * Math.sin(s + v * a),
                h.y = e * Math.cos(s + v * a),
                h.z = e * Math.sin(i + o * r) * Math.sin(s + v * a),
                p.push(h.x, h.y, h.z),
                u.copy(h).normalize(),
                m.push(u.x, u.y, u.z),
                f.push(o + x, 1 - v),
                g.push(l++)
            }
            c.push(g)
        }
        for (let e = 0; e < n; e++)
            for (let i = 0; i < t; i++) {
                const t = c[e][i + 1]
                  , r = c[e][i]
                  , a = c[e + 1][i]
                  , l = c[e + 1][i + 1];
                (0 !== e || s > 0) && d.push(t, r, l),
                (e !== n - 1 || o < Math.PI) && d.push(r, a, l)
            }
        this.setIndex(d),
        this.setAttribute("position", new Ni(p,3)),
        this.setAttribute("normal", new Ni(m,3)),
        this.setAttribute("uv", new Ni(f,2))
    }
    static fromJSON(e) {
        return new Pc(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)
    }
}
class Ic extends Vl {
    constructor(e=1, t=0) {
        super([1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t),
        this.type = "TetrahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new Ic(e.radius,e.detail)
    }
}
class Dc extends Vi {
    constructor(e=1, t=.4, n=8, i=6, r=2 * Math.PI) {
        super(),
        this.type = "TorusGeometry",
        this.parameters = {
            radius: e,
            tube: t,
            radialSegments: n,
            tubularSegments: i,
            arc: r
        },
        n = Math.floor(n),
        i = Math.floor(i);
        const s = []
          , a = []
          , o = []
          , l = []
          , c = new pn
          , h = new pn
          , u = new pn;
        for (let s = 0; s <= n; s++)
            for (let d = 0; d <= i; d++) {
                const p = d / i * r
                  , m = s / n * Math.PI * 2;
                h.x = (e + t * Math.cos(m)) * Math.cos(p),
                h.y = (e + t * Math.cos(m)) * Math.sin(p),
                h.z = t * Math.sin(m),
                a.push(h.x, h.y, h.z),
                c.x = e * Math.cos(p),
                c.y = e * Math.sin(p),
                u.subVectors(h, c).normalize(),
                o.push(u.x, u.y, u.z),
                l.push(d / i),
                l.push(s / n)
            }
        for (let e = 1; e <= n; e++)
            for (let t = 1; t <= i; t++) {
                const n = (i + 1) * e + t - 1
                  , r = (i + 1) * (e - 1) + t - 1
                  , a = (i + 1) * (e - 1) + t
                  , o = (i + 1) * e + t;
                s.push(n, r, o),
                s.push(r, a, o)
            }
        this.setIndex(s),
        this.setAttribute("position", new Ni(a,3)),
        this.setAttribute("normal", new Ni(o,3)),
        this.setAttribute("uv", new Ni(l,2))
    }
    static fromJSON(e) {
        return new Dc(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)
    }
}
class Oc extends Vi {
    constructor(e=1, t=.4, n=64, i=8, r=2, s=3) {
        super(),
        this.type = "TorusKnotGeometry",
        this.parameters = {
            radius: e,
            tube: t,
            tubularSegments: n,
            radialSegments: i,
            p: r,
            q: s
        },
        n = Math.floor(n),
        i = Math.floor(i);
        const a = []
          , o = []
          , l = []
          , c = []
          , h = new pn
          , u = new pn
          , d = new pn
          , p = new pn
          , m = new pn
          , f = new pn
          , g = new pn;
        for (let a = 0; a <= n; ++a) {
            const x = a / n * r * Math.PI * 2;
            v(x, r, s, e, d),
            v(x + .01, r, s, e, p),
            f.subVectors(p, d),
            g.addVectors(p, d),
            m.crossVectors(f, g),
            g.crossVectors(m, f),
            m.normalize(),
            g.normalize();
            for (let e = 0; e <= i; ++e) {
                const r = e / i * Math.PI * 2
                  , s = -t * Math.cos(r)
                  , p = t * Math.sin(r);
                h.x = d.x + (s * g.x + p * m.x),
                h.y = d.y + (s * g.y + p * m.y),
                h.z = d.z + (s * g.z + p * m.z),
                o.push(h.x, h.y, h.z),
                u.subVectors(h, d).normalize(),
                l.push(u.x, u.y, u.z),
                c.push(a / n),
                c.push(e / i)
            }
        }
        for (let e = 1; e <= n; e++)
            for (let t = 1; t <= i; t++) {
                const n = (i + 1) * (e - 1) + (t - 1)
                  , r = (i + 1) * e + (t - 1)
                  , s = (i + 1) * e + t
                  , o = (i + 1) * (e - 1) + t;
                a.push(n, r, o),
                a.push(r, s, o)
            }
        function v(e, t, n, i, r) {
            const s = Math.cos(e)
              , a = Math.sin(e)
              , o = n / t * e
              , l = Math.cos(o);
            r.x = i * (2 + l) * .5 * s,
            r.y = i * (2 + l) * a * .5,
            r.z = i * Math.sin(o) * .5
        }
        this.setIndex(a),
        this.setAttribute("position", new Ni(o,3)),
        this.setAttribute("normal", new Ni(l,3)),
        this.setAttribute("uv", new Ni(c,2))
    }
    static fromJSON(e) {
        return new Oc(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)
    }
}
class Nc extends Vi {
    constructor(e=new Dl(new pn(-1,-1,0),new pn(-1,1,0),new pn(1,1,0)), t=64, n=1, i=8, r=!1) {
        super(),
        this.type = "TubeGeometry",
        this.parameters = {
            path: e,
            tubularSegments: t,
            radius: n,
            radialSegments: i,
            closed: r
        };
        const s = e.computeFrenetFrames(t, r);
        this.tangents = s.tangents,
        this.normals = s.normals,
        this.binormals = s.binormals;
        const a = new pn
          , o = new pn
          , l = new Ft;
        let c = new pn;
        const h = []
          , u = []
          , d = []
          , p = [];
        function m(r) {
            c = e.getPointAt(r / t, c);
            const l = s.normals[r]
              , d = s.binormals[r];
            for (let e = 0; e <= i; e++) {
                const t = e / i * Math.PI * 2
                  , r = Math.sin(t)
                  , s = -Math.cos(t);
                o.x = s * l.x + r * d.x,
                o.y = s * l.y + r * d.y,
                o.z = s * l.z + r * d.z,
                o.normalize(),
                u.push(o.x, o.y, o.z),
                a.x = c.x + n * o.x,
                a.y = c.y + n * o.y,
                a.z = c.z + n * o.z,
                h.push(a.x, a.y, a.z)
            }
        }
        !function() {
            for (let e = 0; e < t; e++)
                m(e);
            m(!1 === r ? t : 0),
            function() {
                for (let e = 0; e <= t; e++)
                    for (let n = 0; n <= i; n++)
                        l.x = e / t,
                        l.y = n / i,
                        d.push(l.x, l.y)
            }(),
            function() {
                for (let e = 1; e <= t; e++)
                    for (let t = 1; t <= i; t++) {
                        const n = (i + 1) * (e - 1) + (t - 1)
                          , r = (i + 1) * e + (t - 1)
                          , s = (i + 1) * e + t
                          , a = (i + 1) * (e - 1) + t;
                        p.push(n, r, a),
                        p.push(r, s, a)
                    }
            }()
        }(),
        this.setIndex(p),
        this.setAttribute("position", new Ni(h,3)),
        this.setAttribute("normal", new Ni(u,3)),
        this.setAttribute("uv", new Ni(d,2))
    }
    toJSON() {
        const e = super.toJSON();
        return e.path = this.parameters.path.toJSON(),
        e
    }
    static fromJSON(e) {
        return new Nc((new Nl[e.path.type]).fromJSON(e.path),e.tubularSegments,e.radius,e.radialSegments,e.closed)
    }
}
class zc extends Vi {
    constructor(e=null) {
        if (super(),
        this.type = "WireframeGeometry",
        this.parameters = {
            geometry: e
        },
        null !== e) {
            const t = []
              , n = new Set
              , i = new pn
              , r = new pn;
            if (null !== e.index) {
                const s = e.attributes.position
                  , a = e.index;
                let o = e.groups;
                0 === o.length && (o = [{
                    start: 0,
                    count: a.count,
                    materialIndex: 0
                }]);
                for (let e = 0, l = o.length; e < l; ++e) {
                    const l = o[e]
                      , c = l.start;
                    for (let e = c, o = c + l.count; e < o; e += 3)
                        for (let o = 0; o < 3; o++) {
                            const l = a.getX(e + o)
                              , c = a.getX(e + (o + 1) % 3);
                            i.fromBufferAttribute(s, l),
                            r.fromBufferAttribute(s, c),
                            !0 === Uc(i, r, n) && (t.push(i.x, i.y, i.z),
                            t.push(r.x, r.y, r.z))
                        }
                }
            } else {
                const s = e.attributes.position;
                for (let e = 0, a = s.count / 3; e < a; e++)
                    for (let a = 0; a < 3; a++) {
                        const o = 3 * e + a
                          , l = 3 * e + (a + 1) % 3;
                        i.fromBufferAttribute(s, o),
                        r.fromBufferAttribute(s, l),
                        !0 === Uc(i, r, n) && (t.push(i.x, i.y, i.z),
                        t.push(r.x, r.y, r.z))
                    }
            }
            this.setAttribute("position", new Ni(t,3))
        }
    }
}
function Uc(e, t, n) {
    const i = `${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`
      , r = `${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`;
    return !0 !== n.has(i) && !0 !== n.has(r) && (n.add(i),
    n.add(r),
    !0)
}
var Fc = Object.freeze({
    __proto__: null,
    BoxGeometry: cr,
    CapsuleGeometry: Bl,
    CircleGeometry: kl,
    ConeGeometry: Hl,
    CylinderGeometry: Gl,
    DodecahedronGeometry: Wl,
    EdgesGeometry: Zl,
    ExtrudeGeometry: Tc,
    IcosahedronGeometry: Ec,
    LatheGeometry: Fl,
    OctahedronGeometry: Cc,
    PlaneGeometry: Lr,
    PolyhedronGeometry: Vl,
    RingGeometry: Lc,
    ShapeGeometry: Rc,
    SphereGeometry: Pc,
    TetrahedronGeometry: Ic,
    TorusGeometry: Dc,
    TorusKnotGeometry: Oc,
    TubeGeometry: Nc,
    WireframeGeometry: zc
});
class Bc extends Ci {
    constructor(e) {
        super(),
        this.isShadowMaterial = !0,
        this.type = "ShadowMaterial",
        this.color = new en(0),
        this.transparent = !0,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.fog = e.fog,
        this
    }
}
class kc extends pr {
    constructor(e) {
        super(e),
        this.isRawShaderMaterial = !0,
        this.type = "RawShaderMaterial"
    }
}
class Gc extends Ci {
    constructor(e) {
        super(),
        this.isMeshStandardMaterial = !0,
        this.defines = {
            STANDARD: ""
        },
        this.type = "MeshStandardMaterial",
        this.color = new en(16777215),
        this.roughness = 1,
        this.metalness = 0,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new en(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = 0,
        this.normalScale = new Ft(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.roughnessMap = null,
        this.metalnessMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapIntensity = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            STANDARD: ""
        },
        this.color.copy(e.color),
        this.roughness = e.roughness,
        this.metalness = e.metalness,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.roughnessMap = e.roughnessMap,
        this.metalnessMap = e.metalnessMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapIntensity = e.envMapIntensity,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class Hc extends Gc {
    constructor(e) {
        super(),
        this.isMeshPhysicalMaterial = !0,
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.type = "MeshPhysicalMaterial",
        this.clearcoatMap = null,
        this.clearcoatRoughness = 0,
        this.clearcoatRoughnessMap = null,
        this.clearcoatNormalScale = new Ft(1,1),
        this.clearcoatNormalMap = null,
        this.ior = 1.5,
        Object.defineProperty(this, "reflectivity", {
            get: function() {
                return Lt(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
            },
            set: function(e) {
                this.ior = (1 + .4 * e) / (1 - .4 * e)
            }
        }),
        this.iridescenceMap = null,
        this.iridescenceIOR = 1.3,
        this.iridescenceThicknessRange = [100, 400],
        this.iridescenceThicknessMap = null,
        this.sheenColor = new en(0),
        this.sheenColorMap = null,
        this.sheenRoughness = 1,
        this.sheenRoughnessMap = null,
        this.transmissionMap = null,
        this.thickness = 0,
        this.thicknessMap = null,
        this.attenuationDistance = 0,
        this.attenuationColor = new en(1,1,1),
        this.specularIntensity = 1,
        this.specularIntensityMap = null,
        this.specularColor = new en(1,1,1),
        this.specularColorMap = null,
        this._sheen = 0,
        this._clearcoat = 0,
        this._iridescence = 0,
        this._transmission = 0,
        this.setValues(e)
    }
    get sheen() {
        return this._sheen
    }
    set sheen(e) {
        this._sheen > 0 != e > 0 && this.version++,
        this._sheen = e
    }
    get clearcoat() {
        return this._clearcoat
    }
    set clearcoat(e) {
        this._clearcoat > 0 != e > 0 && this.version++,
        this._clearcoat = e
    }
    get iridescence() {
        return this._iridescence
    }
    set iridescence(e) {
        this._iridescence > 0 != e > 0 && this.version++,
        this._iridescence = e
    }
    get transmission() {
        return this._transmission
    }
    set transmission(e) {
        this._transmission > 0 != e > 0 && this.version++,
        this._transmission = e
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.clearcoat = e.clearcoat,
        this.clearcoatMap = e.clearcoatMap,
        this.clearcoatRoughness = e.clearcoatRoughness,
        this.clearcoatRoughnessMap = e.clearcoatRoughnessMap,
        this.clearcoatNormalMap = e.clearcoatNormalMap,
        this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
        this.ior = e.ior,
        this.iridescence = e.iridescence,
        this.iridescenceMap = e.iridescenceMap,
        this.iridescenceIOR = e.iridescenceIOR,
        this.iridescenceThicknessRange = [...e.iridescenceThicknessRange],
        this.iridescenceThicknessMap = e.iridescenceThicknessMap,
        this.sheen = e.sheen,
        this.sheenColor.copy(e.sheenColor),
        this.sheenColorMap = e.sheenColorMap,
        this.sheenRoughness = e.sheenRoughness,
        this.sheenRoughnessMap = e.sheenRoughnessMap,
        this.transmission = e.transmission,
        this.transmissionMap = e.transmissionMap,
        this.thickness = e.thickness,
        this.thicknessMap = e.thicknessMap,
        this.attenuationDistance = e.attenuationDistance,
        this.attenuationColor.copy(e.attenuationColor),
        this.specularIntensity = e.specularIntensity,
        this.specularIntensityMap = e.specularIntensityMap,
        this.specularColor.copy(e.specularColor),
        this.specularColorMap = e.specularColorMap,
        this
    }
}
class Vc extends Ci {
    constructor(e) {
        super(),
        this.isMeshPhongMaterial = !0,
        this.type = "MeshPhongMaterial",
        this.color = new en(16777215),
        this.specular = new en(1118481),
        this.shininess = 30,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new en(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = 0,
        this.normalScale = new Ft(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = 0,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.specular.copy(e.specular),
        this.shininess = e.shininess,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class Wc extends Ci {
    constructor(e) {
        super(),
        this.isMeshToonMaterial = !0,
        this.defines = {
            TOON: ""
        },
        this.type = "MeshToonMaterial",
        this.color = new en(16777215),
        this.map = null,
        this.gradientMap = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new en(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = 0,
        this.normalScale = new Ft(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.alphaMap = null,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.gradientMap = e.gradientMap,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.alphaMap = e.alphaMap,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.fog = e.fog,
        this
    }
}
class jc extends Ci {
    constructor(e) {
        super(),
        this.isMeshNormalMaterial = !0,
        this.type = "MeshNormalMaterial",
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = 0,
        this.normalScale = new Ft(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.flatShading = !1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.flatShading = e.flatShading,
        this
    }
}
class Xc extends Ci {
    constructor(e) {
        super(),
        this.isMeshLambertMaterial = !0,
        this.type = "MeshLambertMaterial",
        this.color = new en(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new en(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = 0,
        this.normalScale = new Ft(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = 0,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class qc extends Ci {
    constructor(e) {
        super(),
        this.isMeshMatcapMaterial = !0,
        this.defines = {
            MATCAP: ""
        },
        this.type = "MeshMatcapMaterial",
        this.color = new en(16777215),
        this.matcap = null,
        this.map = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = 0,
        this.normalScale = new Ft(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.alphaMap = null,
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            MATCAP: ""
        },
        this.color.copy(e.color),
        this.matcap = e.matcap,
        this.map = e.map,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.alphaMap = e.alphaMap,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class Yc extends Zo {
    constructor(e) {
        super(),
        this.isLineDashedMaterial = !0,
        this.type = "LineDashedMaterial",
        this.scale = 1,
        this.dashSize = 3,
        this.gapSize = 1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.scale = e.scale,
        this.dashSize = e.dashSize,
        this.gapSize = e.gapSize,
        this
    }
}
function Zc(e, t, n) {
    return Kc(e) ? new e.constructor(e.subarray(t, void 0 !== n ? n : e.length)) : e.slice(t, n)
}
function Jc(e, t, n) {
    return !e || !n && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
}
function Kc(e) {
    return ArrayBuffer.isView(e) && !(e instanceof DataView)
}
function Qc(e) {
    const t = e.length
      , n = new Array(t);
    for (let e = 0; e !== t; ++e)
        n[e] = e;
    return n.sort((function(t, n) {
        return e[t] - e[n]
    }
    )),
    n
}
function $c(e, t, n) {
    const i = e.length
      , r = new e.constructor(i);
    for (let s = 0, a = 0; a !== i; ++s) {
        const i = n[s] * t;
        for (let n = 0; n !== t; ++n)
            r[a++] = e[i + n]
    }
    return r
}
function eh(e, t, n, i) {
    let r = 1
      , s = e[0];
    for (; void 0 !== s && void 0 === s[i]; )
        s = e[r++];
    if (void 0 === s)
        return;
    let a = s[i];
    if (void 0 !== a)
        if (Array.isArray(a))
            do {
                a = s[i],
                void 0 !== a && (t.push(s.time),
                n.push.apply(n, a)),
                s = e[r++]
            } while (void 0 !== s);
        else if (void 0 !== a.toArray)
            do {
                a = s[i],
                void 0 !== a && (t.push(s.time),
                a.toArray(n, n.length)),
                s = e[r++]
            } while (void 0 !== s);
        else
            do {
                a = s[i],
                void 0 !== a && (t.push(s.time),
                n.push(a)),
                s = e[r++]
            } while (void 0 !== s)
}
var th = Object.freeze({
    __proto__: null,
    arraySlice: Zc,
    convertArray: Jc,
    isTypedArray: Kc,
    getKeyframeOrder: Qc,
    sortedArray: $c,
    flattenJSON: eh,
    subclip: function(e, t, n, i, r=30) {
        const s = e.clone();
        s.name = t;
        const a = [];
        for (let e = 0; e < s.tracks.length; ++e) {
            const t = s.tracks[e]
              , o = t.getValueSize()
              , l = []
              , c = [];
            for (let e = 0; e < t.times.length; ++e) {
                const s = t.times[e] * r;
                if (!(s < n || s >= i)) {
                    l.push(t.times[e]);
                    for (let n = 0; n < o; ++n)
                        c.push(t.values[e * o + n])
                }
            }
            0 !== l.length && (t.times = Jc(l, t.times.constructor),
            t.values = Jc(c, t.values.constructor),
            a.push(t))
        }
        s.tracks = a;
        let o = Infinity;
        for (let e = 0; e < s.tracks.length; ++e)
            o > s.tracks[e].times[0] && (o = s.tracks[e].times[0]);
        for (let e = 0; e < s.tracks.length; ++e)
            s.tracks[e].shift(-1 * o);
        return s.resetDuration(),
        s
    },
    makeClipAdditive: function(e, t=0, n=e, i=30) {
        i <= 0 && (i = 30);
        const r = n.tracks.length
          , s = t / i;
        for (let t = 0; t < r; ++t) {
            const i = n.tracks[t]
              , r = i.ValueTypeName;
            if ("bool" === r || "string" === r)
                continue;
            const a = e.tracks.find((function(e) {
                return e.name === i.name && e.ValueTypeName === r
            }
            ));
            if (void 0 === a)
                continue;
            let o = 0;
            const l = i.getValueSize();
            i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (o = l / 3);
            let c = 0;
            const h = a.getValueSize();
            a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = h / 3);
            const u = i.times.length - 1;
            let d;
            if (s <= i.times[0]) {
                const e = o
                  , t = l - o;
                d = Zc(i.values, e, t)
            } else if (s >= i.times[u]) {
                const e = u * l + o
                  , t = e + l - o;
                d = Zc(i.values, e, t)
            } else {
                const e = i.createInterpolant()
                  , t = o
                  , n = l - o;
                e.evaluate(s),
                d = Zc(e.resultBuffer, t, n)
            }
            if ("quaternion" === r) {
                (new dn).fromArray(d).normalize().conjugate().toArray(d)
            }
            const p = a.times.length;
            for (let e = 0; e < p; ++e) {
                const t = e * h + c;
                if ("quaternion" === r)
                    dn.multiplyQuaternionsFlat(a.values, t, d, 0, a.values, t);
                else {
                    const e = h - 2 * c;
                    for (let n = 0; n < e; ++n)
                        a.values[t + n] -= d[n]
                }
            }
        }
        return e.blendMode = mt,
        e
    }
});
class nh {
    constructor(e, t, n, i) {
        this.parameterPositions = e,
        this._cachedIndex = 0,
        this.resultBuffer = void 0 !== i ? i : new t.constructor(n),
        this.sampleValues = t,
        this.valueSize = n,
        this.settings = null,
        this.DefaultSettings_ = {}
    }
    evaluate(e) {
        const t = this.parameterPositions;
        let n = this._cachedIndex
          , i = t[n]
          , r = t[n - 1];
        e: {
            t: {
                let s;
                n: {
                    i: if (!(e < i)) {
                        for (let s = n + 2; ; ) {
                            if (void 0 === i) {
                                if (e < r)
                                    break i;
                                return n = t.length,
                                this._cachedIndex = n,
                                this.copySampleValue_(n - 1)
                            }
                            if (n === s)
                                break;
                            if (r = i,
                            i = t[++n],
                            e < i)
                                break t
                        }
                        s = t.length;
                        break n
                    }
                    if (e >= r)
                        break e;
                    {
                        const a = t[1];
                        e < a && (n = 2,
                        r = a);
                        for (let s = n - 2; ; ) {
                            if (void 0 === r)
                                return this._cachedIndex = 0,
                                this.copySampleValue_(0);
                            if (n === s)
                                break;
                            if (i = r,
                            r = t[--n - 1],
                            e >= r)
                                break t
                        }
                        s = n,
                        n = 0
                    }
                }
                for (; n < s; ) {
                    const i = n + s >>> 1;
                    e < t[i] ? s = i : n = i + 1
                }
                if (i = t[n],
                r = t[n - 1],
                void 0 === r)
                    return this._cachedIndex = 0,
                    this.copySampleValue_(0);
                if (void 0 === i)
                    return n = t.length,
                    this._cachedIndex = n,
                    this.copySampleValue_(n - 1)
            }
            this._cachedIndex = n,
            this.intervalChanged_(n, r, i)
        }
        return this.interpolate_(n, r, e, i)
    }
    getSettings_() {
        return this.settings || this.DefaultSettings_
    }
    copySampleValue_(e) {
        const t = this.resultBuffer
          , n = this.sampleValues
          , i = this.valueSize
          , r = e * i;
        for (let e = 0; e !== i; ++e)
            t[e] = n[r + e];
        return t
    }
    interpolate_() {
        throw new Error("call to abstract method")
    }
    intervalChanged_() {}
}
class ih extends nh {
    constructor(e, t, n, i) {
        super(e, t, n, i),
        this._weightPrev = -0,
        this._offsetPrev = -0,
        this._weightNext = -0,
        this._offsetNext = -0,
        this.DefaultSettings_ = {
            endingStart: ht,
            endingEnd: ht
        }
    }
    intervalChanged_(e, t, n) {
        const i = this.parameterPositions;
        let r = e - 2
          , s = e + 1
          , a = i[r]
          , o = i[s];
        if (void 0 === a)
            switch (this.getSettings_().endingStart) {
            case ut:
                r = e,
                a = 2 * t - n;
                break;
            case dt:
                r = i.length - 2,
                a = t + i[r] - i[r + 1];
                break;
            default:
                r = e,
                a = n
            }
        if (void 0 === o)
            switch (this.getSettings_().endingEnd) {
            case ut:
                s = e,
                o = 2 * n - t;
                break;
            case dt:
                s = 1,
                o = n + i[1] - i[0];
                break;
            default:
                s = e - 1,
                o = t
            }
        const l = .5 * (n - t)
          , c = this.valueSize;
        this._weightPrev = l / (t - a),
        this._weightNext = l / (o - n),
        this._offsetPrev = r * c,
        this._offsetNext = s * c
    }
    interpolate_(e, t, n, i) {
        const r = this.resultBuffer
          , s = this.sampleValues
          , a = this.valueSize
          , o = e * a
          , l = o - a
          , c = this._offsetPrev
          , h = this._offsetNext
          , u = this._weightPrev
          , d = this._weightNext
          , p = (n - t) / (i - t)
          , m = p * p
          , f = m * p
          , g = -u * f + 2 * u * m - u * p
          , v = (1 + u) * f + (-1.5 - 2 * u) * m + (-.5 + u) * p + 1
          , x = (-1 - d) * f + (1.5 + d) * m + .5 * p
          , y = d * f - d * m;
        for (let e = 0; e !== a; ++e)
            r[e] = g * s[c + e] + v * s[l + e] + x * s[o + e] + y * s[h + e];
        return r
    }
}
class rh extends nh {
    constructor(e, t, n, i) {
        super(e, t, n, i)
    }
    interpolate_(e, t, n, i) {
        const r = this.resultBuffer
          , s = this.sampleValues
          , a = this.valueSize
          , o = e * a
          , l = o - a
          , c = (n - t) / (i - t)
          , h = 1 - c;
        for (let e = 0; e !== a; ++e)
            r[e] = s[l + e] * h + s[o + e] * c;
        return r
    }
}
class sh extends nh {
    constructor(e, t, n, i) {
        super(e, t, n, i)
    }
    interpolate_(e) {
        return this.copySampleValue_(e - 1)
    }
}
class ah {
    constructor(e, t, n, i) {
        if (void 0 === e)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (void 0 === t || 0 === t.length)
            throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
        this.name = e,
        this.times = Jc(t, this.TimeBufferType),
        this.values = Jc(n, this.ValueBufferType),
        this.setInterpolation(i || this.DefaultInterpolation)
    }
    static toJSON(e) {
        const t = e.constructor;
        let n;
        if (t.toJSON !== this.toJSON)
            n = t.toJSON(e);
        else {
            n = {
                name: e.name,
                times: Jc(e.times, Array),
                values: Jc(e.values, Array)
            };
            const t = e.getInterpolation();
            t !== e.DefaultInterpolation && (n.interpolation = t)
        }
        return n.type = e.ValueTypeName,
        n
    }
    InterpolantFactoryMethodDiscrete(e) {
        return new sh(this.times,this.values,this.getValueSize(),e)
    }
    InterpolantFactoryMethodLinear(e) {
        return new rh(this.times,this.values,this.getValueSize(),e)
    }
    InterpolantFactoryMethodSmooth(e) {
        return new ih(this.times,this.values,this.getValueSize(),e)
    }
    setInterpolation(e) {
        let t;
        switch (e) {
        case ot:
            t = this.InterpolantFactoryMethodDiscrete;
            break;
        case lt:
            t = this.InterpolantFactoryMethodLinear;
            break;
        case ct:
            t = this.InterpolantFactoryMethodSmooth
        }
        if (void 0 === t) {
            const t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (void 0 === this.createInterpolant) {
                if (e === this.DefaultInterpolation)
                    throw new Error(t);
                this.setInterpolation(this.DefaultInterpolation)
            }
            return console.warn("THREE.KeyframeTrack:", t),
            this
        }
        return this.createInterpolant = t,
        this
    }
    getInterpolation() {
        switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
            return ot;
        case this.InterpolantFactoryMethodLinear:
            return lt;
        case this.InterpolantFactoryMethodSmooth:
            return ct
        }
    }
    getValueSize() {
        return this.values.length / this.times.length
    }
    shift(e) {
        if (0 !== e) {
            const t = this.times;
            for (let n = 0, i = t.length; n !== i; ++n)
                t[n] += e
        }
        return this
    }
    scale(e) {
        if (1 !== e) {
            const t = this.times;
            for (let n = 0, i = t.length; n !== i; ++n)
                t[n] *= e
        }
        return this
    }
    trim(e, t) {
        const n = this.times
          , i = n.length;
        let r = 0
          , s = i - 1;
        for (; r !== i && n[r] < e; )
            ++r;
        for (; -1 !== s && n[s] > t; )
            --s;
        if (++s,
        0 !== r || s !== i) {
            r >= s && (s = Math.max(s, 1),
            r = s - 1);
            const e = this.getValueSize();
            this.times = Zc(n, r, s),
            this.values = Zc(this.values, r * e, s * e)
        }
        return this
    }
    validate() {
        let e = !0;
        const t = this.getValueSize();
        t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
        e = !1);
        const n = this.times
          , i = this.values
          , r = n.length;
        0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this),
        e = !1);
        let s = null;
        for (let t = 0; t !== r; t++) {
            const i = n[t];
            if ("number" == typeof i && isNaN(i)) {
                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, t, i),
                e = !1;
                break
            }
            if (null !== s && s > i) {
                console.error("THREE.KeyframeTrack: Out of order keys.", this, t, i, s),
                e = !1;
                break
            }
            s = i
        }
        if (void 0 !== i && Kc(i))
            for (let t = 0, n = i.length; t !== n; ++t) {
                const n = i[t];
                if (isNaN(n)) {
                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, t, n),
                    e = !1;
                    break
                }
            }
        return e
    }
    optimize() {
        const e = Zc(this.times)
          , t = Zc(this.values)
          , n = this.getValueSize()
          , i = this.getInterpolation() === ct
          , r = e.length - 1;
        let s = 1;
        for (let a = 1; a < r; ++a) {
            let r = !1;
            const o = e[a];
            if (o !== e[a + 1] && (1 !== a || o !== e[0]))
                if (i)
                    r = !0;
                else {
                    const e = a * n
                      , i = e - n
                      , s = e + n;
                    for (let a = 0; a !== n; ++a) {
                        const n = t[e + a];
                        if (n !== t[i + a] || n !== t[s + a]) {
                            r = !0;
                            break
                        }
                    }
                }
            if (r) {
                if (a !== s) {
                    e[s] = e[a];
                    const i = a * n
                      , r = s * n;
                    for (let e = 0; e !== n; ++e)
                        t[r + e] = t[i + e]
                }
                ++s
            }
        }
        if (r > 0) {
            e[s] = e[r];
            for (let e = r * n, i = s * n, a = 0; a !== n; ++a)
                t[i + a] = t[e + a];
            ++s
        }
        return s !== e.length ? (this.times = Zc(e, 0, s),
        this.values = Zc(t, 0, s * n)) : (this.times = e,
        this.values = t),
        this
    }
    clone() {
        const e = Zc(this.times, 0)
          , t = Zc(this.values, 0)
          , n = new (0,
        this.constructor)(this.name,e,t);
        return n.createInterpolant = this.createInterpolant,
        n
    }
}
ah.prototype.TimeBufferType = Float32Array,
ah.prototype.ValueBufferType = Float32Array,
ah.prototype.DefaultInterpolation = lt;
class oh extends ah {
}
oh.prototype.ValueTypeName = "bool",
oh.prototype.ValueBufferType = Array,
oh.prototype.DefaultInterpolation = ot,
oh.prototype.InterpolantFactoryMethodLinear = void 0,
oh.prototype.InterpolantFactoryMethodSmooth = void 0;
class lh extends ah {
}
lh.prototype.ValueTypeName = "color";
class ch extends ah {
}
ch.prototype.ValueTypeName = "number";
class hh extends nh {
    constructor(e, t, n, i) {
        super(e, t, n, i)
    }
    interpolate_(e, t, n, i) {
        const r = this.resultBuffer
          , s = this.sampleValues
          , a = this.valueSize
          , o = (n - t) / (i - t);
        let l = e * a;
        for (let e = l + a; l !== e; l += 4)
            dn.slerpFlat(r, 0, s, l - a, s, l, o);
        return r
    }
}
class uh extends ah {
    InterpolantFactoryMethodLinear(e) {
        return new hh(this.times,this.values,this.getValueSize(),e)
    }
}
uh.prototype.ValueTypeName = "quaternion",
uh.prototype.DefaultInterpolation = lt,
uh.prototype.InterpolantFactoryMethodSmooth = void 0;
class dh extends ah {
}
dh.prototype.ValueTypeName = "string",
dh.prototype.ValueBufferType = Array,
dh.prototype.DefaultInterpolation = ot,
dh.prototype.InterpolantFactoryMethodLinear = void 0,
dh.prototype.InterpolantFactoryMethodSmooth = void 0;
class ph extends ah {
}
ph.prototype.ValueTypeName = "vector";
class mh {
    constructor(e, t=-1, n, i=2500) {
        this.name = e,
        this.tracks = n,
        this.duration = t,
        this.blendMode = i,
        this.uuid = Ct(),
        this.duration < 0 && this.resetDuration()
    }
    static parse(e) {
        const t = []
          , n = e.tracks
          , i = 1 / (e.fps || 1);
        for (let e = 0, r = n.length; e !== r; ++e)
            t.push(fh(n[e]).scale(i));
        const r = new this(e.name,e.duration,t,e.blendMode);
        return r.uuid = e.uuid,
        r
    }
    static toJSON(e) {
        const t = []
          , n = e.tracks
          , i = {
            name: e.name,
            duration: e.duration,
            tracks: t,
            uuid: e.uuid,
            blendMode: e.blendMode
        };
        for (let e = 0, i = n.length; e !== i; ++e)
            t.push(ah.toJSON(n[e]));
        return i
    }
    static CreateFromMorphTargetSequence(e, t, n, i) {
        const r = t.length
          , s = [];
        for (let e = 0; e < r; e++) {
            let a = []
              , o = [];
            a.push((e + r - 1) % r, e, (e + 1) % r),
            o.push(0, 1, 0);
            const l = Qc(a);
            a = $c(a, 1, l),
            o = $c(o, 1, l),
            i || 0 !== a[0] || (a.push(r),
            o.push(o[0])),
            s.push(new ch(".morphTargetInfluences[" + t[e].name + "]",a,o).scale(1 / n))
        }
        return new this(e,-1,s)
    }
    static findByName(e, t) {
        let n = e;
        if (!Array.isArray(e)) {
            const t = e;
            n = t.geometry && t.geometry.animations || t.animations
        }
        for (let e = 0; e < n.length; e++)
            if (n[e].name === t)
                return n[e];
        return null
    }
    static CreateClipsFromMorphTargetSequences(e, t, n) {
        const i = {}
          , r = /^([\w-]*?)([\d]+)$/;
        for (let t = 0, n = e.length; t < n; t++) {
            const n = e[t]
              , s = n.name.match(r);
            if (s && s.length > 1) {
                const e = s[1];
                let t = i[e];
                t || (i[e] = t = []),
                t.push(n)
            }
        }
        const s = [];
        for (const e in i)
            s.push(this.CreateFromMorphTargetSequence(e, i[e], t, n));
        return s
    }
    static parseAnimation(e, t) {
        if (!e)
            return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
            null;
        const n = function(e, t, n, i, r) {
            if (0 !== n.length) {
                const s = []
                  , a = [];
                eh(n, s, a, i),
                0 !== s.length && r.push(new e(t,s,a))
            }
        }
          , i = []
          , r = e.name || "default"
          , s = e.fps || 30
          , a = e.blendMode;
        let o = e.length || -1;
        const l = e.hierarchy || [];
        for (let e = 0; e < l.length; e++) {
            const r = l[e].keys;
            if (r && 0 !== r.length)
                if (r[0].morphTargets) {
                    const e = {};
                    let t;
                    for (t = 0; t < r.length; t++)
                        if (r[t].morphTargets)
                            for (let n = 0; n < r[t].morphTargets.length; n++)
                                e[r[t].morphTargets[n]] = -1;
                    for (const n in e) {
                        const e = []
                          , s = [];
                        for (let i = 0; i !== r[t].morphTargets.length; ++i) {
                            const i = r[t];
                            e.push(i.time),
                            s.push(i.morphTarget === n ? 1 : 0)
                        }
                        i.push(new ch(".morphTargetInfluence[" + n + "]",e,s))
                    }
                    o = e.length * s
                } else {
                    const s = ".bones[" + t[e].name + "]";
                    n(ph, s + ".position", r, "pos", i),
                    n(uh, s + ".quaternion", r, "rot", i),
                    n(ph, s + ".scale", r, "scl", i)
                }
        }
        if (0 === i.length)
            return null;
        return new this(r,o,i,a)
    }
    resetDuration() {
        let e = 0;
        for (let t = 0, n = this.tracks.length; t !== n; ++t) {
            const n = this.tracks[t];
            e = Math.max(e, n.times[n.times.length - 1])
        }
        return this.duration = e,
        this
    }
    trim() {
        for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].trim(0, this.duration);
        return this
    }
    validate() {
        let e = !0;
        for (let t = 0; t < this.tracks.length; t++)
            e = e && this.tracks[t].validate();
        return e
    }
    optimize() {
        for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].optimize();
        return this
    }
    clone() {
        const e = [];
        for (let t = 0; t < this.tracks.length; t++)
            e.push(this.tracks[t].clone());
        return new this.constructor(this.name,this.duration,e,this.blendMode)
    }
    toJSON() {
        return this.constructor.toJSON(this)
    }
}
function fh(e) {
    if (void 0 === e.type)
        throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    const t = function(e) {
        switch (e.toLowerCase()) {
        case "scalar":
        case "double":
        case "float":
        case "number":
        case "integer":
            return ch;
        case "vector":
        case "vector2":
        case "vector3":
        case "vector4":
            return ph;
        case "color":
            return lh;
        case "quaternion":
            return uh;
        case "bool":
        case "boolean":
            return oh;
        case "string":
            return dh
        }
        throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
    }(e.type);
    if (void 0 === e.times) {
        const t = []
          , n = [];
        eh(e.keys, t, n, "value"),
        e.times = t,
        e.values = n
    }
    return void 0 !== t.parse ? t.parse(e) : new t(e.name,e.times,e.values,e.interpolation)
}
const gh = {
    enabled: !1,
    files: {},
    add: function(e, t) {
        !1 !== this.enabled && (this.files[e] = t)
    },
    get: function(e) {
        if (!1 !== this.enabled)
            return this.files[e]
    },
    remove: function(e) {
        delete this.files[e]
    },
    clear: function() {
        this.files = {}
    }
};
class vh {
    constructor(e, t, n) {
        const i = this;
        let r, s = !1, a = 0, o = 0;
        const l = [];
        this.onStart = void 0,
        this.onLoad = e,
        this.onProgress = t,
        this.onError = n,
        this.itemStart = function(e) {
            o++,
            !1 === s && void 0 !== i.onStart && i.onStart(e, a, o),
            s = !0
        }
        ,
        this.itemEnd = function(e) {
            a++,
            void 0 !== i.onProgress && i.onProgress(e, a, o),
            a === o && (s = !1,
            void 0 !== i.onLoad && i.onLoad())
        }
        ,
        this.itemError = function(e) {
            void 0 !== i.onError && i.onError(e)
        }
        ,
        this.resolveURL = function(e) {
            return r ? r(e) : e
        }
        ,
        this.setURLModifier = function(e) {
            return r = e,
            this
        }
        ,
        this.addHandler = function(e, t) {
            return l.push(e, t),
            this
        }
        ,
        this.removeHandler = function(e) {
            const t = l.indexOf(e);
            return -1 !== t && l.splice(t, 2),
            this
        }
        ,
        this.getHandler = function(e) {
            for (let t = 0, n = l.length; t < n; t += 2) {
                const n = l[t]
                  , i = l[t + 1];
                if (n.global && (n.lastIndex = 0),
                n.test(e))
                    return i
            }
            return null
        }
    }
}
const xh = new vh;
class yh {
    constructor(e) {
        this.manager = void 0 !== e ? e : xh,
        this.crossOrigin = "anonymous",
        this.withCredentials = !1,
        this.path = "",
        this.resourcePath = "",
        this.requestHeader = {}
    }
    load() {}
    loadAsync(e, t) {
        const n = this;
        return new Promise((function(i, r) {
            n.load(e, i, t, r)
        }
        ))
    }
    parse() {}
    setCrossOrigin(e) {
        return this.crossOrigin = e,
        this
    }
    setWithCredentials(e) {
        return this.withCredentials = e,
        this
    }
    setPath(e) {
        return this.path = e,
        this
    }
    setResourcePath(e) {
        return this.resourcePath = e,
        this
    }
    setRequestHeader(e) {
        return this.requestHeader = e,
        this
    }
}
const _h = {};
class bh extends Error {
    constructor(e, t) {
        super(e),
        this.response = t
    }
}
class Mh extends yh {
    constructor(e) {
        super(e)
    }
    load(e, t, n, i) {
        void 0 === e && (e = ""),
        void 0 !== this.path && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const r = gh.get(e);
        if (void 0 !== r)
            return this.manager.itemStart(e),
            setTimeout((()=>{
                t && t(r),
                this.manager.itemEnd(e)
            }
            ), 0),
            r;
        if (void 0 !== _h[e])
            return void _h[e].push({
                onLoad: t,
                onProgress: n,
                onError: i
            });
        _h[e] = [],
        _h[e].push({
            onLoad: t,
            onProgress: n,
            onError: i
        });
        const s = new Request(e,{
            headers: new Headers(this.requestHeader),
            credentials: this.withCredentials ? "include" : "same-origin"
        })
          , a = this.mimeType
          , o = this.responseType;
        fetch(s).then((t=>{
            if (200 === t.status || 0 === t.status) {
                if (0 === t.status && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                "undefined" == typeof ReadableStream || void 0 === t.body || void 0 === t.body.getReader)
                    return t;
                const n = _h[e]
                  , i = t.body.getReader()
                  , r = t.headers.get("Content-Length")
                  , s = r ? parseInt(r) : 0
                  , a = 0 !== s;
                let o = 0;
                const l = new ReadableStream({
                    start(e) {
                        !function t() {
                            i.read().then((({done: i, value: r})=>{
                                if (i)
                                    e.close();
                                else {
                                    o += r.byteLength;
                                    const i = new ProgressEvent("progress",{
                                        lengthComputable: a,
                                        loaded: o,
                                        total: s
                                    });
                                    for (let e = 0, t = n.length; e < t; e++) {
                                        const t = n[e];
                                        t.onProgress && t.onProgress(i)
                                    }
                                    e.enqueue(r),
                                    t()
                                }
                            }
                            ))
                        }()
                    }
                });
                return new Response(l)
            }
            throw new bh(`fetch for "${t.url}" responded with ${t.status}: ${t.statusText}`,t)
        }
        )).then((e=>{
            switch (o) {
            case "arraybuffer":
                return e.arrayBuffer();
            case "blob":
                return e.blob();
            case "document":
                return e.text().then((e=>(new DOMParser).parseFromString(e, a)));
            case "json":
                return e.json();
            default:
                if (void 0 === a)
                    return e.text();
                {
                    const t = /charset="?([^;"\s]*)"?/i.exec(a)
                      , n = t && t[1] ? t[1].toLowerCase() : void 0
                      , i = new TextDecoder(n);
                    return e.arrayBuffer().then((e=>i.decode(e)))
                }
            }
        }
        )).then((t=>{
            gh.add(e, t);
            const n = _h[e];
            delete _h[e];
            for (let e = 0, i = n.length; e < i; e++) {
                const i = n[e];
                i.onLoad && i.onLoad(t)
            }
        }
        )).catch((t=>{
            const n = _h[e];
            if (void 0 === n)
                throw this.manager.itemError(e),
                t;
            delete _h[e];
            for (let e = 0, i = n.length; e < i; e++) {
                const i = n[e];
                i.onError && i.onError(t)
            }
            this.manager.itemError(e)
        }
        )).finally((()=>{
            this.manager.itemEnd(e)
        }
        )),
        this.manager.itemStart(e)
    }
    setResponseType(e) {
        return this.responseType = e,
        this
    }
    setMimeType(e) {
        return this.mimeType = e,
        this
    }
}
class wh extends yh {
    constructor(e) {
        super(e)
    }
    load(e, t, n, i) {
        void 0 !== this.path && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const r = this
          , s = gh.get(e);
        if (void 0 !== s)
            return r.manager.itemStart(e),
            setTimeout((function() {
                t && t(s),
                r.manager.itemEnd(e)
            }
            ), 0),
            s;
        const a = Vt("img");
        function o() {
            c(),
            gh.add(e, this),
            t && t(this),
            r.manager.itemEnd(e)
        }
        function l(t) {
            c(),
            i && i(t),
            r.manager.itemError(e),
            r.manager.itemEnd(e)
        }
        function c() {
            a.removeEventListener("load", o, !1),
            a.removeEventListener("error", l, !1)
        }
        return a.addEventListener("load", o, !1),
        a.addEventListener("error", l, !1),
        "data:" !== e.slice(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin),
        r.manager.itemStart(e),
        a.src = e,
        a
    }
}
class Sh extends yh {
    constructor(e) {
        super(e)
    }
    load(e, t, n, i) {
        const r = new on
          , s = new wh(this.manager);
        return s.setCrossOrigin(this.crossOrigin),
        s.setPath(this.path),
        s.load(e, (function(e) {
            r.image = e,
            r.needsUpdate = !0,
            void 0 !== t && t(r)
        }
        ), n, i),
        r
    }
}
class Th extends fi {
    constructor(e, t=1) {
        super(),
        this.isLight = !0,
        this.type = "Light",
        this.color = new en(e),
        this.intensity = t
    }
    dispose() {}
    copy(e, t) {
        return super.copy(e, t),
        this.color.copy(e.color),
        this.intensity = e.intensity,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.color = this.color.getHex(),
        t.object.intensity = this.intensity,
        void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()),
        void 0 !== this.distance && (t.object.distance = this.distance),
        void 0 !== this.angle && (t.object.angle = this.angle),
        void 0 !== this.decay && (t.object.decay = this.decay),
        void 0 !== this.penumbra && (t.object.penumbra = this.penumbra),
        void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()),
        t
    }
}
class Ah extends Th {
    constructor(e, t, n) {
        super(e, n),
        this.isHemisphereLight = !0,
        this.type = "HemisphereLight",
        this.position.copy(fi.DefaultUp),
        this.updateMatrix(),
        this.groundColor = new en(t)
    }
    copy(e, t) {
        return super.copy(e, t),
        this.groundColor.copy(e.groundColor),
        this
    }
}
const Eh = new Wn
  , Ch = new pn
  , Lh = new pn;
class Rh {
    constructor(e) {
        this.camera = e,
        this.bias = 0,
        this.normalBias = 0,
        this.radius = 1,
        this.blurSamples = 8,
        this.mapSize = new Ft(512,512),
        this.map = null,
        this.mapPass = null,
        this.matrix = new Wn,
        this.autoUpdate = !0,
        this.needsUpdate = !1,
        this._frustum = new Ar,
        this._frameExtents = new Ft(1,1),
        this._viewportCount = 1,
        this._viewports = [new ln(0,0,1,1)]
    }
    getViewportCount() {
        return this._viewportCount
    }
    getFrustum() {
        return this._frustum
    }
    updateMatrices(e) {
        const t = this.camera
          , n = this.matrix;
        Ch.setFromMatrixPosition(e.matrixWorld),
        t.position.copy(Ch),
        Lh.setFromMatrixPosition(e.target.matrixWorld),
        t.lookAt(Lh),
        t.updateMatrixWorld(),
        Eh.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(Eh),
        n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
        n.multiply(t.projectionMatrix),
        n.multiply(t.matrixWorldInverse)
    }
    getViewport(e) {
        return this._viewports[e]
    }
    getFrameExtents() {
        return this._frameExtents
    }
    dispose() {
        this.map && this.map.dispose(),
        this.mapPass && this.mapPass.dispose()
    }
    copy(e) {
        return this.camera = e.camera.clone(),
        this.bias = e.bias,
        this.radius = e.radius,
        this.mapSize.copy(e.mapSize),
        this
    }
    clone() {
        return (new this.constructor).copy(this)
    }
    toJSON() {
        const e = {};
        return 0 !== this.bias && (e.bias = this.bias),
        0 !== this.normalBias && (e.normalBias = this.normalBias),
        1 !== this.radius && (e.radius = this.radius),
        512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()),
        e.camera = this.camera.toJSON(!1).object,
        delete e.camera.matrix,
        e
    }
}
class Ph extends Rh {
    constructor() {
        super(new fr(50,1,.5,500)),
        this.isSpotLightShadow = !0,
        this.focus = 1
    }
    updateMatrices(e) {
        const t = this.camera
          , n = 2 * Et * e.angle * this.focus
          , i = this.mapSize.width / this.mapSize.height
          , r = e.distance || t.far;
        n === t.fov && i === t.aspect && r === t.far || (t.fov = n,
        t.aspect = i,
        t.far = r,
        t.updateProjectionMatrix()),
        super.updateMatrices(e)
    }
    copy(e) {
        return super.copy(e),
        this.focus = e.focus,
        this
    }
}
class Ih extends Th {
    constructor(e, t, n=0, i=Math.PI / 3, r=0, s=1) {
        super(e, t),
        this.isSpotLight = !0,
        this.type = "SpotLight",
        this.position.copy(fi.DefaultUp),
        this.updateMatrix(),
        this.target = new fi,
        this.distance = n,
        this.angle = i,
        this.penumbra = r,
        this.decay = s,
        this.map = null,
        this.shadow = new Ph
    }
    get power() {
        return this.intensity * Math.PI
    }
    set power(e) {
        this.intensity = e / Math.PI
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.distance = e.distance,
        this.angle = e.angle,
        this.penumbra = e.penumbra,
        this.decay = e.decay,
        this.target = e.target.clone(),
        this.shadow = e.shadow.clone(),
        this
    }
}
const Dh = new Wn
  , Oh = new pn
  , Nh = new pn;
class zh extends Rh {
    constructor() {
        super(new fr(90,1,.5,500)),
        this.isPointLightShadow = !0,
        this._frameExtents = new Ft(4,2),
        this._viewportCount = 6,
        this._viewports = [new ln(2,1,1,1), new ln(0,1,1,1), new ln(3,1,1,1), new ln(1,1,1,1), new ln(3,0,1,1), new ln(1,0,1,1)],
        this._cubeDirections = [new pn(1,0,0), new pn(-1,0,0), new pn(0,0,1), new pn(0,0,-1), new pn(0,1,0), new pn(0,-1,0)],
        this._cubeUps = [new pn(0,1,0), new pn(0,1,0), new pn(0,1,0), new pn(0,1,0), new pn(0,0,1), new pn(0,0,-1)]
    }
    updateMatrices(e, t=0) {
        const n = this.camera
          , i = this.matrix
          , r = e.distance || n.far;
        r !== n.far && (n.far = r,
        n.updateProjectionMatrix()),
        Oh.setFromMatrixPosition(e.matrixWorld),
        n.position.copy(Oh),
        Nh.copy(n.position),
        Nh.add(this._cubeDirections[t]),
        n.up.copy(this._cubeUps[t]),
        n.lookAt(Nh),
        n.updateMatrixWorld(),
        i.makeTranslation(-Oh.x, -Oh.y, -Oh.z),
        Dh.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(Dh)
    }
}
class Uh extends Th {
    constructor(e, t, n=0, i=1) {
        super(e, t),
        this.isPointLight = !0,
        this.type = "PointLight",
        this.distance = n,
        this.decay = i,
        this.shadow = new zh
    }
    get power() {
        return 4 * this.intensity * Math.PI
    }
    set power(e) {
        this.intensity = e / (4 * Math.PI)
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.distance = e.distance,
        this.decay = e.decay,
        this.shadow = e.shadow.clone(),
        this
    }
}
class Fh extends Rh {
    constructor() {
        super(new Br(-5,5,5,-5,.5,500)),
        this.isDirectionalLightShadow = !0
    }
}
class Bh extends Th {
    constructor(e, t) {
        super(e, t),
        this.isDirectionalLight = !0,
        this.type = "DirectionalLight",
        this.position.copy(fi.DefaultUp),
        this.updateMatrix(),
        this.target = new fi,
        this.shadow = new Fh
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e) {
        return super.copy(e),
        this.target = e.target.clone(),
        this.shadow = e.shadow.clone(),
        this
    }
}
class kh extends Th {
    constructor(e, t) {
        super(e, t),
        this.isAmbientLight = !0,
        this.type = "AmbientLight"
    }
}
class Gh extends Th {
    constructor(e, t, n=10, i=10) {
        super(e, t),
        this.isRectAreaLight = !0,
        this.type = "RectAreaLight",
        this.width = n,
        this.height = i
    }
    get power() {
        return this.intensity * this.width * this.height * Math.PI
    }
    set power(e) {
        this.intensity = e / (this.width * this.height * Math.PI)
    }
    copy(e) {
        return super.copy(e),
        this.width = e.width,
        this.height = e.height,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.width = this.width,
        t.object.height = this.height,
        t
    }
}
class Hh {
    constructor() {
        this.isSphericalHarmonics3 = !0,
        this.coefficients = [];
        for (let e = 0; e < 9; e++)
            this.coefficients.push(new pn)
    }
    set(e) {
        for (let t = 0; t < 9; t++)
            this.coefficients[t].copy(e[t]);
        return this
    }
    zero() {
        for (let e = 0; e < 9; e++)
            this.coefficients[e].set(0, 0, 0);
        return this
    }
    getAt(e, t) {
        const n = e.x
          , i = e.y
          , r = e.z
          , s = this.coefficients;
        return t.copy(s[0]).multiplyScalar(.282095),
        t.addScaledVector(s[1], .488603 * i),
        t.addScaledVector(s[2], .488603 * r),
        t.addScaledVector(s[3], .488603 * n),
        t.addScaledVector(s[4], n * i * 1.092548),
        t.addScaledVector(s[5], i * r * 1.092548),
        t.addScaledVector(s[6], .315392 * (3 * r * r - 1)),
        t.addScaledVector(s[7], n * r * 1.092548),
        t.addScaledVector(s[8], .546274 * (n * n - i * i)),
        t
    }
    getIrradianceAt(e, t) {
        const n = e.x
          , i = e.y
          , r = e.z
          , s = this.coefficients;
        return t.copy(s[0]).multiplyScalar(.886227),
        t.addScaledVector(s[1], 1.023328 * i),
        t.addScaledVector(s[2], 1.023328 * r),
        t.addScaledVector(s[3], 1.023328 * n),
        t.addScaledVector(s[4], .858086 * n * i),
        t.addScaledVector(s[5], .858086 * i * r),
        t.addScaledVector(s[6], .743125 * r * r - .247708),
        t.addScaledVector(s[7], .858086 * n * r),
        t.addScaledVector(s[8], .429043 * (n * n - i * i)),
        t
    }
    add(e) {
        for (let t = 0; t < 9; t++)
            this.coefficients[t].add(e.coefficients[t]);
        return this
    }
    addScaledSH(e, t) {
        for (let n = 0; n < 9; n++)
            this.coefficients[n].addScaledVector(e.coefficients[n], t);
        return this
    }
    scale(e) {
        for (let t = 0; t < 9; t++)
            this.coefficients[t].multiplyScalar(e);
        return this
    }
    lerp(e, t) {
        for (let n = 0; n < 9; n++)
            this.coefficients[n].lerp(e.coefficients[n], t);
        return this
    }
    equals(e) {
        for (let t = 0; t < 9; t++)
            if (!this.coefficients[t].equals(e.coefficients[t]))
                return !1;
        return !0
    }
    copy(e) {
        return this.set(e.coefficients)
    }
    clone() {
        return (new this.constructor).copy(this)
    }
    fromArray(e, t=0) {
        const n = this.coefficients;
        for (let i = 0; i < 9; i++)
            n[i].fromArray(e, t + 3 * i);
        return this
    }
    toArray(e=[], t=0) {
        const n = this.coefficients;
        for (let i = 0; i < 9; i++)
            n[i].toArray(e, t + 3 * i);
        return e
    }
    static getBasisAt(e, t) {
        const n = e.x
          , i = e.y
          , r = e.z;
        t[0] = .282095,
        t[1] = .488603 * i,
        t[2] = .488603 * r,
        t[3] = .488603 * n,
        t[4] = 1.092548 * n * i,
        t[5] = 1.092548 * i * r,
        t[6] = .315392 * (3 * r * r - 1),
        t[7] = 1.092548 * n * r,
        t[8] = .546274 * (n * n - i * i)
    }
}
class Vh extends Th {
    constructor(e=new Hh, t=1) {
        super(void 0, t),
        this.isLightProbe = !0,
        this.sh = e
    }
    copy(e) {
        return super.copy(e),
        this.sh.copy(e.sh),
        this
    }
    fromJSON(e) {
        return this.intensity = e.intensity,
        this.sh.fromArray(e.sh),
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.sh = this.sh.toArray(),
        t
    }
}
class Wh extends yh {
    constructor(e) {
        super(e),
        this.textures = {}
    }
    load(e, t, n, i) {
        const r = this
          , s = new Mh(r.manager);
        s.setPath(r.path),
        s.setRequestHeader(r.requestHeader),
        s.setWithCredentials(r.withCredentials),
        s.load(e, (function(n) {
            try {
                t(r.parse(JSON.parse(n)))
            } catch (t) {
                i ? i(t) : console.error(t),
                r.manager.itemError(e)
            }
        }
        ), n, i)
    }
    parse(e) {
        const t = this.textures;
        function n(e) {
            return void 0 === t[e] && console.warn("THREE.MaterialLoader: Undefined texture", e),
            t[e]
        }
        const i = Wh.createMaterialFromType(e.type);
        if (void 0 !== e.uuid && (i.uuid = e.uuid),
        void 0 !== e.name && (i.name = e.name),
        void 0 !== e.color && void 0 !== i.color && i.color.setHex(e.color),
        void 0 !== e.roughness && (i.roughness = e.roughness),
        void 0 !== e.metalness && (i.metalness = e.metalness),
        void 0 !== e.sheen && (i.sheen = e.sheen),
        void 0 !== e.sheenColor && (i.sheenColor = (new en).setHex(e.sheenColor)),
        void 0 !== e.sheenRoughness && (i.sheenRoughness = e.sheenRoughness),
        void 0 !== e.emissive && void 0 !== i.emissive && i.emissive.setHex(e.emissive),
        void 0 !== e.specular && void 0 !== i.specular && i.specular.setHex(e.specular),
        void 0 !== e.specularIntensity && (i.specularIntensity = e.specularIntensity),
        void 0 !== e.specularColor && void 0 !== i.specularColor && i.specularColor.setHex(e.specularColor),
        void 0 !== e.shininess && (i.shininess = e.shininess),
        void 0 !== e.clearcoat && (i.clearcoat = e.clearcoat),
        void 0 !== e.clearcoatRoughness && (i.clearcoatRoughness = e.clearcoatRoughness),
        void 0 !== e.iridescence && (i.iridescence = e.iridescence),
        void 0 !== e.iridescenceIOR && (i.iridescenceIOR = e.iridescenceIOR),
        void 0 !== e.iridescenceThicknessRange && (i.iridescenceThicknessRange = e.iridescenceThicknessRange),
        void 0 !== e.transmission && (i.transmission = e.transmission),
        void 0 !== e.thickness && (i.thickness = e.thickness),
        void 0 !== e.attenuationDistance && (i.attenuationDistance = e.attenuationDistance),
        void 0 !== e.attenuationColor && void 0 !== i.attenuationColor && i.attenuationColor.setHex(e.attenuationColor),
        void 0 !== e.fog && (i.fog = e.fog),
        void 0 !== e.flatShading && (i.flatShading = e.flatShading),
        void 0 !== e.blending && (i.blending = e.blending),
        void 0 !== e.combine && (i.combine = e.combine),
        void 0 !== e.side && (i.side = e.side),
        void 0 !== e.shadowSide && (i.shadowSide = e.shadowSide),
        void 0 !== e.opacity && (i.opacity = e.opacity),
        void 0 !== e.transparent && (i.transparent = e.transparent),
        void 0 !== e.alphaTest && (i.alphaTest = e.alphaTest),
        void 0 !== e.depthTest && (i.depthTest = e.depthTest),
        void 0 !== e.depthWrite && (i.depthWrite = e.depthWrite),
        void 0 !== e.colorWrite && (i.colorWrite = e.colorWrite),
        void 0 !== e.stencilWrite && (i.stencilWrite = e.stencilWrite),
        void 0 !== e.stencilWriteMask && (i.stencilWriteMask = e.stencilWriteMask),
        void 0 !== e.stencilFunc && (i.stencilFunc = e.stencilFunc),
        void 0 !== e.stencilRef && (i.stencilRef = e.stencilRef),
        void 0 !== e.stencilFuncMask && (i.stencilFuncMask = e.stencilFuncMask),
        void 0 !== e.stencilFail && (i.stencilFail = e.stencilFail),
        void 0 !== e.stencilZFail && (i.stencilZFail = e.stencilZFail),
        void 0 !== e.stencilZPass && (i.stencilZPass = e.stencilZPass),
        void 0 !== e.wireframe && (i.wireframe = e.wireframe),
        void 0 !== e.wireframeLinewidth && (i.wireframeLinewidth = e.wireframeLinewidth),
        void 0 !== e.wireframeLinecap && (i.wireframeLinecap = e.wireframeLinecap),
        void 0 !== e.wireframeLinejoin && (i.wireframeLinejoin = e.wireframeLinejoin),
        void 0 !== e.rotation && (i.rotation = e.rotation),
        1 !== e.linewidth && (i.linewidth = e.linewidth),
        void 0 !== e.dashSize && (i.dashSize = e.dashSize),
        void 0 !== e.gapSize && (i.gapSize = e.gapSize),
        void 0 !== e.scale && (i.scale = e.scale),
        void 0 !== e.polygonOffset && (i.polygonOffset = e.polygonOffset),
        void 0 !== e.polygonOffsetFactor && (i.polygonOffsetFactor = e.polygonOffsetFactor),
        void 0 !== e.polygonOffsetUnits && (i.polygonOffsetUnits = e.polygonOffsetUnits),
        void 0 !== e.dithering && (i.dithering = e.dithering),
        void 0 !== e.alphaToCoverage && (i.alphaToCoverage = e.alphaToCoverage),
        void 0 !== e.premultipliedAlpha && (i.premultipliedAlpha = e.premultipliedAlpha),
        void 0 !== e.visible && (i.visible = e.visible),
        void 0 !== e.toneMapped && (i.toneMapped = e.toneMapped),
        void 0 !== e.userData && (i.userData = e.userData),
        void 0 !== e.vertexColors && ("number" == typeof e.vertexColors ? i.vertexColors = e.vertexColors > 0 : i.vertexColors = e.vertexColors),
        void 0 !== e.uniforms)
            for (const t in e.uniforms) {
                const r = e.uniforms[t];
                switch (i.uniforms[t] = {},
                r.type) {
                case "t":
                    i.uniforms[t].value = n(r.value);
                    break;
                case "c":
                    i.uniforms[t].value = (new en).setHex(r.value);
                    break;
                case "v2":
                    i.uniforms[t].value = (new Ft).fromArray(r.value);
                    break;
                case "v3":
                    i.uniforms[t].value = (new pn).fromArray(r.value);
                    break;
                case "v4":
                    i.uniforms[t].value = (new ln).fromArray(r.value);
                    break;
                case "m3":
                    i.uniforms[t].value = (new Bt).fromArray(r.value);
                    break;
                case "m4":
                    i.uniforms[t].value = (new Wn).fromArray(r.value);
                    break;
                default:
                    i.uniforms[t].value = r.value
                }
            }
        if (void 0 !== e.defines && (i.defines = e.defines),
        void 0 !== e.vertexShader && (i.vertexShader = e.vertexShader),
        void 0 !== e.fragmentShader && (i.fragmentShader = e.fragmentShader),
        void 0 !== e.glslVersion && (i.glslVersion = e.glslVersion),
        void 0 !== e.extensions)
            for (const t in e.extensions)
                i.extensions[t] = e.extensions[t];
        if (void 0 !== e.size && (i.size = e.size),
        void 0 !== e.sizeAttenuation && (i.sizeAttenuation = e.sizeAttenuation),
        void 0 !== e.map && (i.map = n(e.map)),
        void 0 !== e.matcap && (i.matcap = n(e.matcap)),
        void 0 !== e.alphaMap && (i.alphaMap = n(e.alphaMap)),
        void 0 !== e.bumpMap && (i.bumpMap = n(e.bumpMap)),
        void 0 !== e.bumpScale && (i.bumpScale = e.bumpScale),
        void 0 !== e.normalMap && (i.normalMap = n(e.normalMap)),
        void 0 !== e.normalMapType && (i.normalMapType = e.normalMapType),
        void 0 !== e.normalScale) {
            let t = e.normalScale;
            !1 === Array.isArray(t) && (t = [t, t]),
            i.normalScale = (new Ft).fromArray(t)
        }
        return void 0 !== e.displacementMap && (i.displacementMap = n(e.displacementMap)),
        void 0 !== e.displacementScale && (i.displacementScale = e.displacementScale),
        void 0 !== e.displacementBias && (i.displacementBias = e.displacementBias),
        void 0 !== e.roughnessMap && (i.roughnessMap = n(e.roughnessMap)),
        void 0 !== e.metalnessMap && (i.metalnessMap = n(e.metalnessMap)),
        void 0 !== e.emissiveMap && (i.emissiveMap = n(e.emissiveMap)),
        void 0 !== e.emissiveIntensity && (i.emissiveIntensity = e.emissiveIntensity),
        void 0 !== e.specularMap && (i.specularMap = n(e.specularMap)),
        void 0 !== e.specularIntensityMap && (i.specularIntensityMap = n(e.specularIntensityMap)),
        void 0 !== e.specularColorMap && (i.specularColorMap = n(e.specularColorMap)),
        void 0 !== e.envMap && (i.envMap = n(e.envMap)),
        void 0 !== e.envMapIntensity && (i.envMapIntensity = e.envMapIntensity),
        void 0 !== e.reflectivity && (i.reflectivity = e.reflectivity),
        void 0 !== e.refractionRatio && (i.refractionRatio = e.refractionRatio),
        void 0 !== e.lightMap && (i.lightMap = n(e.lightMap)),
        void 0 !== e.lightMapIntensity && (i.lightMapIntensity = e.lightMapIntensity),
        void 0 !== e.aoMap && (i.aoMap = n(e.aoMap)),
        void 0 !== e.aoMapIntensity && (i.aoMapIntensity = e.aoMapIntensity),
        void 0 !== e.gradientMap && (i.gradientMap = n(e.gradientMap)),
        void 0 !== e.clearcoatMap && (i.clearcoatMap = n(e.clearcoatMap)),
        void 0 !== e.clearcoatRoughnessMap && (i.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)),
        void 0 !== e.clearcoatNormalMap && (i.clearcoatNormalMap = n(e.clearcoatNormalMap)),
        void 0 !== e.clearcoatNormalScale && (i.clearcoatNormalScale = (new Ft).fromArray(e.clearcoatNormalScale)),
        void 0 !== e.iridescenceMap && (i.iridescenceMap = n(e.iridescenceMap)),
        void 0 !== e.iridescenceThicknessMap && (i.iridescenceThicknessMap = n(e.iridescenceThicknessMap)),
        void 0 !== e.transmissionMap && (i.transmissionMap = n(e.transmissionMap)),
        void 0 !== e.thicknessMap && (i.thicknessMap = n(e.thicknessMap)),
        void 0 !== e.sheenColorMap && (i.sheenColorMap = n(e.sheenColorMap)),
        void 0 !== e.sheenRoughnessMap && (i.sheenRoughnessMap = n(e.sheenRoughnessMap)),
        i
    }
    setTextures(e) {
        return this.textures = e,
        this
    }
    static createMaterialFromType(e) {
        return new {
            ShadowMaterial: Bc,
            SpriteMaterial: po,
            RawShaderMaterial: kc,
            ShaderMaterial: pr,
            PointsMaterial: al,
            MeshPhysicalMaterial: Hc,
            MeshStandardMaterial: Gc,
            MeshPhongMaterial: Vc,
            MeshToonMaterial: Wc,
            MeshNormalMaterial: jc,
            MeshLambertMaterial: Xc,
            MeshDepthMaterial: Wa,
            MeshDistanceMaterial: ja,
            MeshBasicMaterial: Li,
            MeshMatcapMaterial: qc,
            LineDashedMaterial: Yc,
            LineBasicMaterial: Zo,
            Material: Ci
        }[e]
    }
}
class jh {
    static decodeText(e) {
        if ("undefined" != typeof TextDecoder)
            return (new TextDecoder).decode(e);
        let t = "";
        for (let n = 0, i = e.length; n < i; n++)
            t += String.fromCharCode(e[n]);
        try {
            return decodeURIComponent(escape(t))
        } catch (e) {
            return t
        }
    }
    static extractUrlBase(e) {
        const t = e.lastIndexOf("/");
        return -1 === t ? "./" : e.slice(0, t + 1)
    }
    static resolveURL(e, t) {
        return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
    }
}
class Xh extends Vi {
    constructor() {
        super(),
        this.isInstancedBufferGeometry = !0,
        this.type = "InstancedBufferGeometry",
        this.instanceCount = Infinity
    }
    copy(e) {
        return super.copy(e),
        this.instanceCount = e.instanceCount,
        this
    }
    clone() {
        return (new this.constructor).copy(this)
    }
    toJSON() {
        const e = super.toJSON(this);
        return e.instanceCount = this.instanceCount,
        e.isInstancedBufferGeometry = !0,
        e
    }
}
class qh extends yh {
    constructor(e) {
        super(e)
    }
    load(e, t, n, i) {
        const r = this
          , s = new Mh(r.manager);
        s.setPath(r.path),
        s.setRequestHeader(r.requestHeader),
        s.setWithCredentials(r.withCredentials),
        s.load(e, (function(n) {
            try {
                t(r.parse(JSON.parse(n)))
            } catch (t) {
                i ? i(t) : console.error(t),
                r.manager.itemError(e)
            }
        }
        ), n, i)
    }
    parse(e) {
        const t = {}
          , n = {};
        function i(e, i) {
            if (void 0 !== t[i])
                return t[i];
            const r = e.interleavedBuffers[i]
              , s = function(e, t) {
                if (void 0 !== n[t])
                    return n[t];
                const i = e.arrayBuffers
                  , r = i[t]
                  , s = new Uint32Array(r).buffer;
                return n[t] = s,
                s
            }(e, r.buffer)
              , a = Ht(r.type, s)
              , o = new co(a,r.stride);
            return o.uuid = r.uuid,
            t[i] = o,
            o
        }
        const r = e.isInstancedBufferGeometry ? new Xh : new Vi
          , s = e.data.index;
        if (void 0 !== s) {
            const e = Ht(s.type, s.array);
            r.setIndex(new Ii(e,1))
        }
        const a = e.data.attributes;
        for (const t in a) {
            const n = a[t];
            let s;
            if (n.isInterleavedBufferAttribute) {
                const t = i(e.data, n.data);
                s = new uo(t,n.itemSize,n.offset,n.normalized)
            } else {
                const e = Ht(n.type, n.array);
                s = new (n.isInstancedBufferAttribute ? Vo : Ii)(e,n.itemSize,n.normalized)
            }
            void 0 !== n.name && (s.name = n.name),
            void 0 !== n.usage && s.setUsage(n.usage),
            void 0 !== n.updateRange && (s.updateRange.offset = n.updateRange.offset,
            s.updateRange.count = n.updateRange.count),
            r.setAttribute(t, s)
        }
        const o = e.data.morphAttributes;
        if (o)
            for (const t in o) {
                const n = o[t]
                  , s = [];
                for (let t = 0, r = n.length; t < r; t++) {
                    const r = n[t];
                    let a;
                    if (r.isInterleavedBufferAttribute) {
                        const t = i(e.data, r.data);
                        a = new uo(t,r.itemSize,r.offset,r.normalized)
                    } else {
                        const e = Ht(r.type, r.array);
                        a = new Ii(e,r.itemSize,r.normalized)
                    }
                    void 0 !== r.name && (a.name = r.name),
                    s.push(a)
                }
                r.morphAttributes[t] = s
            }
        e.data.morphTargetsRelative && (r.morphTargetsRelative = !0);
        const l = e.data.groups || e.data.drawcalls || e.data.offsets;
        if (void 0 !== l)
            for (let e = 0, t = l.length; e !== t; ++e) {
                const t = l[e];
                r.addGroup(t.start, t.count, t.materialIndex)
            }
        const c = e.data.boundingSphere;
        if (void 0 !== c) {
            const e = new pn;
            void 0 !== c.center && e.fromArray(c.center),
            r.boundingSphere = new Nn(e,c.radius)
        }
        return e.name && (r.name = e.name),
        e.userData && (r.userData = e.userData),
        r
    }
}
const Yh = {
    UVMapping: ue,
    CubeReflectionMapping: de,
    CubeRefractionMapping: pe,
    EquirectangularReflectionMapping: me,
    EquirectangularRefractionMapping: fe,
    CubeUVReflectionMapping: ge
}
  , Zh = {
    RepeatWrapping: ve,
    ClampToEdgeWrapping: xe,
    MirroredRepeatWrapping: ye
}
  , Jh = {
    NearestFilter: _e,
    NearestMipmapNearestFilter: be,
    NearestMipmapLinearFilter: Me,
    LinearFilter: we,
    LinearMipmapNearestFilter: Se,
    LinearMipmapLinearFilter: Te
};
class Kh extends yh {
    constructor(e) {
        super(e),
        this.isImageBitmapLoader = !0,
        "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
        "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
        this.options = {
            premultiplyAlpha: "none"
        }
    }
    setOptions(e) {
        return this.options = e,
        this
    }
    load(e, t, n, i) {
        void 0 === e && (e = ""),
        void 0 !== this.path && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const r = this
          , s = gh.get(e);
        if (void 0 !== s)
            return r.manager.itemStart(e),
            setTimeout((function() {
                t && t(s),
                r.manager.itemEnd(e)
            }
            ), 0),
            s;
        const a = {};
        a.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include",
        a.headers = this.requestHeader,
        fetch(e, a).then((function(e) {
            return e.blob()
        }
        )).then((function(e) {
            return createImageBitmap(e, Object.assign(r.options, {
                colorSpaceConversion: "none"
            }))
        }
        )).then((function(n) {
            gh.add(e, n),
            t && t(n),
            r.manager.itemEnd(e)
        }
        )).catch((function(t) {
            i && i(t),
            r.manager.itemError(e),
            r.manager.itemEnd(e)
        }
        )),
        r.manager.itemStart(e)
    }
}
let Qh;
const $h = {
    getContext: function() {
        return void 0 === Qh && (Qh = new (window.AudioContext || window.webkitAudioContext)),
        Qh
    },
    setContext: function(e) {
        Qh = e
    }
};
class eu extends yh {
    constructor(e) {
        super(e)
    }
    load(e, t, n, i) {
        const r = this
          , s = new Mh(this.manager);
        s.setResponseType("arraybuffer"),
        s.setPath(this.path),
        s.setRequestHeader(this.requestHeader),
        s.setWithCredentials(this.withCredentials),
        s.load(e, (function(n) {
            try {
                const e = n.slice(0);
                $h.getContext().decodeAudioData(e, (function(e) {
                    t(e)
                }
                ))
            } catch (t) {
                i ? i(t) : console.error(t),
                r.manager.itemError(e)
            }
        }
        ), n, i)
    }
}
const tu = new Wn
  , nu = new Wn
  , iu = new Wn;
class ru {
    constructor(e=!0) {
        this.autoStart = e,
        this.startTime = 0,
        this.oldTime = 0,
        this.elapsedTime = 0,
        this.running = !1
    }
    start() {
        this.startTime = su(),
        this.oldTime = this.startTime,
        this.elapsedTime = 0,
        this.running = !0
    }
    stop() {
        this.getElapsedTime(),
        this.running = !1,
        this.autoStart = !1
    }
    getElapsedTime() {
        return this.getDelta(),
        this.elapsedTime
    }
    getDelta() {
        let e = 0;
        if (this.autoStart && !this.running)
            return this.start(),
            0;
        if (this.running) {
            const t = su();
            e = (t - this.oldTime) / 1e3,
            this.oldTime = t,
            this.elapsedTime += e
        }
        return e
    }
}
function su() {
    return ("undefined" == typeof performance ? Date : performance).now()
}
const au = new pn
  , ou = new dn
  , lu = new pn
  , cu = new pn;
class hu extends fi {
    constructor() {
        super(),
        this.type = "AudioListener",
        this.context = $h.getContext(),
        this.gain = this.context.createGain(),
        this.gain.connect(this.context.destination),
        this.filter = null,
        this.timeDelta = 0,
        this._clock = new ru
    }
    getInput() {
        return this.gain
    }
    removeFilter() {
        return null !== this.filter && (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination),
        this.gain.connect(this.context.destination),
        this.filter = null),
        this
    }
    getFilter() {
        return this.filter
    }
    setFilter(e) {
        return null !== this.filter ? (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination),
        this.filter = e,
        this.gain.connect(this.filter),
        this.filter.connect(this.context.destination),
        this
    }
    getMasterVolume() {
        return this.gain.gain.value
    }
    setMasterVolume(e) {
        return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
        this
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e);
        const t = this.context.listener
          , n = this.up;
        if (this.timeDelta = this._clock.getDelta(),
        this.matrixWorld.decompose(au, ou, lu),
        cu.set(0, 0, -1).applyQuaternion(ou),
        t.positionX) {
            const e = this.context.currentTime + this.timeDelta;
            t.positionX.linearRampToValueAtTime(au.x, e),
            t.positionY.linearRampToValueAtTime(au.y, e),
            t.positionZ.linearRampToValueAtTime(au.z, e),
            t.forwardX.linearRampToValueAtTime(cu.x, e),
            t.forwardY.linearRampToValueAtTime(cu.y, e),
            t.forwardZ.linearRampToValueAtTime(cu.z, e),
            t.upX.linearRampToValueAtTime(n.x, e),
            t.upY.linearRampToValueAtTime(n.y, e),
            t.upZ.linearRampToValueAtTime(n.z, e)
        } else
            t.setPosition(au.x, au.y, au.z),
            t.setOrientation(cu.x, cu.y, cu.z, n.x, n.y, n.z)
    }
}
class uu extends fi {
    constructor(e) {
        super(),
        this.type = "Audio",
        this.listener = e,
        this.context = e.context,
        this.gain = this.context.createGain(),
        this.gain.connect(e.getInput()),
        this.autoplay = !1,
        this.buffer = null,
        this.detune = 0,
        this.loop = !1,
        this.loopStart = 0,
        this.loopEnd = 0,
        this.offset = 0,
        this.duration = void 0,
        this.playbackRate = 1,
        this.isPlaying = !1,
        this.hasPlaybackControl = !0,
        this.source = null,
        this.sourceType = "empty",
        this._startedAt = 0,
        this._progress = 0,
        this._connected = !1,
        this.filters = []
    }
    getOutput() {
        return this.gain
    }
    setNodeSource(e) {
        return this.hasPlaybackControl = !1,
        this.sourceType = "audioNode",
        this.source = e,
        this.connect(),
        this
    }
    setMediaElementSource(e) {
        return this.hasPlaybackControl = !1,
        this.sourceType = "mediaNode",
        this.source = this.context.createMediaElementSource(e),
        this.connect(),
        this
    }
    setMediaStreamSource(e) {
        return this.hasPlaybackControl = !1,
        this.sourceType = "mediaStreamNode",
        this.source = this.context.createMediaStreamSource(e),
        this.connect(),
        this
    }
    setBuffer(e) {
        return this.buffer = e,
        this.sourceType = "buffer",
        this.autoplay && this.play(),
        this
    }
    play(e=0) {
        if (!0 === this.isPlaying)
            return void console.warn("THREE.Audio: Audio is already playing.");
        if (!1 === this.hasPlaybackControl)
            return void console.warn("THREE.Audio: this Audio has no playback control.");
        this._startedAt = this.context.currentTime + e;
        const t = this.context.createBufferSource();
        return t.buffer = this.buffer,
        t.loop = this.loop,
        t.loopStart = this.loopStart,
        t.loopEnd = this.loopEnd,
        t.onended = this.onEnded.bind(this),
        t.start(this._startedAt, this._progress + this.offset, this.duration),
        this.isPlaying = !0,
        this.source = t,
        this.setDetune(this.detune),
        this.setPlaybackRate(this.playbackRate),
        this.connect()
    }
    pause() {
        if (!1 !== this.hasPlaybackControl)
            return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate,
            !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)),
            this.source.stop(),
            this.source.onended = null,
            this.isPlaying = !1),
            this;
        console.warn("THREE.Audio: this Audio has no playback control.")
    }
    stop() {
        if (!1 !== this.hasPlaybackControl)
            return this._progress = 0,
            this.source.stop(),
            this.source.onended = null,
            this.isPlaying = !1,
            this;
        console.warn("THREE.Audio: this Audio has no playback control.")
    }
    connect() {
        if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let e = 1, t = this.filters.length; e < t; e++)
                this.filters[e - 1].connect(this.filters[e]);
            this.filters[this.filters.length - 1].connect(this.getOutput())
        } else
            this.source.connect(this.getOutput());
        return this._connected = !0,
        this
    }
    disconnect() {
        if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for (let e = 1, t = this.filters.length; e < t; e++)
                this.filters[e - 1].disconnect(this.filters[e]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput())
        } else
            this.source.disconnect(this.getOutput());
        return this._connected = !1,
        this
    }
    getFilters() {
        return this.filters
    }
    setFilters(e) {
        return e || (e = []),
        !0 === this._connected ? (this.disconnect(),
        this.filters = e.slice(),
        this.connect()) : this.filters = e.slice(),
        this
    }
    setDetune(e) {
        if (this.detune = e,
        void 0 !== this.source.detune)
            return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01),
            this
    }
    getDetune() {
        return this.detune
    }
    getFilter() {
        return this.getFilters()[0]
    }
    setFilter(e) {
        return this.setFilters(e ? [e] : [])
    }
    setPlaybackRate(e) {
        if (!1 !== this.hasPlaybackControl)
            return this.playbackRate = e,
            !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01),
            this;
        console.warn("THREE.Audio: this Audio has no playback control.")
    }
    getPlaybackRate() {
        return this.playbackRate
    }
    onEnded() {
        this.isPlaying = !1
    }
    getLoop() {
        return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."),
        !1) : this.loop
    }
    setLoop(e) {
        if (!1 !== this.hasPlaybackControl)
            return this.loop = e,
            !0 === this.isPlaying && (this.source.loop = this.loop),
            this;
        console.warn("THREE.Audio: this Audio has no playback control.")
    }
    setLoopStart(e) {
        return this.loopStart = e,
        this
    }
    setLoopEnd(e) {
        return this.loopEnd = e,
        this
    }
    getVolume() {
        return this.gain.gain.value
    }
    setVolume(e) {
        return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
        this
    }
}
const du = new pn
  , pu = new dn
  , mu = new pn
  , fu = new pn;
class gu {
    constructor(e, t, n) {
        let i, r, s;
        switch (this.binding = e,
        this.valueSize = n,
        t) {
        case "quaternion":
            i = this._slerp,
            r = this._slerpAdditive,
            s = this._setAdditiveIdentityQuaternion,
            this.buffer = new Float64Array(6 * n),
            this._workIndex = 5;
            break;
        case "string":
        case "bool":
            i = this._select,
            r = this._select,
            s = this._setAdditiveIdentityOther,
            this.buffer = new Array(5 * n);
            break;
        default:
            i = this._lerp,
            r = this._lerpAdditive,
            s = this._setAdditiveIdentityNumeric,
            this.buffer = new Float64Array(5 * n)
        }
        this._mixBufferRegion = i,
        this._mixBufferRegionAdditive = r,
        this._setIdentity = s,
        this._origIndex = 3,
        this._addIndex = 4,
        this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0,
        this.useCount = 0,
        this.referenceCount = 0
    }
    accumulate(e, t) {
        const n = this.buffer
          , i = this.valueSize
          , r = e * i + i;
        let s = this.cumulativeWeight;
        if (0 === s) {
            for (let e = 0; e !== i; ++e)
                n[r + e] = n[e];
            s = t
        } else {
            s += t;
            const e = t / s;
            this._mixBufferRegion(n, r, 0, e, i)
        }
        this.cumulativeWeight = s
    }
    accumulateAdditive(e) {
        const t = this.buffer
          , n = this.valueSize
          , i = n * this._addIndex;
        0 === this.cumulativeWeightAdditive && this._setIdentity(),
        this._mixBufferRegionAdditive(t, i, 0, e, n),
        this.cumulativeWeightAdditive += e
    }
    apply(e) {
        const t = this.valueSize
          , n = this.buffer
          , i = e * t + t
          , r = this.cumulativeWeight
          , s = this.cumulativeWeightAdditive
          , a = this.binding;
        if (this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0,
        r < 1) {
            const e = t * this._origIndex;
            this._mixBufferRegion(n, i, e, 1 - r, t)
        }
        s > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * t, 1, t);
        for (let e = t, r = t + t; e !== r; ++e)
            if (n[e] !== n[e + t]) {
                a.setValue(n, i);
                break
            }
    }
    saveOriginalState() {
        const e = this.binding
          , t = this.buffer
          , n = this.valueSize
          , i = n * this._origIndex;
        e.getValue(t, i);
        for (let e = n, r = i; e !== r; ++e)
            t[e] = t[i + e % n];
        this._setIdentity(),
        this.cumulativeWeight = 0,
        this.cumulativeWeightAdditive = 0
    }
    restoreOriginalState() {
        const e = 3 * this.valueSize;
        this.binding.setValue(this.buffer, e)
    }
    _setAdditiveIdentityNumeric() {
        const e = this._addIndex * this.valueSize
          , t = e + this.valueSize;
        for (let n = e; n < t; n++)
            this.buffer[n] = 0
    }
    _setAdditiveIdentityQuaternion() {
        this._setAdditiveIdentityNumeric(),
        this.buffer[this._addIndex * this.valueSize + 3] = 1
    }
    _setAdditiveIdentityOther() {
        const e = this._origIndex * this.valueSize
          , t = this._addIndex * this.valueSize;
        for (let n = 0; n < this.valueSize; n++)
            this.buffer[t + n] = this.buffer[e + n]
    }
    _select(e, t, n, i, r) {
        if (i >= .5)
            for (let i = 0; i !== r; ++i)
                e[t + i] = e[n + i]
    }
    _slerp(e, t, n, i) {
        dn.slerpFlat(e, t, e, t, e, n, i)
    }
    _slerpAdditive(e, t, n, i, r) {
        const s = this._workIndex * r;
        dn.multiplyQuaternionsFlat(e, s, e, t, e, n),
        dn.slerpFlat(e, t, e, t, e, s, i)
    }
    _lerp(e, t, n, i, r) {
        const s = 1 - i;
        for (let a = 0; a !== r; ++a) {
            const r = t + a;
            e[r] = e[r] * s + e[n + a] * i
        }
    }
    _lerpAdditive(e, t, n, i, r) {
        for (let s = 0; s !== r; ++s) {
            const r = t + s;
            e[r] = e[r] + e[n + s] * i
        }
    }
}
const vu = "\\[\\]\\.:\\/"
  , xu = new RegExp("[" + vu + "]","g")
  , yu = "[^" + vu + "]"
  , _u = "[^" + vu.replace("\\.", "") + "]"
  , bu = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", yu) + /(WCOD+)?/.source.replace("WCOD", _u) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", yu) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", yu) + "$")
  , Mu = ["material", "materials", "bones", "map"];
class wu {
    constructor(e, t, n) {
        this.path = t,
        this.parsedPath = n || wu.parseTrackName(t),
        this.node = wu.findNode(e, this.parsedPath.nodeName) || e,
        this.rootNode = e,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound
    }
    static create(e, t, n) {
        return e && e.isAnimationObjectGroup ? new wu.Composite(e,t,n) : new wu(e,t,n)
    }
    static sanitizeNodeName(e) {
        return e.replace(/\s/g, "_").replace(xu, "")
    }
    static parseTrackName(e) {
        const t = bu.exec(e);
        if (null === t)
            throw new Error("PropertyBinding: Cannot parse trackName: " + e);
        const n = {
            nodeName: t[2],
            objectName: t[3],
            objectIndex: t[4],
            propertyName: t[5],
            propertyIndex: t[6]
        }
          , i = n.nodeName && n.nodeName.lastIndexOf(".");
        if (void 0 !== i && -1 !== i) {
            const e = n.nodeName.substring(i + 1);
            -1 !== Mu.indexOf(e) && (n.nodeName = n.nodeName.substring(0, i),
            n.objectName = e)
        }
        if (null === n.propertyName || 0 === n.propertyName.length)
            throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
        return n
    }
    static findNode(e, t) {
        if (void 0 === t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid)
            return e;
        if (e.skeleton) {
            const n = e.skeleton.getBoneByName(t);
            if (void 0 !== n)
                return n
        }
        if (e.children) {
            const n = function(e) {
                for (let i = 0; i < e.length; i++) {
                    const r = e[i];
                    if (r.name === t || r.uuid === t)
                        return r;
                    const s = n(r.children);
                    if (s)
                        return s
                }
                return null
            }
              , i = n(e.children);
            if (i)
                return i
        }
        return null
    }
    _getValue_unavailable() {}
    _setValue_unavailable() {}
    _getValue_direct(e, t) {
        e[t] = this.targetObject[this.propertyName]
    }
    _getValue_array(e, t) {
        const n = this.resolvedProperty;
        for (let i = 0, r = n.length; i !== r; ++i)
            e[t++] = n[i]
    }
    _getValue_arrayElement(e, t) {
        e[t] = this.resolvedProperty[this.propertyIndex]
    }
    _getValue_toArray(e, t) {
        this.resolvedProperty.toArray(e, t)
    }
    _setValue_direct(e, t) {
        this.targetObject[this.propertyName] = e[t]
    }
    _setValue_direct_setNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t],
        this.targetObject.needsUpdate = !0
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t],
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_array(e, t) {
        const n = this.resolvedProperty;
        for (let i = 0, r = n.length; i !== r; ++i)
            n[i] = e[t++]
    }
    _setValue_array_setNeedsUpdate(e, t) {
        const n = this.resolvedProperty;
        for (let i = 0, r = n.length; i !== r; ++i)
            n[i] = e[t++];
        this.targetObject.needsUpdate = !0
    }
    _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
        const n = this.resolvedProperty;
        for (let i = 0, r = n.length; i !== r; ++i)
            n[i] = e[t++];
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_arrayElement(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t]
    }
    _setValue_arrayElement_setNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t],
        this.targetObject.needsUpdate = !0
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t],
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_fromArray(e, t) {
        this.resolvedProperty.fromArray(e, t)
    }
    _setValue_fromArray_setNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t),
        this.targetObject.needsUpdate = !0
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t),
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _getValue_unbound(e, t) {
        this.bind(),
        this.getValue(e, t)
    }
    _setValue_unbound(e, t) {
        this.bind(),
        this.setValue(e, t)
    }
    bind() {
        let e = this.node;
        const t = this.parsedPath
          , n = t.objectName
          , i = t.propertyName;
        let r = t.propertyIndex;
        if (e || (e = wu.findNode(this.rootNode, t.nodeName) || this.rootNode,
        this.node = e),
        this.getValue = this._getValue_unavailable,
        this.setValue = this._setValue_unavailable,
        !e)
            return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
        if (n) {
            let i = t.objectIndex;
            switch (n) {
            case "materials":
                if (!e.material)
                    return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                if (!e.material.materials)
                    return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                e = e.material.materials;
                break;
            case "bones":
                if (!e.skeleton)
                    return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                e = e.skeleton.bones;
                for (let t = 0; t < e.length; t++)
                    if (e[t].name === i) {
                        i = t;
                        break
                    }
                break;
            case "map":
                if (!e.material)
                    return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                if (!e.material.map)
                    return void console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                e = e.material.map;
                break;
            default:
                if (void 0 === e[n])
                    return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                e = e[n]
            }
            if (void 0 !== i) {
                if (void 0 === e[i])
                    return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                e = e[i]
            }
        }
        const s = e[i];
        if (void 0 === s) {
            const n = t.nodeName;
            return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + i + " but it wasn't found.", e)
        }
        let a = this.Versioning.None;
        this.targetObject = e,
        void 0 !== e.needsUpdate ? a = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (a = this.Versioning.MatrixWorldNeedsUpdate);
        let o = this.BindingType.Direct;
        if (void 0 !== r) {
            if ("morphTargetInfluences" === i) {
                if (!e.geometry)
                    return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                if (!e.geometry.morphAttributes)
                    return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                void 0 !== e.morphTargetDictionary[r] && (r = e.morphTargetDictionary[r])
            }
            o = this.BindingType.ArrayElement,
            this.resolvedProperty = s,
            this.propertyIndex = r
        } else
            void 0 !== s.fromArray && void 0 !== s.toArray ? (o = this.BindingType.HasFromToArray,
            this.resolvedProperty = s) : Array.isArray(s) ? (o = this.BindingType.EntireArray,
            this.resolvedProperty = s) : this.propertyName = i;
        this.getValue = this.GetterByBindingType[o],
        this.setValue = this.SetterByBindingTypeAndVersioning[o][a]
    }
    unbind() {
        this.node = null,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound
    }
}
wu.Composite = class {
    constructor(e, t, n) {
        const i = n || wu.parseTrackName(t);
        this._targetGroup = e,
        this._bindings = e.subscribe_(t, i)
    }
    getValue(e, t) {
        this.bind();
        const n = this._targetGroup.nCachedObjects_
          , i = this._bindings[n];
        void 0 !== i && i.getValue(e, t)
    }
    setValue(e, t) {
        const n = this._bindings;
        for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i)
            n[i].setValue(e, t)
    }
    bind() {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
            e[t].bind()
    }
    unbind() {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
            e[t].unbind()
    }
}
,
wu.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
},
wu.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
},
wu.prototype.GetterByBindingType = [wu.prototype._getValue_direct, wu.prototype._getValue_array, wu.prototype._getValue_arrayElement, wu.prototype._getValue_toArray],
wu.prototype.SetterByBindingTypeAndVersioning = [[wu.prototype._setValue_direct, wu.prototype._setValue_direct_setNeedsUpdate, wu.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [wu.prototype._setValue_array, wu.prototype._setValue_array_setNeedsUpdate, wu.prototype._setValue_array_setMatrixWorldNeedsUpdate], [wu.prototype._setValue_arrayElement, wu.prototype._setValue_arrayElement_setNeedsUpdate, wu.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [wu.prototype._setValue_fromArray, wu.prototype._setValue_fromArray_setNeedsUpdate, wu.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
class Su {
    constructor(e, t, n=null, i=t.blendMode) {
        this._mixer = e,
        this._clip = t,
        this._localRoot = n,
        this.blendMode = i;
        const r = t.tracks
          , s = r.length
          , a = new Array(s)
          , o = {
            endingStart: ht,
            endingEnd: ht
        };
        for (let e = 0; e !== s; ++e) {
            const t = r[e].createInterpolant(null);
            a[e] = t,
            t.settings = o
        }
        this._interpolantSettings = o,
        this._interpolants = a,
        this._propertyBindings = new Array(s),
        this._cacheIndex = null,
        this._byClipCacheIndex = null,
        this._timeScaleInterpolant = null,
        this._weightInterpolant = null,
        this.loop = 2201,
        this._loopCount = -1,
        this._startTime = null,
        this.time = 0,
        this.timeScale = 1,
        this._effectiveTimeScale = 1,
        this.weight = 1,
        this._effectiveWeight = 1,
        this.repetitions = Infinity,
        this.paused = !1,
        this.enabled = !0,
        this.clampWhenFinished = !1,
        this.zeroSlopeAtStart = !0,
        this.zeroSlopeAtEnd = !0
    }
    play() {
        return this._mixer._activateAction(this),
        this
    }
    stop() {
        return this._mixer._deactivateAction(this),
        this.reset()
    }
    reset() {
        return this.paused = !1,
        this.enabled = !0,
        this.time = 0,
        this._loopCount = -1,
        this._startTime = null,
        this.stopFading().stopWarping()
    }
    isRunning() {
        return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
    }
    isScheduled() {
        return this._mixer._isActiveAction(this)
    }
    startAt(e) {
        return this._startTime = e,
        this
    }
    setLoop(e, t) {
        return this.loop = e,
        this.repetitions = t,
        this
    }
    setEffectiveWeight(e) {
        return this.weight = e,
        this._effectiveWeight = this.enabled ? e : 0,
        this.stopFading()
    }
    getEffectiveWeight() {
        return this._effectiveWeight
    }
    fadeIn(e) {
        return this._scheduleFading(e, 0, 1)
    }
    fadeOut(e) {
        return this._scheduleFading(e, 1, 0)
    }
    crossFadeFrom(e, t, n) {
        if (e.fadeOut(t),
        this.fadeIn(t),
        n) {
            const n = this._clip.duration
              , i = e._clip.duration
              , r = i / n
              , s = n / i;
            e.warp(1, r, t),
            this.warp(s, 1, t)
        }
        return this
    }
    crossFadeTo(e, t, n) {
        return e.crossFadeFrom(this, t, n)
    }
    stopFading() {
        const e = this._weightInterpolant;
        return null !== e && (this._weightInterpolant = null,
        this._mixer._takeBackControlInterpolant(e)),
        this
    }
    setEffectiveTimeScale(e) {
        return this.timeScale = e,
        this._effectiveTimeScale = this.paused ? 0 : e,
        this.stopWarping()
    }
    getEffectiveTimeScale() {
        return this._effectiveTimeScale
    }
    setDuration(e) {
        return this.timeScale = this._clip.duration / e,
        this.stopWarping()
    }
    syncWith(e) {
        return this.time = e.time,
        this.timeScale = e.timeScale,
        this.stopWarping()
    }
    halt(e) {
        return this.warp(this._effectiveTimeScale, 0, e)
    }
    warp(e, t, n) {
        const i = this._mixer
          , r = i.time
          , s = this.timeScale;
        let a = this._timeScaleInterpolant;
        null === a && (a = i._lendControlInterpolant(),
        this._timeScaleInterpolant = a);
        const o = a.parameterPositions
          , l = a.sampleValues;
        return o[0] = r,
        o[1] = r + n,
        l[0] = e / s,
        l[1] = t / s,
        this
    }
    stopWarping() {
        const e = this._timeScaleInterpolant;
        return null !== e && (this._timeScaleInterpolant = null,
        this._mixer._takeBackControlInterpolant(e)),
        this
    }
    getMixer() {
        return this._mixer
    }
    getClip() {
        return this._clip
    }
    getRoot() {
        return this._localRoot || this._mixer._root
    }
    _update(e, t, n, i) {
        if (!this.enabled)
            return void this._updateWeight(e);
        const r = this._startTime;
        if (null !== r) {
            const i = (e - r) * n;
            i < 0 || 0 === n ? t = 0 : (this._startTime = null,
            t = n * i)
        }
        t *= this._updateTimeScale(e);
        const s = this._updateTime(t)
          , a = this._updateWeight(e);
        if (a > 0) {
            const e = this._interpolants
              , t = this._propertyBindings;
            if (this.blendMode === mt)
                for (let n = 0, i = e.length; n !== i; ++n)
                    e[n].evaluate(s),
                    t[n].accumulateAdditive(a);
            else
                for (let n = 0, r = e.length; n !== r; ++n)
                    e[n].evaluate(s),
                    t[n].accumulate(i, a)
        }
    }
    _updateWeight(e) {
        let t = 0;
        if (this.enabled) {
            t = this.weight;
            const n = this._weightInterpolant;
            if (null !== n) {
                const i = n.evaluate(e)[0];
                t *= i,
                e > n.parameterPositions[1] && (this.stopFading(),
                0 === i && (this.enabled = !1))
            }
        }
        return this._effectiveWeight = t,
        t
    }
    _updateTimeScale(e) {
        let t = 0;
        if (!this.paused) {
            t = this.timeScale;
            const n = this._timeScaleInterpolant;
            if (null !== n) {
                t *= n.evaluate(e)[0],
                e > n.parameterPositions[1] && (this.stopWarping(),
                0 === t ? this.paused = !0 : this.timeScale = t)
            }
        }
        return this._effectiveTimeScale = t,
        t
    }
    _updateTime(e) {
        const t = this._clip.duration
          , n = this.loop;
        let i = this.time + e
          , r = this._loopCount;
        const s = 2202 === n;
        if (0 === e)
            return -1 === r ? i : s && 1 == (1 & r) ? t - i : i;
        if (n === at) {
            -1 === r && (this._loopCount = 0,
            this._setEndings(!0, !0, !1));
            e: {
                if (i >= t)
                    i = t;
                else {
                    if (!(i < 0)) {
                        this.time = i;
                        break e
                    }
                    i = 0
                }
                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                this.time = i,
                this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: e < 0 ? -1 : 1
                })
            }
        } else {
            if (-1 === r && (e >= 0 ? (r = 0,
            this._setEndings(!0, 0 === this.repetitions, s)) : this._setEndings(0 === this.repetitions, !0, s)),
            i >= t || i < 0) {
                const n = Math.floor(i / t);
                i -= t * n,
                r += Math.abs(n);
                const a = this.repetitions - r;
                if (a <= 0)
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                    i = e > 0 ? t : 0,
                    this.time = i,
                    this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: e > 0 ? 1 : -1
                    });
                else {
                    if (1 === a) {
                        const t = e < 0;
                        this._setEndings(t, !t, s)
                    } else
                        this._setEndings(!1, !1, s);
                    this._loopCount = r,
                    this.time = i,
                    this._mixer.dispatchEvent({
                        type: "loop",
                        action: this,
                        loopDelta: n
                    })
                }
            } else
                this.time = i;
            if (s && 1 == (1 & r))
                return t - i
        }
        return i
    }
    _setEndings(e, t, n) {
        const i = this._interpolantSettings;
        n ? (i.endingStart = ut,
        i.endingEnd = ut) : (i.endingStart = e ? this.zeroSlopeAtStart ? ut : ht : dt,
        i.endingEnd = t ? this.zeroSlopeAtEnd ? ut : ht : dt)
    }
    _scheduleFading(e, t, n) {
        const i = this._mixer
          , r = i.time;
        let s = this._weightInterpolant;
        null === s && (s = i._lendControlInterpolant(),
        this._weightInterpolant = s);
        const a = s.parameterPositions
          , o = s.sampleValues;
        return a[0] = r,
        o[0] = t,
        a[1] = r + e,
        o[1] = n,
        this
    }
}
const Tu = new Float32Array(1);
class Au extends wt {
    constructor(e) {
        super(),
        this._root = e,
        this._initMemoryManager(),
        this._accuIndex = 0,
        this.time = 0,
        this.timeScale = 1
    }
    _bindAction(e, t) {
        const n = e._localRoot || this._root
          , i = e._clip.tracks
          , r = i.length
          , s = e._propertyBindings
          , a = e._interpolants
          , o = n.uuid
          , l = this._bindingsByRootAndName;
        let c = l[o];
        void 0 === c && (c = {},
        l[o] = c);
        for (let e = 0; e !== r; ++e) {
            const r = i[e]
              , l = r.name;
            let h = c[l];
            if (void 0 !== h)
                ++h.referenceCount,
                s[e] = h;
            else {
                if (h = s[e],
                void 0 !== h) {
                    null === h._cacheIndex && (++h.referenceCount,
                    this._addInactiveBinding(h, o, l));
                    continue
                }
                const i = t && t._propertyBindings[e].binding.parsedPath;
                h = new gu(wu.create(n, l, i),r.ValueTypeName,r.getValueSize()),
                ++h.referenceCount,
                this._addInactiveBinding(h, o, l),
                s[e] = h
            }
            a[e].resultBuffer = h.buffer
        }
    }
    _activateAction(e) {
        if (!this._isActiveAction(e)) {
            if (null === e._cacheIndex) {
                const t = (e._localRoot || this._root).uuid
                  , n = e._clip.uuid
                  , i = this._actionsByClip[n];
                this._bindAction(e, i && i.knownActions[0]),
                this._addInactiveAction(e, n, t)
            }
            const t = e._propertyBindings;
            for (let e = 0, n = t.length; e !== n; ++e) {
                const n = t[e];
                0 == n.useCount++ && (this._lendBinding(n),
                n.saveOriginalState())
            }
            this._lendAction(e)
        }
    }
    _deactivateAction(e) {
        if (this._isActiveAction(e)) {
            const t = e._propertyBindings;
            for (let e = 0, n = t.length; e !== n; ++e) {
                const n = t[e];
                0 == --n.useCount && (n.restoreOriginalState(),
                this._takeBackBinding(n))
            }
            this._takeBackAction(e)
        }
    }
    _initMemoryManager() {
        this._actions = [],
        this._nActiveActions = 0,
        this._actionsByClip = {},
        this._bindings = [],
        this._nActiveBindings = 0,
        this._bindingsByRootAndName = {},
        this._controlInterpolants = [],
        this._nActiveControlInterpolants = 0;
        const e = this;
        this.stats = {
            actions: {
                get total() {
                    return e._actions.length
                },
                get inUse() {
                    return e._nActiveActions
                }
            },
            bindings: {
                get total() {
                    return e._bindings.length
                },
                get inUse() {
                    return e._nActiveBindings
                }
            },
            controlInterpolants: {
                get total() {
                    return e._controlInterpolants.length
                },
                get inUse() {
                    return e._nActiveControlInterpolants
                }
            }
        }
    }
    _isActiveAction(e) {
        const t = e._cacheIndex;
        return null !== t && t < this._nActiveActions
    }
    _addInactiveAction(e, t, n) {
        const i = this._actions
          , r = this._actionsByClip;
        let s = r[t];
        if (void 0 === s)
            s = {
                knownActions: [e],
                actionByRoot: {}
            },
            e._byClipCacheIndex = 0,
            r[t] = s;
        else {
            const t = s.knownActions;
            e._byClipCacheIndex = t.length,
            t.push(e)
        }
        e._cacheIndex = i.length,
        i.push(e),
        s.actionByRoot[n] = e
    }
    _removeInactiveAction(e) {
        const t = this._actions
          , n = t[t.length - 1]
          , i = e._cacheIndex;
        n._cacheIndex = i,
        t[i] = n,
        t.pop(),
        e._cacheIndex = null;
        const r = e._clip.uuid
          , s = this._actionsByClip
          , a = s[r]
          , o = a.knownActions
          , l = o[o.length - 1]
          , c = e._byClipCacheIndex;
        l._byClipCacheIndex = c,
        o[c] = l,
        o.pop(),
        e._byClipCacheIndex = null;
        delete a.actionByRoot[(e._localRoot || this._root).uuid],
        0 === o.length && delete s[r],
        this._removeInactiveBindingsForAction(e)
    }
    _removeInactiveBindingsForAction(e) {
        const t = e._propertyBindings;
        for (let e = 0, n = t.length; e !== n; ++e) {
            const n = t[e];
            0 == --n.referenceCount && this._removeInactiveBinding(n)
        }
    }
    _lendAction(e) {
        const t = this._actions
          , n = e._cacheIndex
          , i = this._nActiveActions++
          , r = t[i];
        e._cacheIndex = i,
        t[i] = e,
        r._cacheIndex = n,
        t[n] = r
    }
    _takeBackAction(e) {
        const t = this._actions
          , n = e._cacheIndex
          , i = --this._nActiveActions
          , r = t[i];
        e._cacheIndex = i,
        t[i] = e,
        r._cacheIndex = n,
        t[n] = r
    }
    _addInactiveBinding(e, t, n) {
        const i = this._bindingsByRootAndName
          , r = this._bindings;
        let s = i[t];
        void 0 === s && (s = {},
        i[t] = s),
        s[n] = e,
        e._cacheIndex = r.length,
        r.push(e)
    }
    _removeInactiveBinding(e) {
        const t = this._bindings
          , n = e.binding
          , i = n.rootNode.uuid
          , r = n.path
          , s = this._bindingsByRootAndName
          , a = s[i]
          , o = t[t.length - 1]
          , l = e._cacheIndex;
        o._cacheIndex = l,
        t[l] = o,
        t.pop(),
        delete a[r],
        0 === Object.keys(a).length && delete s[i]
    }
    _lendBinding(e) {
        const t = this._bindings
          , n = e._cacheIndex
          , i = this._nActiveBindings++
          , r = t[i];
        e._cacheIndex = i,
        t[i] = e,
        r._cacheIndex = n,
        t[n] = r
    }
    _takeBackBinding(e) {
        const t = this._bindings
          , n = e._cacheIndex
          , i = --this._nActiveBindings
          , r = t[i];
        e._cacheIndex = i,
        t[i] = e,
        r._cacheIndex = n,
        t[n] = r
    }
    _lendControlInterpolant() {
        const e = this._controlInterpolants
          , t = this._nActiveControlInterpolants++;
        let n = e[t];
        return void 0 === n && (n = new rh(new Float32Array(2),new Float32Array(2),1,Tu),
        n.__cacheIndex = t,
        e[t] = n),
        n
    }
    _takeBackControlInterpolant(e) {
        const t = this._controlInterpolants
          , n = e.__cacheIndex
          , i = --this._nActiveControlInterpolants
          , r = t[i];
        e.__cacheIndex = i,
        t[i] = e,
        r.__cacheIndex = n,
        t[n] = r
    }
    clipAction(e, t, n) {
        const i = t || this._root
          , r = i.uuid;
        let s = "string" == typeof e ? mh.findByName(i, e) : e;
        const a = null !== s ? s.uuid : e
          , o = this._actionsByClip[a];
        let l = null;
        if (void 0 === n && (n = null !== s ? s.blendMode : pt),
        void 0 !== o) {
            const e = o.actionByRoot[r];
            if (void 0 !== e && e.blendMode === n)
                return e;
            l = o.knownActions[0],
            null === s && (s = l._clip)
        }
        if (null === s)
            return null;
        const c = new Su(this,s,t,n);
        return this._bindAction(c, l),
        this._addInactiveAction(c, a, r),
        c
    }
    existingAction(e, t) {
        const n = t || this._root
          , i = n.uuid
          , r = "string" == typeof e ? mh.findByName(n, e) : e
          , s = r ? r.uuid : e
          , a = this._actionsByClip[s];
        return void 0 !== a && a.actionByRoot[i] || null
    }
    stopAllAction() {
        const e = this._actions;
        for (let t = this._nActiveActions - 1; t >= 0; --t)
            e[t].stop();
        return this
    }
    update(e) {
        e *= this.timeScale;
        const t = this._actions
          , n = this._nActiveActions
          , i = this.time += e
          , r = Math.sign(e)
          , s = this._accuIndex ^= 1;
        for (let a = 0; a !== n; ++a) {
            t[a]._update(i, e, r, s)
        }
        const a = this._bindings
          , o = this._nActiveBindings;
        for (let e = 0; e !== o; ++e)
            a[e].apply(s);
        return this
    }
    setTime(e) {
        this.time = 0;
        for (let e = 0; e < this._actions.length; e++)
            this._actions[e].time = 0;
        return this.update(e)
    }
    getRoot() {
        return this._root
    }
    uncacheClip(e) {
        const t = this._actions
          , n = e.uuid
          , i = this._actionsByClip
          , r = i[n];
        if (void 0 !== r) {
            const e = r.knownActions;
            for (let n = 0, i = e.length; n !== i; ++n) {
                const i = e[n];
                this._deactivateAction(i);
                const r = i._cacheIndex
                  , s = t[t.length - 1];
                i._cacheIndex = null,
                i._byClipCacheIndex = null,
                s._cacheIndex = r,
                t[r] = s,
                t.pop(),
                this._removeInactiveBindingsForAction(i)
            }
            delete i[n]
        }
    }
    uncacheRoot(e) {
        const t = e.uuid
          , n = this._actionsByClip;
        for (const e in n) {
            const i = n[e].actionByRoot[t];
            void 0 !== i && (this._deactivateAction(i),
            this._removeInactiveAction(i))
        }
        const i = this._bindingsByRootAndName[t];
        if (void 0 !== i)
            for (const e in i) {
                const t = i[e];
                t.restoreOriginalState(),
                this._removeInactiveBinding(t)
            }
    }
    uncacheAction(e, t) {
        const n = this.existingAction(e, t);
        null !== n && (this._deactivateAction(n),
        this._removeInactiveAction(n))
    }
}
class Eu {
    constructor(e) {
        this.value = e
    }
    clone() {
        return new Eu(void 0 === this.value.clone ? this.value : this.value.clone())
    }
}
let Cu = 0;
class Lu {
    constructor(e, t, n=0, i=Infinity) {
        this.ray = new Vn(e,t),
        this.near = n,
        this.far = i,
        this.camera = null,
        this.layers = new ti,
        this.params = {
            Mesh: {},
            Line: {
                threshold: 1
            },
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        }
    }
    set(e, t) {
        this.ray.set(e, t)
    }
    setFromCamera(e, t) {
        t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
        this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(),
        this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t),
        this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
        this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
    }
    intersectObject(e, t=!0, n=[]) {
        return Pu(e, this, n, t),
        n.sort(Ru),
        n
    }
    intersectObjects(e, t=!0, n=[]) {
        for (let i = 0, r = e.length; i < r; i++)
            Pu(e[i], this, n, t);
        return n.sort(Ru),
        n
    }
}
function Ru(e, t) {
    return e.distance - t.distance
}
function Pu(e, t, n, i) {
    if (e.layers.test(t.layers) && e.raycast(t, n),
    !0 === i) {
        const i = e.children;
        for (let e = 0, r = i.length; e < r; e++)
            Pu(i[e], t, n, !0)
    }
}
class Iu {
    constructor(e=1, t=0, n=0) {
        return this.radius = e,
        this.phi = t,
        this.theta = n,
        this
    }
    set(e, t, n) {
        return this.radius = e,
        this.phi = t,
        this.theta = n,
        this
    }
    copy(e) {
        return this.radius = e.radius,
        this.phi = e.phi,
        this.theta = e.theta,
        this
    }
    makeSafe() {
        const e = 1e-6;
        return this.phi = Math.max(e, Math.min(Math.PI - e, this.phi)),
        this
    }
    setFromVector3(e) {
        return this.setFromCartesianCoords(e.x, e.y, e.z)
    }
    setFromCartesianCoords(e, t, n) {
        return this.radius = Math.sqrt(e * e + t * t + n * n),
        0 === this.radius ? (this.theta = 0,
        this.phi = 0) : (this.theta = Math.atan2(e, n),
        this.phi = Math.acos(Lt(t / this.radius, -1, 1))),
        this
    }
    clone() {
        return (new this.constructor).copy(this)
    }
}
const Du = new Ft;
const Ou = new pn
  , Nu = new pn;
const zu = new pn;
const Uu = new pn
  , Fu = new Wn
  , Bu = new Wn;
function ku(e) {
    const t = [];
    !0 === e.isBone && t.push(e);
    for (let n = 0; n < e.children.length; n++)
        t.push.apply(t, ku(e.children[n]));
    return t
}
class Gu extends or {
    constructor(e, t, n) {
        super(new Pc(t,4,2), new Li({
            wireframe: !0,
            fog: !1,
            toneMapped: !1
        })),
        this.light = e,
        this.light.updateMatrixWorld(),
        this.color = n,
        this.type = "PointLightHelper",
        this.matrix = this.light.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.update()
    }
    dispose() {
        this.geometry.dispose(),
        this.material.dispose()
    }
    update() {
        void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
    }
}
const Hu = new pn
  , Vu = new en
  , Wu = new en;
const ju = new pn
  , Xu = new pn
  , qu = new pn;
const Yu = new pn
  , Zu = new mr;
function Ju(e, t, n, i, r, s, a) {
    Yu.set(r, s, a).unproject(i);
    const o = t[e];
    if (void 0 !== o) {
        const e = n.getAttribute("position");
        for (let t = 0, n = o.length; t < n; t++)
            e.setXYZ(o[t], Yu.x, Yu.y, Yu.z)
    }
}
const Ku = new gn;
const Qu = new pn;
let $u, ed;
class td {
    constructor() {
        this.type = "ShapePath",
        this.color = new en,
        this.subPaths = [],
        this.currentPath = null
    }
    moveTo(e, t) {
        return this.currentPath = new Ul,
        this.subPaths.push(this.currentPath),
        this.currentPath.moveTo(e, t),
        this
    }
    lineTo(e, t) {
        return this.currentPath.lineTo(e, t),
        this
    }
    quadraticCurveTo(e, t, n, i) {
        return this.currentPath.quadraticCurveTo(e, t, n, i),
        this
    }
    bezierCurveTo(e, t, n, i, r, s) {
        return this.currentPath.bezierCurveTo(e, t, n, i, r, s),
        this
    }
    splineThru(e) {
        return this.currentPath.splineThru(e),
        this
    }
    toShapes(e) {
        function t(e, t) {
            const n = t.length;
            let i = !1;
            for (let r = n - 1, s = 0; s < n; r = s++) {
                let n = t[r]
                  , a = t[s]
                  , o = a.x - n.x
                  , l = a.y - n.y;
                if (Math.abs(l) > Number.EPSILON) {
                    if (l < 0 && (n = t[s],
                    o = -o,
                    a = t[r],
                    l = -l),
                    e.y < n.y || e.y > a.y)
                        continue;
                    if (e.y === n.y) {
                        if (e.x === n.x)
                            return !0
                    } else {
                        const t = l * (e.x - n.x) - o * (e.y - n.y);
                        if (0 === t)
                            return !0;
                        if (t < 0)
                            continue;
                        i = !i
                    }
                } else {
                    if (e.y !== n.y)
                        continue;
                    if (a.x <= e.x && e.x <= n.x || n.x <= e.x && e.x <= a.x)
                        return !0
                }
            }
            return i
        }
        const n = Mc.isClockWise
          , i = this.subPaths;
        if (0 === i.length)
            return [];
        let r, s, a;
        const o = [];
        if (1 === i.length)
            return s = i[0],
            a = new Jl,
            a.curves = s.curves,
            o.push(a),
            o;
        let l = !n(i[0].getPoints());
        l = e ? !l : l;
        const c = []
          , h = [];
        let u, d, p = [], m = 0;
        h[m] = void 0,
        p[m] = [];
        for (let t = 0, a = i.length; t < a; t++)
            s = i[t],
            u = s.getPoints(),
            r = n(u),
            r = e ? !r : r,
            r ? (!l && h[m] && m++,
            h[m] = {
                s: new Jl,
                p: u
            },
            h[m].s.curves = s.curves,
            l && m++,
            p[m] = []) : p[m].push({
                h: s,
                p: u[0]
            });
        if (!h[0])
            return function(e) {
                const t = [];
                for (let n = 0, i = e.length; n < i; n++) {
                    const i = e[n]
                      , r = new Jl;
                    r.curves = i.curves,
                    t.push(r)
                }
                return t
            }(i);
        if (h.length > 1) {
            let e = !1
              , n = 0;
            for (let e = 0, t = h.length; e < t; e++)
                c[e] = [];
            for (let i = 0, r = h.length; i < r; i++) {
                const r = p[i];
                for (let s = 0; s < r.length; s++) {
                    const a = r[s];
                    let o = !0;
                    for (let r = 0; r < h.length; r++)
                        t(a.p, h[r].p) && (i !== r && n++,
                        o ? (o = !1,
                        c[r].push(a)) : e = !0);
                    o && c[i].push(a)
                }
            }
            n > 0 && !1 === e && (p = c)
        }
        for (let e = 0, t = h.length; e < t; e++) {
            a = h[e].s,
            o.push(a),
            d = p[e];
            for (let e = 0, t = d.length; e < t; e++)
                a.holes.push(d[e].h)
        }
        return o
    }
}
const nd = id();
function id() {
    const e = new ArrayBuffer(4)
      , t = new Float32Array(e)
      , n = new Uint32Array(e)
      , i = new Uint32Array(512)
      , r = new Uint32Array(512);
    for (let e = 0; e < 256; ++e) {
        const t = e - 127;
        t < -27 ? (i[e] = 0,
        i[256 | e] = 32768,
        r[e] = 24,
        r[256 | e] = 24) : t < -14 ? (i[e] = 1024 >> -t - 14,
        i[256 | e] = 1024 >> -t - 14 | 32768,
        r[e] = -t - 1,
        r[256 | e] = -t - 1) : t <= 15 ? (i[e] = t + 15 << 10,
        i[256 | e] = t + 15 << 10 | 32768,
        r[e] = 13,
        r[256 | e] = 13) : t < 128 ? (i[e] = 31744,
        i[256 | e] = 64512,
        r[e] = 24,
        r[256 | e] = 24) : (i[e] = 31744,
        i[256 | e] = 64512,
        r[e] = 13,
        r[256 | e] = 13)
    }
    const s = new Uint32Array(2048)
      , a = new Uint32Array(64)
      , o = new Uint32Array(64);
    for (let e = 1; e < 1024; ++e) {
        let t = e << 13
          , n = 0;
        for (; 0 == (8388608 & t); )
            t <<= 1,
            n -= 8388608;
        t &= -8388609,
        n += 947912704,
        s[e] = t | n
    }
    for (let e = 1024; e < 2048; ++e)
        s[e] = 939524096 + (e - 1024 << 13);
    for (let e = 1; e < 31; ++e)
        a[e] = e << 23;
    a[31] = 1199570944,
    a[32] = 2147483648;
    for (let e = 33; e < 63; ++e)
        a[e] = 2147483648 + (e - 32 << 23);
    a[63] = 3347054592;
    for (let e = 1; e < 64; ++e)
        32 !== e && (o[e] = 1024);
    return {
        floatView: t,
        uint32View: n,
        baseTable: i,
        shiftTable: r,
        mantissaTable: s,
        exponentTable: a,
        offsetTable: o
    }
}
var rd = Object.freeze({
    __proto__: null,
    toHalfFloat: function(e) {
        Math.abs(e) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
        e = Lt(e, -65504, 65504),
        nd.floatView[0] = e;
        const t = nd.uint32View[0]
          , n = t >> 23 & 511;
        return nd.baseTable[n] + ((8388607 & t) >> nd.shiftTable[n])
    },
    fromHalfFloat: function(e) {
        const t = e >> 10;
        return nd.uint32View[0] = nd.mantissaTable[nd.offsetTable[t] + (1023 & e)] + nd.exponentTable[t],
        nd.floatView[0]
    }
});
class sd extends Pc {
    constructor(e, t, n, i, r, s, a) {
        console.warn("THREE.SphereBufferGeometry has been renamed to THREE.SphereGeometry."),
        super(e, t, n, i, r, s, a)
    }
}
"undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
    detail: {
        revision: ee
    }
})),
"undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = ee);
var ad = Object.freeze({
    __proto__: null,
    ACESFilmicToneMapping: 4,
    AddEquation: ce,
    AddOperation: 2,
    AdditiveAnimationBlendMode: mt,
    AdditiveBlending: 2,
    AlphaFormat: 1021,
    AlwaysDepth: 1,
    AlwaysStencilFunc: 519,
    AmbientLight: kh,
    AmbientLightProbe: class extends Vh {
        constructor(e, t=1) {
            super(void 0, t),
            this.isAmbientLightProbe = !0;
            const n = (new en).set(e);
            this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI))
        }
    }
    ,
    AnimationClip: mh,
    AnimationLoader: class extends yh {
        constructor(e) {
            super(e)
        }
        load(e, t, n, i) {
            const r = this
              , s = new Mh(this.manager);
            s.setPath(this.path),
            s.setRequestHeader(this.requestHeader),
            s.setWithCredentials(this.withCredentials),
            s.load(e, (function(n) {
                try {
                    t(r.parse(JSON.parse(n)))
                } catch (t) {
                    i ? i(t) : console.error(t),
                    r.manager.itemError(e)
                }
            }
            ), n, i)
        }
        parse(e) {
            const t = [];
            for (let n = 0; n < e.length; n++) {
                const i = mh.parse(e[n]);
                t.push(i)
            }
            return t
        }
    }
    ,
    AnimationMixer: Au,
    AnimationObjectGroup: class {
        constructor() {
            this.isAnimationObjectGroup = !0,
            this.uuid = Ct(),
            this._objects = Array.prototype.slice.call(arguments),
            this.nCachedObjects_ = 0;
            const e = {};
            this._indicesByUUID = e;
            for (let t = 0, n = arguments.length; t !== n; ++t)
                e[arguments[t].uuid] = t;
            this._paths = [],
            this._parsedPaths = [],
            this._bindings = [],
            this._bindingsIndicesByPath = {};
            const t = this;
            this.stats = {
                objects: {
                    get total() {
                        return t._objects.length
                    },
                    get inUse() {
                        return this.total - t.nCachedObjects_
                    }
                },
                get bindingsPerObject() {
                    return t._bindings.length
                }
            }
        }
        add() {
            const e = this._objects
              , t = this._indicesByUUID
              , n = this._paths
              , i = this._parsedPaths
              , r = this._bindings
              , s = r.length;
            let a, o = e.length, l = this.nCachedObjects_;
            for (let c = 0, h = arguments.length; c !== h; ++c) {
                const h = arguments[c]
                  , u = h.uuid;
                let d = t[u];
                if (void 0 === d) {
                    d = o++,
                    t[u] = d,
                    e.push(h);
                    for (let e = 0, t = s; e !== t; ++e)
                        r[e].push(new wu(h,n[e],i[e]))
                } else if (d < l) {
                    a = e[d];
                    const o = --l
                      , c = e[o];
                    t[c.uuid] = d,
                    e[d] = c,
                    t[u] = o,
                    e[o] = h;
                    for (let e = 0, t = s; e !== t; ++e) {
                        const t = r[e]
                          , s = t[o];
                        let a = t[d];
                        t[d] = s,
                        void 0 === a && (a = new wu(h,n[e],i[e])),
                        t[o] = a
                    }
                } else
                    e[d] !== a && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
            }
            this.nCachedObjects_ = l
        }
        remove() {
            const e = this._objects
              , t = this._indicesByUUID
              , n = this._bindings
              , i = n.length;
            let r = this.nCachedObjects_;
            for (let s = 0, a = arguments.length; s !== a; ++s) {
                const a = arguments[s]
                  , o = a.uuid
                  , l = t[o];
                if (void 0 !== l && l >= r) {
                    const s = r++
                      , c = e[s];
                    t[c.uuid] = l,
                    e[l] = c,
                    t[o] = s,
                    e[s] = a;
                    for (let e = 0, t = i; e !== t; ++e) {
                        const t = n[e]
                          , i = t[s]
                          , r = t[l];
                        t[l] = i,
                        t[s] = r
                    }
                }
            }
            this.nCachedObjects_ = r
        }
        uncache() {
            const e = this._objects
              , t = this._indicesByUUID
              , n = this._bindings
              , i = n.length;
            let r = this.nCachedObjects_
              , s = e.length;
            for (let a = 0, o = arguments.length; a !== o; ++a) {
                const o = arguments[a].uuid
                  , l = t[o];
                if (void 0 !== l)
                    if (delete t[o],
                    l < r) {
                        const a = --r
                          , o = e[a]
                          , c = --s
                          , h = e[c];
                        t[o.uuid] = l,
                        e[l] = o,
                        t[h.uuid] = a,
                        e[a] = h,
                        e.pop();
                        for (let e = 0, t = i; e !== t; ++e) {
                            const t = n[e]
                              , i = t[a]
                              , r = t[c];
                            t[l] = i,
                            t[a] = r,
                            t.pop()
                        }
                    } else {
                        const r = --s
                          , a = e[r];
                        r > 0 && (t[a.uuid] = l),
                        e[l] = a,
                        e.pop();
                        for (let e = 0, t = i; e !== t; ++e) {
                            const t = n[e];
                            t[l] = t[r],
                            t.pop()
                        }
                    }
            }
            this.nCachedObjects_ = r
        }
        subscribe_(e, t) {
            const n = this._bindingsIndicesByPath;
            let i = n[e];
            const r = this._bindings;
            if (void 0 !== i)
                return r[i];
            const s = this._paths
              , a = this._parsedPaths
              , o = this._objects
              , l = o.length
              , c = this.nCachedObjects_
              , h = new Array(l);
            i = r.length,
            n[e] = i,
            s.push(e),
            a.push(t),
            r.push(h);
            for (let n = c, i = o.length; n !== i; ++n) {
                const i = o[n];
                h[n] = new wu(i,e,t)
            }
            return h
        }
        unsubscribe_(e) {
            const t = this._bindingsIndicesByPath
              , n = t[e];
            if (void 0 !== n) {
                const i = this._paths
                  , r = this._parsedPaths
                  , s = this._bindings
                  , a = s.length - 1
                  , o = s[a];
                t[e[a]] = n,
                s[n] = o,
                s.pop(),
                r[n] = r[a],
                r.pop(),
                i[n] = i[a],
                i.pop()
            }
        }
    }
    ,
    AnimationUtils: th,
    ArcCurve: xl,
    ArrayCamera: Ja,
    ArrowHelper: class extends fi {
        constructor(e=new pn(0,0,1), t=new pn(0,0,0), n=1, i=16776960, r=.2 * n, s=.2 * r) {
            super(),
            this.type = "ArrowHelper",
            void 0 === $u && ($u = new Vi,
            $u.setAttribute("position", new Ni([0, 0, 0, 0, 1, 0],3)),
            ed = new Gl(0,.5,1,5,1),
            ed.translate(0, -.5, 0)),
            this.position.copy(t),
            this.line = new tl($u,new Zo({
                color: i,
                toneMapped: !1
            })),
            this.line.matrixAutoUpdate = !1,
            this.add(this.line),
            this.cone = new or(ed,new Li({
                color: i,
                toneMapped: !1
            })),
            this.cone.matrixAutoUpdate = !1,
            this.add(this.cone),
            this.setDirection(e),
            this.setLength(n, r, s)
        }
        setDirection(e) {
            if (e.y > .99999)
                this.quaternion.set(0, 0, 0, 1);
            else if (e.y < -.99999)
                this.quaternion.set(1, 0, 0, 0);
            else {
                Qu.set(e.z, 0, -e.x).normalize();
                const t = Math.acos(e.y);
                this.quaternion.setFromAxisAngle(Qu, t)
            }
        }
        setLength(e, t=.2 * e, n=.2 * t) {
            this.line.scale.set(1, Math.max(1e-4, e - t), 1),
            this.line.updateMatrix(),
            this.cone.scale.set(n, t, n),
            this.cone.position.y = e,
            this.cone.updateMatrix()
        }
        setColor(e) {
            this.line.material.color.set(e),
            this.cone.material.color.set(e)
        }
        copy(e) {
            return super.copy(e, !1),
            this.line.copy(e.line),
            this.cone.copy(e.cone),
            this
        }
    }
    ,
    Audio: uu,
    AudioAnalyser: class {
        constructor(e, t=2048) {
            this.analyser = e.context.createAnalyser(),
            this.analyser.fftSize = t,
            this.data = new Uint8Array(this.analyser.frequencyBinCount),
            e.getOutput().connect(this.analyser)
        }
        getFrequencyData() {
            return this.analyser.getByteFrequencyData(this.data),
            this.data
        }
        getAverageFrequency() {
            let e = 0;
            const t = this.getFrequencyData();
            for (let n = 0; n < t.length; n++)
                e += t[n];
            return e / t.length
        }
    }
    ,
    AudioContext: $h,
    AudioListener: hu,
    AudioLoader: eu,
    AxesHelper: class extends rl {
        constructor(e=1) {
            const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e]
              , n = new Vi;
            n.setAttribute("position", new Ni(t,3)),
            n.setAttribute("color", new Ni([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1],3));
            super(n, new Zo({
                vertexColors: !0,
                toneMapped: !1
            })),
            this.type = "AxesHelper"
        }
        setColors(e, t, n) {
            const i = new en
              , r = this.geometry.attributes.color.array;
            return i.set(e),
            i.toArray(r, 0),
            i.toArray(r, 3),
            i.set(t),
            i.toArray(r, 6),
            i.toArray(r, 9),
            i.set(n),
            i.toArray(r, 12),
            i.toArray(r, 15),
            this.geometry.attributes.color.needsUpdate = !0,
            this
        }
        dispose() {
            this.geometry.dispose(),
            this.material.dispose()
        }
    }
    ,
    BackSide: 1,
    BasicDepthPacking: 3200,
    BasicShadowMap: 0,
    Bone: Fo,
    BooleanKeyframeTrack: oh,
    Box2: class {
        constructor(e=new Ft(Infinity,Infinity), t=new Ft(-Infinity,-Infinity)) {
            this.isBox2 = !0,
            this.min = e,
            this.max = t
        }
        set(e, t) {
            return this.min.copy(e),
            this.max.copy(t),
            this
        }
        setFromPoints(e) {
            this.makeEmpty();
            for (let t = 0, n = e.length; t < n; t++)
                this.expandByPoint(e[t]);
            return this
        }
        setFromCenterAndSize(e, t) {
            const n = Du.copy(t).multiplyScalar(.5);
            return this.min.copy(e).sub(n),
            this.max.copy(e).add(n),
            this
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(e) {
            return this.min.copy(e.min),
            this.max.copy(e.max),
            this
        }
        makeEmpty() {
            return this.min.x = this.min.y = Infinity,
            this.max.x = this.max.y = -Infinity,
            this
        }
        isEmpty() {
            return this.max.x < this.min.x || this.max.y < this.min.y
        }
        getCenter(e) {
            return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
        }
        getSize(e) {
            return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
        }
        expandByPoint(e) {
            return this.min.min(e),
            this.max.max(e),
            this
        }
        expandByVector(e) {
            return this.min.sub(e),
            this.max.add(e),
            this
        }
        expandByScalar(e) {
            return this.min.addScalar(-e),
            this.max.addScalar(e),
            this
        }
        containsPoint(e) {
            return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
        }
        containsBox(e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
        }
        getParameter(e, t) {
            return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
        }
        intersectsBox(e) {
            return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
        }
        clampPoint(e, t) {
            return t.copy(e).clamp(this.min, this.max)
        }
        distanceToPoint(e) {
            return Du.copy(e).clamp(this.min, this.max).sub(e).length()
        }
        intersect(e) {
            return this.min.max(e.min),
            this.max.min(e.max),
            this
        }
        union(e) {
            return this.min.min(e.min),
            this.max.max(e.max),
            this
        }
        translate(e) {
            return this.min.add(e),
            this.max.add(e),
            this
        }
        equals(e) {
            return e.min.equals(this.min) && e.max.equals(this.max)
        }
    }
    ,
    Box3: gn,
    Box3Helper: class extends rl {
        constructor(e, t=16776960) {
            const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
              , i = new Vi;
            i.setIndex(new Ii(n,1)),
            i.setAttribute("position", new Ni([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1],3)),
            super(i, new Zo({
                color: t,
                toneMapped: !1
            })),
            this.box = e,
            this.type = "Box3Helper",
            this.geometry.computeBoundingSphere()
        }
        updateMatrixWorld(e) {
            const t = this.box;
            t.isEmpty() || (t.getCenter(this.position),
            t.getSize(this.scale),
            this.scale.multiplyScalar(.5),
            super.updateMatrixWorld(e))
        }
    }
    ,
    BoxBufferGeometry: class extends cr {
        constructor(e, t, n, i, r, s) {
            console.warn("THREE.BoxBufferGeometry has been renamed to THREE.BoxGeometry."),
            super(e, t, n, i, r, s)
        }
    }
    ,
    BoxGeometry: cr,
    BoxHelper: class extends rl {
        constructor(e, t=16776960) {
            const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7])
              , i = new Float32Array(24)
              , r = new Vi;
            r.setIndex(new Ii(n,1)),
            r.setAttribute("position", new Ii(i,3)),
            super(r, new Zo({
                color: t,
                toneMapped: !1
            })),
            this.object = e,
            this.type = "BoxHelper",
            this.matrixAutoUpdate = !1,
            this.update()
        }
        update(e) {
            if (void 0 !== e && console.warn("THREE.BoxHelper: .update() has no longer arguments."),
            void 0 !== this.object && Ku.setFromObject(this.object),
            Ku.isEmpty())
                return;
            const t = Ku.min
              , n = Ku.max
              , i = this.geometry.attributes.position
              , r = i.array;
            r[0] = n.x,
            r[1] = n.y,
            r[2] = n.z,
            r[3] = t.x,
            r[4] = n.y,
            r[5] = n.z,
            r[6] = t.x,
            r[7] = t.y,
            r[8] = n.z,
            r[9] = n.x,
            r[10] = t.y,
            r[11] = n.z,
            r[12] = n.x,
            r[13] = n.y,
            r[14] = t.z,
            r[15] = t.x,
            r[16] = n.y,
            r[17] = t.z,
            r[18] = t.x,
            r[19] = t.y,
            r[20] = t.z,
            r[21] = n.x,
            r[22] = t.y,
            r[23] = t.z,
            i.needsUpdate = !0,
            this.geometry.computeBoundingSphere()
        }
        setFromObject(e) {
            return this.object = e,
            this.update(),
            this
        }
        copy(e, t) {
            return super.copy(e, t),
            this.object = e.object,
            this
        }
    }
    ,
    BufferAttribute: Ii,
    BufferGeometry: Vi,
    BufferGeometryLoader: qh,
    ByteType: 1010,
    Cache: gh,
    Camera: mr,
    CameraHelper: class extends rl {
        constructor(e) {
            const t = new Vi
              , n = new Zo({
                color: 16777215,
                vertexColors: !0,
                toneMapped: !1
            })
              , i = []
              , r = []
              , s = {};
            function a(e, t) {
                o(e),
                o(t)
            }
            function o(e) {
                i.push(0, 0, 0),
                r.push(0, 0, 0),
                void 0 === s[e] && (s[e] = []),
                s[e].push(i.length / 3 - 1)
            }
            a("n1", "n2"),
            a("n2", "n4"),
            a("n4", "n3"),
            a("n3", "n1"),
            a("f1", "f2"),
            a("f2", "f4"),
            a("f4", "f3"),
            a("f3", "f1"),
            a("n1", "f1"),
            a("n2", "f2"),
            a("n3", "f3"),
            a("n4", "f4"),
            a("p", "n1"),
            a("p", "n2"),
            a("p", "n3"),
            a("p", "n4"),
            a("u1", "u2"),
            a("u2", "u3"),
            a("u3", "u1"),
            a("c", "t"),
            a("p", "c"),
            a("cn1", "cn2"),
            a("cn3", "cn4"),
            a("cf1", "cf2"),
            a("cf3", "cf4"),
            t.setAttribute("position", new Ni(i,3)),
            t.setAttribute("color", new Ni(r,3)),
            super(t, n),
            this.type = "CameraHelper",
            this.camera = e,
            this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
            this.matrix = e.matrixWorld,
            this.matrixAutoUpdate = !1,
            this.pointMap = s,
            this.update();
            const l = new en(16755200)
              , c = new en(16711680)
              , h = new en(43775)
              , u = new en(16777215)
              , d = new en(3355443);
            this.setColors(l, c, h, u, d)
        }
        setColors(e, t, n, i, r) {
            const s = this.geometry.getAttribute("color");
            s.setXYZ(0, e.r, e.g, e.b),
            s.setXYZ(1, e.r, e.g, e.b),
            s.setXYZ(2, e.r, e.g, e.b),
            s.setXYZ(3, e.r, e.g, e.b),
            s.setXYZ(4, e.r, e.g, e.b),
            s.setXYZ(5, e.r, e.g, e.b),
            s.setXYZ(6, e.r, e.g, e.b),
            s.setXYZ(7, e.r, e.g, e.b),
            s.setXYZ(8, e.r, e.g, e.b),
            s.setXYZ(9, e.r, e.g, e.b),
            s.setXYZ(10, e.r, e.g, e.b),
            s.setXYZ(11, e.r, e.g, e.b),
            s.setXYZ(12, e.r, e.g, e.b),
            s.setXYZ(13, e.r, e.g, e.b),
            s.setXYZ(14, e.r, e.g, e.b),
            s.setXYZ(15, e.r, e.g, e.b),
            s.setXYZ(16, e.r, e.g, e.b),
            s.setXYZ(17, e.r, e.g, e.b),
            s.setXYZ(18, e.r, e.g, e.b),
            s.setXYZ(19, e.r, e.g, e.b),
            s.setXYZ(20, e.r, e.g, e.b),
            s.setXYZ(21, e.r, e.g, e.b),
            s.setXYZ(22, e.r, e.g, e.b),
            s.setXYZ(23, e.r, e.g, e.b),
            s.setXYZ(24, t.r, t.g, t.b),
            s.setXYZ(25, t.r, t.g, t.b),
            s.setXYZ(26, t.r, t.g, t.b),
            s.setXYZ(27, t.r, t.g, t.b),
            s.setXYZ(28, t.r, t.g, t.b),
            s.setXYZ(29, t.r, t.g, t.b),
            s.setXYZ(30, t.r, t.g, t.b),
            s.setXYZ(31, t.r, t.g, t.b),
            s.setXYZ(32, n.r, n.g, n.b),
            s.setXYZ(33, n.r, n.g, n.b),
            s.setXYZ(34, n.r, n.g, n.b),
            s.setXYZ(35, n.r, n.g, n.b),
            s.setXYZ(36, n.r, n.g, n.b),
            s.setXYZ(37, n.r, n.g, n.b),
            s.setXYZ(38, i.r, i.g, i.b),
            s.setXYZ(39, i.r, i.g, i.b),
            s.setXYZ(40, r.r, r.g, r.b),
            s.setXYZ(41, r.r, r.g, r.b),
            s.setXYZ(42, r.r, r.g, r.b),
            s.setXYZ(43, r.r, r.g, r.b),
            s.setXYZ(44, r.r, r.g, r.b),
            s.setXYZ(45, r.r, r.g, r.b),
            s.setXYZ(46, r.r, r.g, r.b),
            s.setXYZ(47, r.r, r.g, r.b),
            s.setXYZ(48, r.r, r.g, r.b),
            s.setXYZ(49, r.r, r.g, r.b),
            s.needsUpdate = !0
        }
        update() {
            const e = this.geometry
              , t = this.pointMap;
            Zu.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
            Ju("c", t, e, Zu, 0, 0, -1),
            Ju("t", t, e, Zu, 0, 0, 1),
            Ju("n1", t, e, Zu, -1, -1, -1),
            Ju("n2", t, e, Zu, 1, -1, -1),
            Ju("n3", t, e, Zu, -1, 1, -1),
            Ju("n4", t, e, Zu, 1, 1, -1),
            Ju("f1", t, e, Zu, -1, -1, 1),
            Ju("f2", t, e, Zu, 1, -1, 1),
            Ju("f3", t, e, Zu, -1, 1, 1),
            Ju("f4", t, e, Zu, 1, 1, 1),
            Ju("u1", t, e, Zu, .7, 1.1, -1),
            Ju("u2", t, e, Zu, -.7, 1.1, -1),
            Ju("u3", t, e, Zu, 0, 2, -1),
            Ju("cf1", t, e, Zu, -1, 0, 1),
            Ju("cf2", t, e, Zu, 1, 0, 1),
            Ju("cf3", t, e, Zu, 0, -1, 1),
            Ju("cf4", t, e, Zu, 0, 1, 1),
            Ju("cn1", t, e, Zu, -1, 0, -1),
            Ju("cn2", t, e, Zu, 1, 0, -1),
            Ju("cn3", t, e, Zu, 0, -1, -1),
            Ju("cn4", t, e, Zu, 0, 1, -1),
            e.getAttribute("position").needsUpdate = !0
        }
        dispose() {
            this.geometry.dispose(),
            this.material.dispose()
        }
    }
    ,
    CanvasTexture: fl,
    CapsuleBufferGeometry: class extends Bl {
        constructor(e, t, n, i) {
            console.warn("THREE.CapsuleBufferGeometry has been renamed to THREE.CapsuleGeometry."),
            super(e, t, n, i)
        }
    }
    ,
    CapsuleGeometry: Bl,
    CatmullRomCurve3: Sl,
    CineonToneMapping: 3,
    CircleBufferGeometry: class extends kl {
        constructor(e, t, n, i) {
            console.warn("THREE.CircleBufferGeometry has been renamed to THREE.CircleGeometry."),
            super(e, t, n, i)
        }
    }
    ,
    CircleGeometry: kl,
    ClampToEdgeWrapping: xe,
    Clock: ru,
    Color: en,
    ColorKeyframeTrack: lh,
    ColorManagement: qt,
    CompressedTexture: ml,
    CompressedTextureLoader: class extends yh {
        constructor(e) {
            super(e)
        }
        load(e, t, n, i) {
            const r = this
              , s = []
              , a = new ml
              , o = new Mh(this.manager);
            o.setPath(this.path),
            o.setResponseType("arraybuffer"),
            o.setRequestHeader(this.requestHeader),
            o.setWithCredentials(r.withCredentials);
            let l = 0;
            function c(c) {
                o.load(e[c], (function(e) {
                    const n = r.parse(e, !0);
                    s[c] = {
                        width: n.width,
                        height: n.height,
                        format: n.format,
                        mipmaps: n.mipmaps
                    },
                    l += 1,
                    6 === l && (1 === n.mipmapCount && (a.minFilter = we),
                    a.image = s,
                    a.format = n.format,
                    a.needsUpdate = !0,
                    t && t(a))
                }
                ), n, i)
            }
            if (Array.isArray(e))
                for (let t = 0, n = e.length; t < n; ++t)
                    c(t);
            else
                o.load(e, (function(e) {
                    const n = r.parse(e, !0);
                    if (n.isCubemap) {
                        const e = n.mipmaps.length / n.mipmapCount;
                        for (let t = 0; t < e; t++) {
                            s[t] = {
                                mipmaps: []
                            };
                            for (let e = 0; e < n.mipmapCount; e++)
                                s[t].mipmaps.push(n.mipmaps[t * n.mipmapCount + e]),
                                s[t].format = n.format,
                                s[t].width = n.width,
                                s[t].height = n.height
                        }
                        a.image = s
                    } else
                        a.image.width = n.width,
                        a.image.height = n.height,
                        a.mipmaps = n.mipmaps;
                    1 === n.mipmapCount && (a.minFilter = we),
                    a.format = n.format,
                    a.needsUpdate = !0,
                    t && t(a)
                }
                ), n, i);
            return a
        }
    }
    ,
    ConeBufferGeometry: class extends Hl {
        constructor(e, t, n, i, r, s, a) {
            console.warn("THREE.ConeBufferGeometry has been renamed to THREE.ConeGeometry."),
            super(e, t, n, i, r, s, a)
        }
    }
    ,
    ConeGeometry: Hl,
    CubeCamera: vr,
    CubeReflectionMapping: de,
    CubeRefractionMapping: pe,
    CubeTexture: xr,
    CubeTextureLoader: class extends yh {
        constructor(e) {
            super(e)
        }
        load(e, t, n, i) {
            const r = new xr
              , s = new wh(this.manager);
            s.setCrossOrigin(this.crossOrigin),
            s.setPath(this.path);
            let a = 0;
            function o(n) {
                s.load(e[n], (function(e) {
                    r.images[n] = e,
                    a++,
                    6 === a && (r.needsUpdate = !0,
                    t && t(r))
                }
                ), void 0, i)
            }
            for (let t = 0; t < e.length; ++t)
                o(t);
            return r
        }
    }
    ,
    CubeUVReflectionMapping: ge,
    CubicBezierCurve: Cl,
    CubicBezierCurve3: Ll,
    CubicInterpolant: ih,
    CullFaceBack: 1,
    CullFaceFront: 2,
    CullFaceFrontBack: 3,
    CullFaceNone: 0,
    Curve: gl,
    CurvePath: zl,
    CustomBlending: 5,
    CustomToneMapping: 5,
    CylinderBufferGeometry: class extends Gl {
        constructor(e, t, n, i, r, s, a, o) {
            console.warn("THREE.CylinderBufferGeometry has been renamed to THREE.CylinderGeometry."),
            super(e, t, n, i, r, s, a, o)
        }
    }
    ,
    CylinderGeometry: Gl,
    Cylindrical: class {
        constructor(e=1, t=0, n=0) {
            return this.radius = e,
            this.theta = t,
            this.y = n,
            this
        }
        set(e, t, n) {
            return this.radius = e,
            this.theta = t,
            this.y = n,
            this
        }
        copy(e) {
            return this.radius = e.radius,
            this.theta = e.theta,
            this.y = e.y,
            this
        }
        setFromVector3(e) {
            return this.setFromCartesianCoords(e.x, e.y, e.z)
        }
        setFromCartesianCoords(e, t, n) {
            return this.radius = Math.sqrt(e * e + n * n),
            this.theta = Math.atan2(e, n),
            this.y = t,
            this
        }
        clone() {
            return (new this.constructor).copy(this)
        }
    }
    ,
    Data3DTexture: un,
    DataArrayTexture: hn,
    DataTexture: Bo,
    DataTexture2DArray: class extends hn {
        constructor(e, t, n, i) {
            console.warn("THREE.DataTexture2DArray has been renamed to DataArrayTexture."),
            super(e, t, n, i)
        }
    }
    ,
    DataTexture3D: class extends un {
        constructor(e, t, n, i) {
            console.warn("THREE.DataTexture3D has been renamed to Data3DTexture."),
            super(e, t, n, i)
        }
    }
    ,
    DataTextureLoader: class extends yh {
        constructor(e) {
            super(e)
        }
        load(e, t, n, i) {
            const r = this
              , s = new Bo
              , a = new Mh(this.manager);
            return a.setResponseType("arraybuffer"),
            a.setRequestHeader(this.requestHeader),
            a.setPath(this.path),
            a.setWithCredentials(r.withCredentials),
            a.load(e, (function(e) {
                const n = r.parse(e);
                n && (void 0 !== n.image ? s.image = n.image : void 0 !== n.data && (s.image.width = n.width,
                s.image.height = n.height,
                s.image.data = n.data),
                s.wrapS = void 0 !== n.wrapS ? n.wrapS : xe,
                s.wrapT = void 0 !== n.wrapT ? n.wrapT : xe,
                s.magFilter = void 0 !== n.magFilter ? n.magFilter : we,
                s.minFilter = void 0 !== n.minFilter ? n.minFilter : we,
                s.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1,
                void 0 !== n.encoding && (s.encoding = n.encoding),
                void 0 !== n.flipY && (s.flipY = n.flipY),
                void 0 !== n.format && (s.format = n.format),
                void 0 !== n.type && (s.type = n.type),
                void 0 !== n.mipmaps && (s.mipmaps = n.mipmaps,
                s.minFilter = Te),
                1 === n.mipmapCount && (s.minFilter = we),
                void 0 !== n.generateMipmaps && (s.generateMipmaps = n.generateMipmaps),
                s.needsUpdate = !0,
                t && t(s, n))
            }
            ), n, i),
            s
        }
    }
    ,
    DataUtils: rd,
    DecrementStencilOp: 7683,
    DecrementWrapStencilOp: 34056,
    DefaultLoadingManager: xh,
    DepthFormat: De,
    DepthStencilFormat: Oe,
    DepthTexture: eo,
    DirectionalLight: Bh,
    DirectionalLightHelper: class extends fi {
        constructor(e, t, n) {
            super(),
            this.light = e,
            this.light.updateMatrixWorld(),
            this.matrix = e.matrixWorld,
            this.matrixAutoUpdate = !1,
            this.color = n,
            void 0 === t && (t = 1);
            let i = new Vi;
            i.setAttribute("position", new Ni([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0],3));
            const r = new Zo({
                fog: !1,
                toneMapped: !1
            });
            this.lightPlane = new tl(i,r),
            this.add(this.lightPlane),
            i = new Vi,
            i.setAttribute("position", new Ni([0, 0, 0, 0, 0, 1],3)),
            this.targetLine = new tl(i,r),
            this.add(this.targetLine),
            this.update()
        }
        dispose() {
            this.lightPlane.geometry.dispose(),
            this.lightPlane.material.dispose(),
            this.targetLine.geometry.dispose(),
            this.targetLine.material.dispose()
        }
        update() {
            ju.setFromMatrixPosition(this.light.matrixWorld),
            Xu.setFromMatrixPosition(this.light.target.matrixWorld),
            qu.subVectors(Xu, ju),
            this.lightPlane.lookAt(Xu),
            void 0 !== this.color ? (this.lightPlane.material.color.set(this.color),
            this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color),
            this.targetLine.material.color.copy(this.light.color)),
            this.targetLine.lookAt(Xu),
            this.targetLine.scale.z = qu.length()
        }
    }
    ,
    DiscreteInterpolant: sh,
    DodecahedronBufferGeometry: class extends Wl {
        constructor(e, t) {
            console.warn("THREE.DodecahedronBufferGeometry has been renamed to THREE.DodecahedronGeometry."),
            super(e, t)
        }
    }
    ,
    DodecahedronGeometry: Wl,
    DoubleSide: ae,
    DstAlphaFactor: 206,
    DstColorFactor: 208,
    DynamicCopyUsage: 35050,
    DynamicDrawUsage: 35048,
    DynamicReadUsage: 35049,
    EdgesGeometry: Zl,
    EllipseCurve: vl,
    EqualDepth: 4,
    EqualStencilFunc: 514,
    EquirectangularReflectionMapping: me,
    EquirectangularRefractionMapping: fe,
    Euler: ei,
    EventDispatcher: wt,
    ExtrudeBufferGeometry: class extends Tc {
        constructor(e, t) {
            console.warn("THREE.ExtrudeBufferGeometry has been renamed to THREE.ExtrudeGeometry."),
            super(e, t)
        }
    }
    ,
    ExtrudeGeometry: Tc,
    FileLoader: Mh,
    Float16BufferAttribute: class extends Ii {
        constructor(e, t, n) {
            super(new Uint16Array(e), t, n),
            this.isFloat16BufferAttribute = !0
        }
    }
    ,
    Float32BufferAttribute: Ni,
    Float64BufferAttribute: class extends Ii {
        constructor(e, t, n) {
            super(new Float64Array(e), t, n)
        }
    }
    ,
    FloatType: Le,
    Fog: oo,
    FogExp2: ao,
    FramebufferTexture: class extends on {
        constructor(e, t, n) {
            super({
                width: e,
                height: t
            }),
            this.isFramebufferTexture = !0,
            this.format = n,
            this.magFilter = _e,
            this.minFilter = _e,
            this.generateMipmaps = !1,
            this.needsUpdate = !0
        }
    }
    ,
    FrontSide: 0,
    Frustum: Ar,
    GLBufferAttribute: class {
        constructor(e, t, n, i, r) {
            this.isGLBufferAttribute = !0,
            this.buffer = e,
            this.type = t,
            this.itemSize = n,
            this.elementSize = i,
            this.count = r,
            this.version = 0
        }
        set needsUpdate(e) {
            !0 === e && this.version++
        }
        setBuffer(e) {
            return this.buffer = e,
            this
        }
        setType(e, t) {
            return this.type = e,
            this.elementSize = t,
            this
        }
        setItemSize(e) {
            return this.itemSize = e,
            this
        }
        setCount(e) {
            return this.count = e,
            this
        }
    }
    ,
    GLSL1: "100",
    GLSL3: bt,
    GreaterDepth: 6,
    GreaterEqualDepth: 5,
    GreaterEqualStencilFunc: 518,
    GreaterStencilFunc: 516,
    GridHelper: class extends rl {
        constructor(e=10, t=10, n=4473924, i=8947848) {
            n = new en(n),
            i = new en(i);
            const r = t / 2
              , s = e / t
              , a = e / 2
              , o = []
              , l = [];
            for (let e = 0, c = 0, h = -a; e <= t; e++,
            h += s) {
                o.push(-a, 0, h, a, 0, h),
                o.push(h, 0, -a, h, 0, a);
                const t = e === r ? n : i;
                t.toArray(l, c),
                c += 3,
                t.toArray(l, c),
                c += 3,
                t.toArray(l, c),
                c += 3,
                t.toArray(l, c),
                c += 3
            }
            const c = new Vi;
            c.setAttribute("position", new Ni(o,3)),
            c.setAttribute("color", new Ni(l,3));
            super(c, new Zo({
                vertexColors: !0,
                toneMapped: !1
            })),
            this.type = "GridHelper"
        }
    }
    ,
    Group: Ka,
    HalfFloatType: Re,
    HemisphereLight: Ah,
    HemisphereLightHelper: class extends fi {
        constructor(e, t, n) {
            super(),
            this.light = e,
            this.light.updateMatrixWorld(),
            this.matrix = e.matrixWorld,
            this.matrixAutoUpdate = !1,
            this.color = n;
            const i = new Cc(t);
            i.rotateY(.5 * Math.PI),
            this.material = new Li({
                wireframe: !0,
                fog: !1,
                toneMapped: !1
            }),
            void 0 === this.color && (this.material.vertexColors = !0);
            const r = i.getAttribute("position")
              , s = new Float32Array(3 * r.count);
            i.setAttribute("color", new Ii(s,3)),
            this.add(new or(i,this.material)),
            this.update()
        }
        dispose() {
            this.children[0].geometry.dispose(),
            this.children[0].material.dispose()
        }
        update() {
            const e = this.children[0];
            if (void 0 !== this.color)
                this.material.color.set(this.color);
            else {
                const t = e.geometry.getAttribute("color");
                Vu.copy(this.light.color),
                Wu.copy(this.light.groundColor);
                for (let e = 0, n = t.count; e < n; e++) {
                    const i = e < n / 2 ? Vu : Wu;
                    t.setXYZ(e, i.r, i.g, i.b)
                }
                t.needsUpdate = !0
            }
            e.lookAt(Hu.setFromMatrixPosition(this.light.matrixWorld).negate())
        }
    }
    ,
    HemisphereLightProbe: class extends Vh {
        constructor(e, t, n=1) {
            super(void 0, n),
            this.isHemisphereLightProbe = !0;
            const i = (new en).set(e)
              , r = (new en).set(t)
              , s = new pn(i.r,i.g,i.b)
              , a = new pn(r.r,r.g,r.b)
              , o = Math.sqrt(Math.PI)
              , l = o * Math.sqrt(.75);
            this.sh.coefficients[0].copy(s).add(a).multiplyScalar(o),
            this.sh.coefficients[1].copy(s).sub(a).multiplyScalar(l)
        }
    }
    ,
    IcosahedronBufferGeometry: class extends Ec {
        constructor(e, t) {
            console.warn("THREE.IcosahedronBufferGeometry has been renamed to THREE.IcosahedronGeometry."),
            super(e, t)
        }
    }
    ,
    IcosahedronGeometry: Ec,
    ImageBitmapLoader: Kh,
    ImageLoader: wh,
    ImageUtils: nn,
    ImmediateRenderObject: function() {
        console.error("THREE.ImmediateRenderObject has been removed.")
    },
    IncrementStencilOp: 7682,
    IncrementWrapStencilOp: 34055,
    InstancedBufferAttribute: Vo,
    InstancedBufferGeometry: Xh,
    InstancedInterleavedBuffer: class extends co {
        constructor(e, t, n=1) {
            super(e, t),
            this.isInstancedInterleavedBuffer = !0,
            this.meshPerAttribute = n
        }
        copy(e) {
            return super.copy(e),
            this.meshPerAttribute = e.meshPerAttribute,
            this
        }
        clone(e) {
            const t = super.clone(e);
            return t.meshPerAttribute = this.meshPerAttribute,
            t
        }
        toJSON(e) {
            const t = super.toJSON(e);
            return t.isInstancedInterleavedBuffer = !0,
            t.meshPerAttribute = this.meshPerAttribute,
            t
        }
    }
    ,
    InstancedMesh: Yo,
    Int16BufferAttribute: class extends Ii {
        constructor(e, t, n) {
            super(new Int16Array(e), t, n)
        }
    }
    ,
    Int32BufferAttribute: class extends Ii {
        constructor(e, t, n) {
            super(new Int32Array(e), t, n)
        }
    }
    ,
    Int8BufferAttribute: class extends Ii {
        constructor(e, t, n) {
            super(new Int8Array(e), t, n)
        }
    }
    ,
    IntType: 1013,
    InterleavedBuffer: co,
    InterleavedBufferAttribute: uo,
    Interpolant: nh,
    InterpolateDiscrete: ot,
    InterpolateLinear: lt,
    InterpolateSmooth: ct,
    InvertStencilOp: 5386,
    KeepStencilOp: yt,
    KeyframeTrack: ah,
    LOD: Po,
    LatheBufferGeometry: class extends Fl {
        constructor(e, t, n, i) {
            console.warn("THREE.LatheBufferGeometry has been renamed to THREE.LatheGeometry."),
            super(e, t, n, i)
        }
    }
    ,
    LatheGeometry: Fl,
    Layers: ti,
    LessDepth: 2,
    LessEqualDepth: 3,
    LessEqualStencilFunc: 515,
    LessStencilFunc: 513,
    Light: Th,
    LightProbe: Vh,
    Line: tl,
    Line3: class {
        constructor(e=new pn, t=new pn) {
            this.start = e,
            this.end = t
        }
        set(e, t) {
            return this.start.copy(e),
            this.end.copy(t),
            this
        }
        copy(e) {
            return this.start.copy(e.start),
            this.end.copy(e.end),
            this
        }
        getCenter(e) {
            return e.addVectors(this.start, this.end).multiplyScalar(.5)
        }
        delta(e) {
            return e.subVectors(this.end, this.start)
        }
        distanceSq() {
            return this.start.distanceToSquared(this.end)
        }
        distance() {
            return this.start.distanceTo(this.end)
        }
        at(e, t) {
            return this.delta(t).multiplyScalar(e).add(this.start)
        }
        closestPointToPointParameter(e, t) {
            Ou.subVectors(e, this.start),
            Nu.subVectors(this.end, this.start);
            const n = Nu.dot(Nu);
            let i = Nu.dot(Ou) / n;
            return t && (i = Lt(i, 0, 1)),
            i
        }
        closestPointToPoint(e, t, n) {
            const i = this.closestPointToPointParameter(e, t);
            return this.delta(n).multiplyScalar(i).add(this.start)
        }
        applyMatrix4(e) {
            return this.start.applyMatrix4(e),
            this.end.applyMatrix4(e),
            this
        }
        equals(e) {
            return e.start.equals(this.start) && e.end.equals(this.end)
        }
        clone() {
            return (new this.constructor).copy(this)
        }
    }
    ,
    LineBasicMaterial: Zo,
    LineCurve: Rl,
    LineCurve3: Pl,
    LineDashedMaterial: Yc,
    LineLoop: sl,
    LineSegments: rl,
    LinearEncoding: ft,
    LinearFilter: we,
    LinearInterpolant: rh,
    LinearMipMapLinearFilter: 1008,
    LinearMipMapNearestFilter: 1007,
    LinearMipmapLinearFilter: Te,
    LinearMipmapNearestFilter: Se,
    LinearSRGBColorSpace: xt,
    LinearToneMapping: 1,
    Loader: yh,
    LoaderUtils: jh,
    LoadingManager: vh,
    LoopOnce: at,
    LoopPingPong: 2202,
    LoopRepeat: 2201,
    LuminanceAlphaFormat: 1025,
    LuminanceFormat: 1024,
    MOUSE: te,
    Material: Ci,
    MaterialLoader: Wh,
    MathUtils: Ut,
    Matrix3: Bt,
    Matrix4: Wn,
    MaxEquation: 104,
    Mesh: or,
    MeshBasicMaterial: Li,
    MeshDepthMaterial: Wa,
    MeshDistanceMaterial: ja,
    MeshLambertMaterial: Xc,
    MeshMatcapMaterial: qc,
    MeshNormalMaterial: jc,
    MeshPhongMaterial: Vc,
    MeshPhysicalMaterial: Hc,
    MeshStandardMaterial: Gc,
    MeshToonMaterial: Wc,
    MinEquation: 103,
    MirroredRepeatWrapping: ye,
    MixOperation: 1,
    MultiplyBlending: 4,
    MultiplyOperation: 0,
    NearestFilter: _e,
    NearestMipMapLinearFilter: 1005,
    NearestMipMapNearestFilter: 1004,
    NearestMipmapLinearFilter: Me,
    NearestMipmapNearestFilter: be,
    NeverDepth: 0,
    NeverStencilFunc: 512,
    NoBlending: 0,
    NoColorSpace: "",
    NoToneMapping: 0,
    NormalAnimationBlendMode: pt,
    NormalBlending: 1,
    NotEqualDepth: 7,
    NotEqualStencilFunc: 517,
    NumberKeyframeTrack: ch,
    Object3D: fi,
    ObjectLoader: class extends yh {
        constructor(e) {
            super(e)
        }
        load(e, t, n, i) {
            const r = this
              , s = "" === this.path ? jh.extractUrlBase(e) : this.path;
            this.resourcePath = this.resourcePath || s;
            const a = new Mh(this.manager);
            a.setPath(this.path),
            a.setRequestHeader(this.requestHeader),
            a.setWithCredentials(this.withCredentials),
            a.load(e, (function(n) {
                let s = null;
                try {
                    s = JSON.parse(n)
                } catch (t) {
                    return void 0 !== i && i(t),
                    void console.error("THREE:ObjectLoader: Can't parse " + e + ".", t.message)
                }
                const a = s.metadata;
                void 0 !== a && void 0 !== a.type && "geometry" !== a.type.toLowerCase() ? r.parse(s, t) : console.error("THREE.ObjectLoader: Can't load " + e)
            }
            ), n, i)
        }
        async loadAsync(e, t) {
            const n = "" === this.path ? jh.extractUrlBase(e) : this.path;
            this.resourcePath = this.resourcePath || n;
            const i = new Mh(this.manager);
            i.setPath(this.path),
            i.setRequestHeader(this.requestHeader),
            i.setWithCredentials(this.withCredentials);
            const r = await i.loadAsync(e, t)
              , s = JSON.parse(r)
              , a = s.metadata;
            if (void 0 === a || void 0 === a.type || "geometry" === a.type.toLowerCase())
                throw new Error("THREE.ObjectLoader: Can't load " + e);
            return await this.parseAsync(s)
        }
        parse(e, t) {
            const n = this.parseAnimations(e.animations)
              , i = this.parseShapes(e.shapes)
              , r = this.parseGeometries(e.geometries, i)
              , s = this.parseImages(e.images, (function() {
                void 0 !== t && t(l)
            }
            ))
              , a = this.parseTextures(e.textures, s)
              , o = this.parseMaterials(e.materials, a)
              , l = this.parseObject(e.object, r, o, a, n)
              , c = this.parseSkeletons(e.skeletons, l);
            if (this.bindSkeletons(l, c),
            void 0 !== t) {
                let e = !1;
                for (const t in s)
                    if (s[t].data instanceof HTMLImageElement) {
                        e = !0;
                        break
                    }
                !1 === e && t(l)
            }
            return l
        }
        async parseAsync(e) {
            const t = this.parseAnimations(e.animations)
              , n = this.parseShapes(e.shapes)
              , i = this.parseGeometries(e.geometries, n)
              , r = await this.parseImagesAsync(e.images)
              , s = this.parseTextures(e.textures, r)
              , a = this.parseMaterials(e.materials, s)
              , o = this.parseObject(e.object, i, a, s, t)
              , l = this.parseSkeletons(e.skeletons, o);
            return this.bindSkeletons(o, l),
            o
        }
        parseShapes(e) {
            const t = {};
            if (void 0 !== e)
                for (let n = 0, i = e.length; n < i; n++) {
                    const i = (new Jl).fromJSON(e[n]);
                    t[i.uuid] = i
                }
            return t
        }
        parseSkeletons(e, t) {
            const n = {}
              , i = {};
            if (t.traverse((function(e) {
                e.isBone && (i[e.uuid] = e)
            }
            )),
            void 0 !== e)
                for (let t = 0, r = e.length; t < r; t++) {
                    const r = (new Ho).fromJSON(e[t], i);
                    n[r.uuid] = r
                }
            return n
        }
        parseGeometries(e, t) {
            const n = {};
            if (void 0 !== e) {
                const i = new qh;
                for (let r = 0, s = e.length; r < s; r++) {
                    let s;
                    const a = e[r];
                    switch (a.type) {
                    case "BufferGeometry":
                    case "InstancedBufferGeometry":
                        s = i.parse(a);
                        break;
                    default:
                        a.type in Fc ? s = Fc[a.type].fromJSON(a, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${a.type}"`)
                    }
                    s.uuid = a.uuid,
                    void 0 !== a.name && (s.name = a.name),
                    !0 === s.isBufferGeometry && void 0 !== a.userData && (s.userData = a.userData),
                    n[a.uuid] = s
                }
            }
            return n
        }
        parseMaterials(e, t) {
            const n = {}
              , i = {};
            if (void 0 !== e) {
                const r = new Wh;
                r.setTextures(t);
                for (let t = 0, s = e.length; t < s; t++) {
                    const s = e[t];
                    void 0 === n[s.uuid] && (n[s.uuid] = r.parse(s)),
                    i[s.uuid] = n[s.uuid]
                }
            }
            return i
        }
        parseAnimations(e) {
            const t = {};
            if (void 0 !== e)
                for (let n = 0; n < e.length; n++) {
                    const i = e[n]
                      , r = mh.parse(i);
                    t[r.uuid] = r
                }
            return t
        }
        parseImages(e, t) {
            const n = this
              , i = {};
            let r;
            function s(e) {
                if ("string" == typeof e) {
                    const t = e;
                    return function(e) {
                        return n.manager.itemStart(e),
                        r.load(e, (function() {
                            n.manager.itemEnd(e)
                        }
                        ), void 0, (function() {
                            n.manager.itemError(e),
                            n.manager.itemEnd(e)
                        }
                        ))
                    }(/^(\/\/)|([a-z]+:(\/\/)?)/i.test(t) ? t : n.resourcePath + t)
                }
                return e.data ? {
                    data: Ht(e.type, e.data),
                    width: e.width,
                    height: e.height
                } : null
            }
            if (void 0 !== e && e.length > 0) {
                const n = new vh(t);
                r = new wh(n),
                r.setCrossOrigin(this.crossOrigin);
                for (let t = 0, n = e.length; t < n; t++) {
                    const n = e[t]
                      , r = n.url;
                    if (Array.isArray(r)) {
                        const e = [];
                        for (let t = 0, n = r.length; t < n; t++) {
                            const n = s(r[t]);
                            null !== n && (n instanceof HTMLImageElement ? e.push(n) : e.push(new Bo(n.data,n.width,n.height)))
                        }
                        i[n.uuid] = new rn(e)
                    } else {
                        const e = s(n.url);
                        i[n.uuid] = new rn(e)
                    }
                }
            }
            return i
        }
        async parseImagesAsync(e) {
            const t = this
              , n = {};
            let i;
            async function r(e) {
                if ("string" == typeof e) {
                    const n = e
                      , r = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(n) ? n : t.resourcePath + n;
                    return await i.loadAsync(r)
                }
                return e.data ? {
                    data: Ht(e.type, e.data),
                    width: e.width,
                    height: e.height
                } : null
            }
            if (void 0 !== e && e.length > 0) {
                i = new wh(this.manager),
                i.setCrossOrigin(this.crossOrigin);
                for (let t = 0, i = e.length; t < i; t++) {
                    const i = e[t]
                      , s = i.url;
                    if (Array.isArray(s)) {
                        const e = [];
                        for (let t = 0, n = s.length; t < n; t++) {
                            const n = s[t]
                              , i = await r(n);
                            null !== i && (i instanceof HTMLImageElement ? e.push(i) : e.push(new Bo(i.data,i.width,i.height)))
                        }
                        n[i.uuid] = new rn(e)
                    } else {
                        const e = await r(i.url);
                        n[i.uuid] = new rn(e)
                    }
                }
            }
            return n
        }
        parseTextures(e, t) {
            function n(e, t) {
                return "number" == typeof e ? e : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e),
                t[e])
            }
            const i = {};
            if (void 0 !== e)
                for (let r = 0, s = e.length; r < s; r++) {
                    const s = e[r];
                    void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid),
                    void 0 === t[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image);
                    const a = t[s.image]
                      , o = a.data;
                    let l;
                    Array.isArray(o) ? (l = new xr,
                    6 === o.length && (l.needsUpdate = !0)) : (l = o && o.data ? new Bo : new on,
                    o && (l.needsUpdate = !0)),
                    l.source = a,
                    l.uuid = s.uuid,
                    void 0 !== s.name && (l.name = s.name),
                    void 0 !== s.mapping && (l.mapping = n(s.mapping, Yh)),
                    void 0 !== s.offset && l.offset.fromArray(s.offset),
                    void 0 !== s.repeat && l.repeat.fromArray(s.repeat),
                    void 0 !== s.center && l.center.fromArray(s.center),
                    void 0 !== s.rotation && (l.rotation = s.rotation),
                    void 0 !== s.wrap && (l.wrapS = n(s.wrap[0], Zh),
                    l.wrapT = n(s.wrap[1], Zh)),
                    void 0 !== s.format && (l.format = s.format),
                    void 0 !== s.type && (l.type = s.type),
                    void 0 !== s.encoding && (l.encoding = s.encoding),
                    void 0 !== s.minFilter && (l.minFilter = n(s.minFilter, Jh)),
                    void 0 !== s.magFilter && (l.magFilter = n(s.magFilter, Jh)),
                    void 0 !== s.anisotropy && (l.anisotropy = s.anisotropy),
                    void 0 !== s.flipY && (l.flipY = s.flipY),
                    void 0 !== s.premultiplyAlpha && (l.premultiplyAlpha = s.premultiplyAlpha),
                    void 0 !== s.unpackAlignment && (l.unpackAlignment = s.unpackAlignment),
                    void 0 !== s.userData && (l.userData = s.userData),
                    i[s.uuid] = l
                }
            return i
        }
        parseObject(e, t, n, i, r) {
            let s, a, o;
            function l(e) {
                return void 0 === t[e] && console.warn("THREE.ObjectLoader: Undefined geometry", e),
                t[e]
            }
            function c(e) {
                if (void 0 !== e) {
                    if (Array.isArray(e)) {
                        const t = [];
                        for (let i = 0, r = e.length; i < r; i++) {
                            const r = e[i];
                            void 0 === n[r] && console.warn("THREE.ObjectLoader: Undefined material", r),
                            t.push(n[r])
                        }
                        return t
                    }
                    return void 0 === n[e] && console.warn("THREE.ObjectLoader: Undefined material", e),
                    n[e]
                }
            }
            function h(e) {
                return void 0 === i[e] && console.warn("THREE.ObjectLoader: Undefined texture", e),
                i[e]
            }
            switch (e.type) {
            case "Scene":
                s = new lo,
                void 0 !== e.background && (Number.isInteger(e.background) ? s.background = new en(e.background) : s.background = h(e.background)),
                void 0 !== e.environment && (s.environment = h(e.environment)),
                void 0 !== e.fog && ("Fog" === e.fog.type ? s.fog = new oo(e.fog.color,e.fog.near,e.fog.far) : "FogExp2" === e.fog.type && (s.fog = new ao(e.fog.color,e.fog.density)));
                break;
            case "PerspectiveCamera":
                s = new fr(e.fov,e.aspect,e.near,e.far),
                void 0 !== e.focus && (s.focus = e.focus),
                void 0 !== e.zoom && (s.zoom = e.zoom),
                void 0 !== e.filmGauge && (s.filmGauge = e.filmGauge),
                void 0 !== e.filmOffset && (s.filmOffset = e.filmOffset),
                void 0 !== e.view && (s.view = Object.assign({}, e.view));
                break;
            case "OrthographicCamera":
                s = new Br(e.left,e.right,e.top,e.bottom,e.near,e.far),
                void 0 !== e.zoom && (s.zoom = e.zoom),
                void 0 !== e.view && (s.view = Object.assign({}, e.view));
                break;
            case "AmbientLight":
                s = new kh(e.color,e.intensity);
                break;
            case "DirectionalLight":
                s = new Bh(e.color,e.intensity);
                break;
            case "PointLight":
                s = new Uh(e.color,e.intensity,e.distance,e.decay);
                break;
            case "RectAreaLight":
                s = new Gh(e.color,e.intensity,e.width,e.height);
                break;
            case "SpotLight":
                s = new Ih(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay);
                break;
            case "HemisphereLight":
                s = new Ah(e.color,e.groundColor,e.intensity);
                break;
            case "LightProbe":
                s = (new Vh).fromJSON(e);
                break;
            case "SkinnedMesh":
                a = l(e.geometry),
                o = c(e.material),
                s = new Uo(a,o),
                void 0 !== e.bindMode && (s.bindMode = e.bindMode),
                void 0 !== e.bindMatrix && s.bindMatrix.fromArray(e.bindMatrix),
                void 0 !== e.skeleton && (s.skeleton = e.skeleton);
                break;
            case "Mesh":
                a = l(e.geometry),
                o = c(e.material),
                s = new or(a,o);
                break;
            case "InstancedMesh":
                a = l(e.geometry),
                o = c(e.material);
                const t = e.count
                  , n = e.instanceMatrix
                  , i = e.instanceColor;
                s = new Yo(a,o,t),
                s.instanceMatrix = new Vo(new Float32Array(n.array),16),
                void 0 !== i && (s.instanceColor = new Vo(new Float32Array(i.array),i.itemSize));
                break;
            case "LOD":
                s = new Po;
                break;
            case "Line":
                s = new tl(l(e.geometry),c(e.material));
                break;
            case "LineLoop":
                s = new sl(l(e.geometry),c(e.material));
                break;
            case "LineSegments":
                s = new rl(l(e.geometry),c(e.material));
                break;
            case "PointCloud":
            case "Points":
                s = new ul(l(e.geometry),c(e.material));
                break;
            case "Sprite":
                s = new Eo(c(e.material));
                break;
            case "Group":
                s = new Ka;
                break;
            case "Bone":
                s = new Fo;
                break;
            default:
                s = new fi
            }
            if (s.uuid = e.uuid,
            void 0 !== e.name && (s.name = e.name),
            void 0 !== e.matrix ? (s.matrix.fromArray(e.matrix),
            void 0 !== e.matrixAutoUpdate && (s.matrixAutoUpdate = e.matrixAutoUpdate),
            s.matrixAutoUpdate && s.matrix.decompose(s.position, s.quaternion, s.scale)) : (void 0 !== e.position && s.position.fromArray(e.position),
            void 0 !== e.rotation && s.rotation.fromArray(e.rotation),
            void 0 !== e.quaternion && s.quaternion.fromArray(e.quaternion),
            void 0 !== e.scale && s.scale.fromArray(e.scale)),
            void 0 !== e.castShadow && (s.castShadow = e.castShadow),
            void 0 !== e.receiveShadow && (s.receiveShadow = e.receiveShadow),
            e.shadow && (void 0 !== e.shadow.bias && (s.shadow.bias = e.shadow.bias),
            void 0 !== e.shadow.normalBias && (s.shadow.normalBias = e.shadow.normalBias),
            void 0 !== e.shadow.radius && (s.shadow.radius = e.shadow.radius),
            void 0 !== e.shadow.mapSize && s.shadow.mapSize.fromArray(e.shadow.mapSize),
            void 0 !== e.shadow.camera && (s.shadow.camera = this.parseObject(e.shadow.camera))),
            void 0 !== e.visible && (s.visible = e.visible),
            void 0 !== e.frustumCulled && (s.frustumCulled = e.frustumCulled),
            void 0 !== e.renderOrder && (s.renderOrder = e.renderOrder),
            void 0 !== e.userData && (s.userData = e.userData),
            void 0 !== e.layers && (s.layers.mask = e.layers),
            void 0 !== e.children) {
                const a = e.children;
                for (let e = 0; e < a.length; e++)
                    s.add(this.parseObject(a[e], t, n, i, r))
            }
            if (void 0 !== e.animations) {
                const t = e.animations;
                for (let e = 0; e < t.length; e++) {
                    const n = t[e];
                    s.animations.push(r[n])
                }
            }
            if ("LOD" === e.type) {
                void 0 !== e.autoUpdate && (s.autoUpdate = e.autoUpdate);
                const t = e.levels;
                for (let e = 0; e < t.length; e++) {
                    const n = t[e]
                      , i = s.getObjectByProperty("uuid", n.object);
                    void 0 !== i && s.addLevel(i, n.distance)
                }
            }
            return s
        }
        bindSkeletons(e, t) {
            0 !== Object.keys(t).length && e.traverse((function(e) {
                if (!0 === e.isSkinnedMesh && void 0 !== e.skeleton) {
                    const n = t[e.skeleton];
                    void 0 === n ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", e.skeleton) : e.bind(n, e.bindMatrix)
                }
            }
            ))
        }
    }
    ,
    ObjectSpaceNormalMap: 1,
    OctahedronBufferGeometry: class extends Cc {
        constructor(e, t) {
            console.warn("THREE.OctahedronBufferGeometry has been renamed to THREE.OctahedronGeometry."),
            super(e, t)
        }
    }
    ,
    OctahedronGeometry: Cc,
    OneFactor: 201,
    OneMinusDstAlphaFactor: 207,
    OneMinusDstColorFactor: 209,
    OneMinusSrcAlphaFactor: 205,
    OneMinusSrcColorFactor: 203,
    OrthographicCamera: Br,
    PCFShadowMap: 1,
    PCFSoftShadowMap: 2,
    PMREMGenerator: Yr,
    Path: Ul,
    PerspectiveCamera: fr,
    Plane: wr,
    PlaneBufferGeometry: class extends Lr {
        constructor(e, t, n, i) {
            console.warn("THREE.PlaneBufferGeometry has been renamed to THREE.PlaneGeometry."),
            super(e, t, n, i)
        }
    }
    ,
    PlaneGeometry: Lr,
    PlaneHelper: class extends tl {
        constructor(e, t=1, n=16776960) {
            const i = n
              , r = new Vi;
            r.setAttribute("position", new Ni([1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0],3)),
            r.computeBoundingSphere(),
            super(r, new Zo({
                color: i,
                toneMapped: !1
            })),
            this.type = "PlaneHelper",
            this.plane = e,
            this.size = t;
            const s = new Vi;
            s.setAttribute("position", new Ni([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],3)),
            s.computeBoundingSphere(),
            this.add(new or(s,new Li({
                color: i,
                opacity: .2,
                transparent: !0,
                depthWrite: !1,
                toneMapped: !1
            })))
        }
        updateMatrixWorld(e) {
            this.position.set(0, 0, 0),
            this.scale.set(.5 * this.size, .5 * this.size, 1),
            this.lookAt(this.plane.normal),
            this.translateZ(-this.plane.constant),
            super.updateMatrixWorld(e)
        }
    }
    ,
    PointLight: Uh,
    PointLightHelper: Gu,
    Points: ul,
    PointsMaterial: al,
    PolarGridHelper: class extends rl {
        constructor(e=10, t=16, n=8, i=64, r=4473924, s=8947848) {
            r = new en(r),
            s = new en(s);
            const a = []
              , o = [];
            if (t > 1)
                for (let n = 0; n < t; n++) {
                    const i = n / t * (2 * Math.PI)
                      , l = Math.sin(i) * e
                      , c = Math.cos(i) * e;
                    a.push(0, 0, 0),
                    a.push(l, 0, c);
                    const h = 1 & n ? r : s;
                    o.push(h.r, h.g, h.b),
                    o.push(h.r, h.g, h.b)
                }
            for (let t = 0; t < n; t++) {
                const l = 1 & t ? r : s
                  , c = e - e / n * t;
                for (let e = 0; e < i; e++) {
                    let t = e / i * (2 * Math.PI)
                      , n = Math.sin(t) * c
                      , r = Math.cos(t) * c;
                    a.push(n, 0, r),
                    o.push(l.r, l.g, l.b),
                    t = (e + 1) / i * (2 * Math.PI),
                    n = Math.sin(t) * c,
                    r = Math.cos(t) * c,
                    a.push(n, 0, r),
                    o.push(l.r, l.g, l.b)
                }
            }
            const l = new Vi;
            l.setAttribute("position", new Ni(a,3)),
            l.setAttribute("color", new Ni(o,3));
            super(l, new Zo({
                vertexColors: !0,
                toneMapped: !1
            })),
            this.type = "PolarGridHelper"
        }
    }
    ,
    PolyhedronBufferGeometry: class extends Vl {
        constructor(e, t, n, i) {
            console.warn("THREE.PolyhedronBufferGeometry has been renamed to THREE.PolyhedronGeometry."),
            super(e, t, n, i)
        }
    }
    ,
    PolyhedronGeometry: Vl,
    PositionalAudio: class extends uu {
        constructor(e) {
            super(e),
            this.panner = this.context.createPanner(),
            this.panner.panningModel = "HRTF",
            this.panner.connect(this.gain)
        }
        disconnect() {
            super.disconnect(),
            this.panner.disconnect(this.gain)
        }
        getOutput() {
            return this.panner
        }
        getRefDistance() {
            return this.panner.refDistance
        }
        setRefDistance(e) {
            return this.panner.refDistance = e,
            this
        }
        getRolloffFactor() {
            return this.panner.rolloffFactor
        }
        setRolloffFactor(e) {
            return this.panner.rolloffFactor = e,
            this
        }
        getDistanceModel() {
            return this.panner.distanceModel
        }
        setDistanceModel(e) {
            return this.panner.distanceModel = e,
            this
        }
        getMaxDistance() {
            return this.panner.maxDistance
        }
        setMaxDistance(e) {
            return this.panner.maxDistance = e,
            this
        }
        setDirectionalCone(e, t, n) {
            return this.panner.coneInnerAngle = e,
            this.panner.coneOuterAngle = t,
            this.panner.coneOuterGain = n,
            this
        }
        updateMatrixWorld(e) {
            if (super.updateMatrixWorld(e),
            !0 === this.hasPlaybackControl && !1 === this.isPlaying)
                return;
            this.matrixWorld.decompose(du, pu, mu),
            fu.set(0, 0, 1).applyQuaternion(pu);
            const t = this.panner;
            if (t.positionX) {
                const e = this.context.currentTime + this.listener.timeDelta;
                t.positionX.linearRampToValueAtTime(du.x, e),
                t.positionY.linearRampToValueAtTime(du.y, e),
                t.positionZ.linearRampToValueAtTime(du.z, e),
                t.orientationX.linearRampToValueAtTime(fu.x, e),
                t.orientationY.linearRampToValueAtTime(fu.y, e),
                t.orientationZ.linearRampToValueAtTime(fu.z, e)
            } else
                t.setPosition(du.x, du.y, du.z),
                t.setOrientation(fu.x, fu.y, fu.z)
        }
    }
    ,
    PropertyBinding: wu,
    PropertyMixer: gu,
    QuadraticBezierCurve: Il,
    QuadraticBezierCurve3: Dl,
    Quaternion: dn,
    QuaternionKeyframeTrack: uh,
    QuaternionLinearInterpolant: hh,
    REVISION: ee,
    RGBADepthPacking: 3201,
    RGBAFormat: Ie,
    RGBAIntegerFormat: 1033,
    RGBA_ASTC_10x10_Format: nt,
    RGBA_ASTC_10x5_Format: $e,
    RGBA_ASTC_10x6_Format: et,
    RGBA_ASTC_10x8_Format: tt,
    RGBA_ASTC_12x10_Format: it,
    RGBA_ASTC_12x12_Format: rt,
    RGBA_ASTC_4x4_Format: je,
    RGBA_ASTC_5x4_Format: Xe,
    RGBA_ASTC_5x5_Format: qe,
    RGBA_ASTC_6x5_Format: Ye,
    RGBA_ASTC_6x6_Format: Ze,
    RGBA_ASTC_8x5_Format: Je,
    RGBA_ASTC_8x6_Format: Ke,
    RGBA_ASTC_8x8_Format: Qe,
    RGBA_BPTC_Format: st,
    RGBA_ETC2_EAC_Format: We,
    RGBA_PVRTC_2BPPV1_Format: He,
    RGBA_PVRTC_4BPPV1_Format: Ge,
    RGBA_S3TC_DXT1_Format: ze,
    RGBA_S3TC_DXT3_Format: Ue,
    RGBA_S3TC_DXT5_Format: Fe,
    RGBFormat: 1022,
    RGB_ETC1_Format: 36196,
    RGB_ETC2_Format: Ve,
    RGB_PVRTC_2BPPV1_Format: ke,
    RGB_PVRTC_4BPPV1_Format: Be,
    RGB_S3TC_DXT1_Format: Ne,
    RGFormat: 1030,
    RGIntegerFormat: 1031,
    RawShaderMaterial: kc,
    Ray: Vn,
    Raycaster: Lu,
    RectAreaLight: Gh,
    RedFormat: 1028,
    RedIntegerFormat: 1029,
    ReinhardToneMapping: 2,
    RepeatWrapping: ve,
    ReplaceStencilOp: 7681,
    ReverseSubtractEquation: 102,
    RingBufferGeometry: class extends Lc {
        constructor(e, t, n, i, r, s) {
            console.warn("THREE.RingBufferGeometry has been renamed to THREE.RingGeometry."),
            super(e, t, n, i, r, s)
        }
    }
    ,
    RingGeometry: Lc,
    SRGBColorSpace: vt,
    Scene: lo,
    ShaderChunk: Rr,
    ShaderLib: Ir,
    ShaderMaterial: pr,
    ShadowMaterial: Bc,
    Shape: Jl,
    ShapeBufferGeometry: class extends Rc {
        constructor(e, t) {
            console.warn("THREE.ShapeBufferGeometry has been renamed to THREE.ShapeGeometry."),
            super(e, t)
        }
    }
    ,
    ShapeGeometry: Rc,
    ShapePath: td,
    ShapeUtils: Mc,
    ShortType: 1011,
    Skeleton: Ho,
    SkeletonHelper: class extends rl {
        constructor(e) {
            const t = ku(e)
              , n = new Vi
              , i = []
              , r = []
              , s = new en(0,0,1)
              , a = new en(0,1,0);
            for (let e = 0; e < t.length; e++) {
                const n = t[e];
                n.parent && n.parent.isBone && (i.push(0, 0, 0),
                i.push(0, 0, 0),
                r.push(s.r, s.g, s.b),
                r.push(a.r, a.g, a.b))
            }
            n.setAttribute("position", new Ni(i,3)),
            n.setAttribute("color", new Ni(r,3));
            super(n, new Zo({
                vertexColors: !0,
                depthTest: !1,
                depthWrite: !1,
                toneMapped: !1,
                transparent: !0
            })),
            this.isSkeletonHelper = !0,
            this.type = "SkeletonHelper",
            this.root = e,
            this.bones = t,
            this.matrix = e.matrixWorld,
            this.matrixAutoUpdate = !1
        }
        updateMatrixWorld(e) {
            const t = this.bones
              , n = this.geometry
              , i = n.getAttribute("position");
            Bu.copy(this.root.matrixWorld).invert();
            for (let e = 0, n = 0; e < t.length; e++) {
                const r = t[e];
                r.parent && r.parent.isBone && (Fu.multiplyMatrices(Bu, r.matrixWorld),
                Uu.setFromMatrixPosition(Fu),
                i.setXYZ(n, Uu.x, Uu.y, Uu.z),
                Fu.multiplyMatrices(Bu, r.parent.matrixWorld),
                Uu.setFromMatrixPosition(Fu),
                i.setXYZ(n + 1, Uu.x, Uu.y, Uu.z),
                n += 2)
            }
            n.getAttribute("position").needsUpdate = !0,
            super.updateMatrixWorld(e)
        }
    }
    ,
    SkinnedMesh: Uo,
    Source: rn,
    Sphere: Nn,
    SphereBufferGeometry: sd,
    SphereGeometry: Pc,
    Spherical: Iu,
    SphericalHarmonics3: Hh,
    SplineCurve: Ol,
    SpotLight: Ih,
    SpotLightHelper: class extends fi {
        constructor(e, t) {
            super(),
            this.light = e,
            this.light.updateMatrixWorld(),
            this.matrix = e.matrixWorld,
            this.matrixAutoUpdate = !1,
            this.color = t;
            const n = new Vi
              , i = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
            for (let e = 0, t = 1, n = 32; e < n; e++,
            t++) {
                const r = e / n * Math.PI * 2
                  , s = t / n * Math.PI * 2;
                i.push(Math.cos(r), Math.sin(r), 1, Math.cos(s), Math.sin(s), 1)
            }
            n.setAttribute("position", new Ni(i,3));
            const r = new Zo({
                fog: !1,
                toneMapped: !1
            });
            this.cone = new rl(n,r),
            this.add(this.cone),
            this.update()
        }
        dispose() {
            this.cone.geometry.dispose(),
            this.cone.material.dispose()
        }
        update() {
            this.light.updateMatrixWorld();
            const e = this.light.distance ? this.light.distance : 1e3
              , t = e * Math.tan(this.light.angle);
            this.cone.scale.set(t, t, e),
            zu.setFromMatrixPosition(this.light.target.matrixWorld),
            this.cone.lookAt(zu),
            void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
        }
    }
    ,
    Sprite: Eo,
    SpriteMaterial: po,
    SrcAlphaFactor: 204,
    SrcAlphaSaturateFactor: 210,
    SrcColorFactor: 202,
    StaticCopyUsage: 35046,
    StaticDrawUsage: _t,
    StaticReadUsage: 35045,
    StereoCamera: class {
        constructor() {
            this.type = "StereoCamera",
            this.aspect = 1,
            this.eyeSep = .064,
            this.cameraL = new fr,
            this.cameraL.layers.enable(1),
            this.cameraL.matrixAutoUpdate = !1,
            this.cameraR = new fr,
            this.cameraR.layers.enable(2),
            this.cameraR.matrixAutoUpdate = !1,
            this._cache = {
                focus: null,
                fov: null,
                aspect: null,
                near: null,
                far: null,
                zoom: null,
                eyeSep: null
            }
        }
        update(e) {
            const t = this._cache;
            if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
                t.focus = e.focus,
                t.fov = e.fov,
                t.aspect = e.aspect * this.aspect,
                t.near = e.near,
                t.far = e.far,
                t.zoom = e.zoom,
                t.eyeSep = this.eyeSep,
                iu.copy(e.projectionMatrix);
                const n = t.eyeSep / 2
                  , i = n * t.near / t.focus
                  , r = t.near * Math.tan(At * t.fov * .5) / t.zoom;
                let s, a;
                nu.elements[12] = -n,
                tu.elements[12] = n,
                s = -r * t.aspect + i,
                a = r * t.aspect + i,
                iu.elements[0] = 2 * t.near / (a - s),
                iu.elements[8] = (a + s) / (a - s),
                this.cameraL.projectionMatrix.copy(iu),
                s = -r * t.aspect - i,
                a = r * t.aspect - i,
                iu.elements[0] = 2 * t.near / (a - s),
                iu.elements[8] = (a + s) / (a - s),
                this.cameraR.projectionMatrix.copy(iu)
            }
            this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(nu),
            this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(tu)
        }
    }
    ,
    StreamCopyUsage: 35042,
    StreamDrawUsage: 35040,
    StreamReadUsage: 35041,
    StringKeyframeTrack: dh,
    SubtractEquation: 101,
    SubtractiveBlending: 3,
    TOUCH: ne,
    TangentSpaceNormalMap: 0,
    TetrahedronBufferGeometry: class extends Ic {
        constructor(e, t) {
            console.warn("THREE.TetrahedronBufferGeometry has been renamed to THREE.TetrahedronGeometry."),
            super(e, t)
        }
    }
    ,
    TetrahedronGeometry: Ic,
    Texture: on,
    TextureLoader: Sh,
    TorusBufferGeometry: class extends Dc {
        constructor(e, t, n, i, r) {
            console.warn("THREE.TorusBufferGeometry has been renamed to THREE.TorusGeometry."),
            super(e, t, n, i, r)
        }
    }
    ,
    TorusGeometry: Dc,
    TorusKnotBufferGeometry: class extends Oc {
        constructor(e, t, n, i, r, s) {
            console.warn("THREE.TorusKnotBufferGeometry has been renamed to THREE.TorusKnotGeometry."),
            super(e, t, n, i, r, s)
        }
    }
    ,
    TorusKnotGeometry: Oc,
    Triangle: Ai,
    TriangleFanDrawMode: 2,
    TriangleStripDrawMode: 1,
    TrianglesDrawMode: 0,
    TubeBufferGeometry: class extends Nc {
        constructor(e, t, n, i, r) {
            console.warn("THREE.TubeBufferGeometry has been renamed to THREE.TubeGeometry."),
            super(e, t, n, i, r)
        }
    }
    ,
    TubeGeometry: Nc,
    UVMapping: ue,
    Uint16BufferAttribute: Di,
    Uint32BufferAttribute: Oi,
    Uint8BufferAttribute: class extends Ii {
        constructor(e, t, n) {
            super(new Uint8Array(e), t, n)
        }
    }
    ,
    Uint8ClampedBufferAttribute: class extends Ii {
        constructor(e, t, n) {
            super(new Uint8ClampedArray(e), t, n)
        }
    }
    ,
    Uniform: Eu,
    UniformsGroup: class extends wt {
        constructor() {
            super(),
            this.isUniformsGroup = !0,
            Object.defineProperty(this, "id", {
                value: Cu++
            }),
            this.name = "",
            this.usage = _t,
            this.uniforms = []
        }
        add(e) {
            return this.uniforms.push(e),
            this
        }
        remove(e) {
            const t = this.uniforms.indexOf(e);
            return -1 !== t && this.uniforms.splice(t, 1),
            this
        }
        setName(e) {
            return this.name = e,
            this
        }
        setUsage(e) {
            return this.usage = e,
            this
        }
        dispose() {
            return this.dispatchEvent({
                type: "dispose"
            }),
            this
        }
        copy(e) {
            this.name = e.name,
            this.usage = e.usage;
            const t = e.uniforms;
            this.uniforms.length = 0;
            for (let e = 0, n = t.length; e < n; e++)
                this.uniforms.push(t[e].clone());
            return this
        }
        clone() {
            return (new this.constructor).copy(this)
        }
    }
    ,
    UniformsLib: Pr,
    UniformsUtils: dr,
    UnsignedByteType: Ae,
    UnsignedInt248Type: Pe,
    UnsignedIntType: Ce,
    UnsignedShort4444Type: 1017,
    UnsignedShort5551Type: 1018,
    UnsignedShortType: Ee,
    VSMShadowMap: 3,
    Vector2: Ft,
    Vector3: pn,
    Vector4: ln,
    VectorKeyframeTrack: ph,
    VideoTexture: pl,
    WebGL1Renderer: so,
    WebGL3DRenderTarget: class extends cn {
        constructor(e, t, n) {
            super(e, t),
            this.isWebGL3DRenderTarget = !0,
            this.depth = n,
            this.texture = new un(null,e,t,n),
            this.texture.isRenderTargetTexture = !0
        }
    }
    ,
    WebGLArrayRenderTarget: class extends cn {
        constructor(e, t, n) {
            super(e, t),
            this.isWebGLArrayRenderTarget = !0,
            this.depth = n,
            this.texture = new hn(null,e,t,n),
            this.texture.isRenderTargetTexture = !0
        }
    }
    ,
    WebGLCubeRenderTarget: yr,
    WebGLMultipleRenderTargets: class extends cn {
        constructor(e, t, n, i={}) {
            super(e, t, i),
            this.isWebGLMultipleRenderTargets = !0;
            const r = this.texture;
            this.texture = [];
            for (let e = 0; e < n; e++)
                this.texture[e] = r.clone(),
                this.texture[e].isRenderTargetTexture = !0
        }
        setSize(e, t, n=1) {
            if (this.width !== e || this.height !== t || this.depth !== n) {
                this.width = e,
                this.height = t,
                this.depth = n;
                for (let i = 0, r = this.texture.length; i < r; i++)
                    this.texture[i].image.width = e,
                    this.texture[i].image.height = t,
                    this.texture[i].image.depth = n;
                this.dispose()
            }
            return this.viewport.set(0, 0, e, t),
            this.scissor.set(0, 0, e, t),
            this
        }
        copy(e) {
            this.dispose(),
            this.width = e.width,
            this.height = e.height,
            this.depth = e.depth,
            this.viewport.set(0, 0, this.width, this.height),
            this.scissor.set(0, 0, this.width, this.height),
            this.depthBuffer = e.depthBuffer,
            this.stencilBuffer = e.stencilBuffer,
            null !== e.depthTexture && (this.depthTexture = e.depthTexture.clone()),
            this.texture.length = 0;
            for (let t = 0, n = e.texture.length; t < n; t++)
                this.texture[t] = e.texture[t].clone(),
                this.texture[t].isRenderTargetTexture = !0;
            return this
        }
    }
    ,
    WebGLMultisampleRenderTarget: class extends cn {
        constructor(e, t, n) {
            console.error('THREE.WebGLMultisampleRenderTarget has been removed. Use a normal render target and set the "samples" property to greater 0 to enable multisampling.'),
            super(e, t, n),
            this.samples = 4
        }
    }
    ,
    WebGLRenderTarget: cn,
    WebGLRenderer: ro,
    WebGLUtils: Za,
    WireframeGeometry: zc,
    WrapAroundEnding: dt,
    ZeroCurvatureEnding: ht,
    ZeroFactor: 200,
    ZeroSlopeEnding: ut,
    ZeroStencilOp: 0,
    _SRGBAFormat: Mt,
    sRGBEncoding: gt
})
  , od = Ut.degToRad
  , ld = Math
  , cd = (e,t)=>1e3 * ((e,t)=>{
    var n = od(t.lat - e.lat) / 2
      , i = od(t.lng - e.lng) / 2
      , r = od(e.lat)
      , s = od(t.lat)
      , a = ld.sin(n) * ld.sin(n) + ld.sin(i) * ld.sin(i) * (ld.cos(r) * ld.cos(s));
    return 2 * ld.atan2(ld.sqrt(a), ld.sqrt(1 - a)) * 6371
}
)(e, t)
  , hd = (e,t)=>((e,t)=>t.sort(((t,n)=>cd(e, t) - cd(e, n))))(e, t)[0]
  , ud = function(e) {
    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 8;
    return parseFloat(e).toPrecision(t) / 1
}
  , dd = ["className", "id", "innerText", "children", "on", "parent", "style"]
  , pd = function(e) {
    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
      , {parent: n=G.D, single: i=!1} = t
      , r = e.split(" ")
      , s = r[r.length - 1];
    return i || s.startsWith("#") ? n.querySelector(e) : Array.from(n.querySelectorAll(e))
};
pd.show = (e,t)=>{
    k.str(e) && (e = pd(e, t)),
    e && (k.arr(e) ? e.forEach((e=>pd.show(e, t))) : e.classList && e.classList.add("visible"))
}
,
pd.hide = (e,t)=>{
    k.str(e) && (e = pd(e, t)),
    e && (k.arr(e) ? e.forEach((e=>pd.hide(e, t))) : e.classList && e.classList.remove("visible"))
}
,
pd.prop = function(e) {
    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    k.str(e) && (e = pd(e)),
    Object.entries(t).forEach((t=>{
        var [n,i] = t;
        !1 === i ? e.removeAttribute(n) : e.setAttribute(n, i)
    }
    ))
}
,
pd.create = function() {
    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "div"
      , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
      , {className: n, id: i, innerText: r, children: a, on: o, parent: l, style: c} = t
      , h = s(t, dd)
      , u = G.D.createElement(e);
    n && (u.className = n),
    r && (u.innerText = r),
    a && (k.str(a) ? u.innerText += a : k.arr(a) && a.forEach((e=>u.appendChild(e)))),
    c && Object.entries(c).forEach((e=>{
        var [t,n] = e;
        u.style[t] = n
    }
    )),
    i && u.setAttribute("id", i),
    o && Object.entries(o).forEach((e=>{
        var [t,n] = e;
        u.addEventListener(t, n)
    }
    )),
    l && pd.append(u, l);
    var d = Object.entries(h);
    return d.length && d.map((e=>{
        var [t,n] = e;
        u.setAttribute(t, n)
    }
    )),
    u
}
,
pd.on = function(e, t, n) {
    var i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
    k.str(e) && (e = pd(e)),
    k.arr(e) ? e.forEach((e=>e.addEventListener(t, n, !1, i))) : e.addEventListener(t, n, !1, i)
}
,
pd.off = (e,t,n,i)=>{
    k.str(e) && (e = pd(e)),
    k.arr(e) ? e.forEach((e=>e.removeEventListener(t, n, !1, i))) : e.removeEventListener(t, n, !1, i)
}
,
pd.append = function(e) {
    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : B;
    k.str(e) && (e = pd(e)),
    k.str(t) && (t = pd(t)),
    t && e && (k.arr(e) ? e.forEach((e=>t.appendChild(e))) : t.appendChild(e))
}
,
pd.remove = e=>{
    e && (k.str(e) && (e = pd(e)),
    k.arr(e) && e.forEach(pd.remove),
    e && e.parentNode && e.parentNode.removeChild(e))
}
;
var md, fd = ()=>new URLSearchParams(G.location.hash.substr(1)), gd = ()=>{
    var e = fd()
      , t = e.get("z");
    k.num(parseInt(t, 10)) || e.set("z", 17);
    var n = {}
      , i = {
        z: "zoom",
        d: "detail",
        p: "popup",
        s: "screen"
    };
    for (var [r,s] of e.entries())
        r in i && (r = i[r]),
        n[r] = s;
    return n
}
, vd = function() {
    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    G.STATE = t(t({}, G.STATE), e);
    var n = JSON.stringify(G.STATE)
      , i = JSON.stringify(G.OLD_STATE);
    n !== i && (xd(G.STATE),
    G.OLD_STATE = G.STATE)
}, xd = function() {
    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
      , {detail: t, lat: n, lng: i, popup: r, screen: s, three: a, zoom: o} = e
      , l = fd();
    o && l.set("z", ud(o, 3)),
    n && l.set("lat", ud(n, 7)),
    i && l.set("lng", ud(i, 7)),
    r ? l.set("p", r) : !1 === r && l.delete("p"),
    t ? l.set("d", t) : !1 === t && l.delete("d"),
    s ? l.set("s", s) : !1 === s && l.delete("s"),
    a || l.delete("t"),
    G.location.hash = l.toString()
}, yd = e=>{
    var {map: t, zoom: n} = e
      , {locationLayer: i, artifactLayer: r} = t;
    if (i) {
        var s = 16;
        i.zoomFromLocationToObject && (s = i.zoomFromLocationToObject),
        n >= s ? (t.hasLayer(i) && t.removeLayer(i),
        t.hasLayer(r) || t.addLayer(r)) : (t.hasLayer(i) || t.addLayer(i),
        t.hasLayer(r) && t.removeLayer(r))
    }
}
, _d = e=>{
    var t = pd(".nav.menu");
    e ? t.forEach((t=>{
        if (t.dataset.to) {
            var n = t.dataset.to === e || t.classList.contains(e)
              , i = e.includes("-") && t.classList.contains(e.split("-")[0]);
            n || i ? t.classList.add("active") : t.classList.remove("active")
        } else
            t.classList.remove("active")
    }
    )) : t.forEach((e=>{
        e.classList.contains("map") ? e.classList.add("active") : e.classList.remove("active")
    }
    ))
}
, bd = e=>{
    var t, n = !1;
    ("home" === e && (e = "about"),
    pd(".screen.visible").forEach((e=>{
        e.classList.remove("visible")
    }
    )),
    pd(".screen[data-name=".concat(e, "]")).forEach((e=>{
        e.classList.add("visible"),
        n = !0
    }
    )),
    e) && (e.startsWith("list-") ? t = pd(".screen[data-name=list]", {
        single: !0
    }) : e.startsWith("help-") && (t = pd(".screen[data-name=help]", {
        single: !0
    })),
    t && (t.classList.add("visible"),
    n = !0));
    n ? ("about" === e && G.B.classList.add("about"),
    G.B.classList.add("screen-visible")) : G.B.classList.remove("screen-visible", "about")
}
, Md = e=>{
    pd(".detail .info").forEach((t=>{
        var n = t.parentNode
          , {slug: i} = n.dataset;
        if (i === e) {
            n.classList.add("visible");
            var r = n.offsetTop;
            k.num(r) && (n.parentNode.parentNode.scrollTop = r)
        } else
            n.classList.remove("visible")
    }
    ))
}
, wd = e=>{
    var {map: t, popup: n} = e;
    t && t.locationLayer && [t.locationLayer, t.artifactLayer].forEach((e=>{
        e.eachLayer((e=>{
            n && e.slug === n && e.openPopup()
        }
        ))
    }
    ))
}
, Sd = e=>{
    e.currentTarget.parentNode.scrollTop = 0
}
, Td = e=>{
    md = e;
    var t = new URL(G.location);
    t.hash && "#" !== t.hash ? t.hash.includes("&t=1") || t.hash.startsWith("#t=1") || (t.hash = "".concat(t.hash, "&t=1"),
    G.history.pushState({}, "", t)) : (t.hash = "#t=1",
    G.history.pushState({}, "", t))
}
, Ad = ()=>{
    md = null,
    xd()
}
, Ed = function() {
    var e = i((function*() {
        if (md)
            return yield md.onExitButtonClick(),
            md = null,
            !0
    }
    ));
    return function() {
        return e.apply(this, arguments)
    }
}(), Cd = (e,t,n)=>{
    return i = Math.round(e + n * (t - e)),
    r = 0,
    s = 255,
    Math.min(s, Math.max(r, i));
    var i, r, s
}
, Ld = (e,t,n)=>{
    var [i,r,s] = e
      , [a,o,l] = t
      , c = Cd(i, a, n)
      , h = Cd(r, o, n)
      , u = Cd(s, l, n);
    return "rgb(".concat(c, ", ").concat(h, ", ").concat(u, ")")
}
, Rd = e=>{
    var t = pd(".screen.about", {
        single: !0
    })
      , n = pd(".hero", {
        single: !0
    })
      , i = pd("header.main", {
        single: !0
    })
      , r = n && i ? n.clientHeight + i.clientHeight + 200 : 0
      , s = pd("#cityslide")
      , a = pd(".mainMenu", {
        single: !0
    })
      , o = pd(".logoPath", {
        single: !0
    })
      , l = t && t.classList.contains("visible")
      , c = !0 === e || l
      , h = t && t.scrollTop < r;
    if (c && h) {
        var u = t.scrollTop;
        if (s.style.marginLeft = "-".concat(u, "px"),
        i && n) {
            var d = u / n.clientHeight
              , p = Ld([12, 12, 12], [250, 250, 250], d);
            i.style.backgroundColor = p;
            var m = Ld([250, 250, 250], [12, 12, 12], d);
            a && (a.style.color = m),
            o && (o.style.fill = m),
            ((e,t)=>{
                var n = "* {scrollbar-color: ".concat(t, " ").concat(e, ";}")
                  , i = pd("#js-css");
                i || (i = pd.create("style", {
                    id: "js-css"
                })),
                i.innerHTML = n,
                pd("head", {
                    single: !0
                }).appendChild(i)
            }
            )(p, m)
        }
    } else if (i.style.backgroundColor) {
        i.style = {},
        a.style = {},
        o.style = {};
        var f = pd("#js-css");
        f && (f.innerHTML = "")
    }
}
, Pd = e=>{
    var t, n, i = null === (t = e.popup) || void 0 === t || null === (n = t._source) || void 0 === n ? void 0 : n.slug;
    i && vd({
        popup: i
    })
}
, Id = ()=>{
    vd({
        popup: !1
    })
}
, Dd = e=>{
    var {lat: t, lng: n} = e.target.getCenter();
    vd({
        lat: t,
        lng: n
    })
}
, Od = e=>{
    var t = e.target
      , {lat: n, lng: i} = t.getCenter()
      , r = t.getZoom();
    vd({
        lat: n,
        lng: i,
        zoom: r
    })
}
, Nd = e=>{
    var {map: t, lat: n, lng: i, zoom: r, detail: s} = e;
    return ()=>{
        var e = t.getZoom();
        vd({
            lat: n,
            lng: i,
            detail: s,
            zoom: e > r ? e : r
        })
    }
}
, zd = e=>{
    if (!(G.location.hash.length > 0)) {
        var {lat: t, lng: n, zoom: i} = e
          , r = !1;
        return G.APP_DB.cities && !G.APP_DB.city ? r = "about" : G.innerWidth > 800 && (r = "list"),
        vd({
            lat: t,
            lng: n,
            zoom: i,
            screen: r
        }),
        G.STATE = {
            lat: t,
            lng: n,
            zoom: i
        },
        G.OLD_STATE = G.STATE,
        {
            lat: t,
            lng: n,
            zoom: i
        }
    }
    return gd()
}
, Ud = e=>{
    var t, {popup: n, screen: r, zoom: s, detail: a} = gd();
    yd({
        map: e,
        zoom: s
    }),
    n && wd({
        map: e,
        popup: n
    }),
    _d(r),
    r && (bd(r),
    G.B.classList.add("screen-visible")),
    Md(a),
    (t = pd(".screen.about", {
        single: !0
    })) && (Rd(!0),
    pd.on(t, "scroll", Rd, {
        passive: !0
    })),
    pd.on(G, "popstate", (e=>i((function*() {
        if (yield Ed())
            return !1;
        var t = e.getCenter()
          , n = e.getZoom()
          , {lat: i=t.lat, lng: r=t.lng, zoom: s=n, popup: a, screen: o, detail: l} = gd();
        bd(o),
        Md(l),
        _d(o),
        yd({
            map: e,
            zoom: s
        }),
        wd({
            map: e,
            popup: a
        }),
        Rd(),
        (t.lat !== i || t.lng !== r || s !== n) && e.setView({
            lat: i,
            lng: r
        }, s)
    }
    )))(e)),
    pd.on(e, "popupopen", Pd),
    pd.on(e, "popupclose", Id),
    pd.on(e, "zoomend", Od),
    pd.on(e, "dragend", Dd),
    pd.on(".nav", "click", (e=>t=>{
        var n, i, r = t.currentTarget, {dataset: s, classList: a, parentNode: o} = r, {to: l} = s, {z: c, lat: h, lng: u, detail: d, popup: p} = s, {slug: m} = o.dataset;
        l ? a.contains("active") ? a.contains("no-toggle") || (n = !1) : n = l : (a.contains("exit") || a.contains("close") && G.B.clientWidth < 800) && (n = !1),
        m && [e.locationLayer, e.artifactLayer].forEach((e=>{
            e.eachLayer((e=>{
                e.slug === m && (i = m)
            }
            ))
        }
        )),
        "show" === d ? d = !o.classList.contains("visible") && m : "hide" === d && (d = !1),
        p && (i = p),
        vd({
            detail: d,
            lat: h,
            lng: u,
            zoom: c,
            popup: i,
            screen: n
        }),
        a.contains("scroll") && setTimeout((()=>{
            var e = o.parentNode.parentNode
              , t = o.offsetTop;
            e.scrollTop = t
        }
        ), 50)
    }
    )(e)),
    pd.on(".backToTop", "click", Sd)
}
, Fd = ()=>{
    if ((j || K || X) && "true" !== G.store.getItem("warningSeen")) {
        var e = !1;
        j && (q ? (e = !0,
        pd.show("#warning .safari")) : Q || (e = !0,
        pd.show("#warning .no-webxr")),
        e && (pd.show("#warning .ios"),
        pd.show("#warning .ios .all"))),
        K && (J ? Z < 86 && (e = !0,
        pd.show("#warning .chrome.old")) : (e = !0,
        pd.show("#warning .chrome.no")),
        e && (pd.show("#warning .android"),
        pd.show("#warning .android .all"))),
        X && q && (pd.show("#warning .safari"),
        pd.show("#warning .macos")),
        e && (pd.show("#warning"),
        pd.on("#close-warning", "click", (()=>{
            pd.hide("#warning")
        }
        )),
        G.store.setItem("warningSeen", !0))
    }
}
, Bd = e=>{
    var t = e.currentTarget.parentNode.parentNode
      , n = G.store.getItem("popups", [])
      , i = t.getAttribute("id")
      , r = t.classList.contains("once");
    !n.includes(i) && r && (n.push(i),
    G.store.setItem("popups", n)),
    pd.hide(t)
}
, kd = ()=>{
    pd(".popup").forEach((e=>{
        e.getAttribute("id"),
        pd("button.close", {
            parent: e
        }).forEach((e=>{
            pd.on(e, "click", Bd)
        }
        )),
        pd("button.action", {
            parent: e
        }).forEach((e=>{
            pd.on(e, "click", (e=>{
                if (e.currentTarget.classList.contains("teleport")) {
                    var t = G.store.getItem("nearestCity")
                      , n = APP_DB.cities.find((e=>e.slug === t));
                    G.location.href = "/".concat(t, "/#z=").concat(n.zoom, "&lat=").concat(n.lat, "&lng=").concat(n.lng)
                }
            }
            ))
        }
        ))
    }
    ))
}
, Gd = function() {
    var e = i((function*(e) {
        if (!G.createImageBitmap)
            return !1;
        var t = yield G.fetch(e)
          , n = yield t.blob();
        try {
            return yield G.createImageBitmap(n),
            !0
        } catch (e) {
            return !1
        }
    }
    ));
    return function(t) {
        return e.apply(this, arguments)
    }
}(), Hd = function() {
    var e = i((function*() {
        var {xr: e} = G.NAV;
        if (!e)
            return !1;
        try {
            return yield e.isSessionSupported("immersive-ar")
        } catch (e) {
            return !1
        }
    }
    ));
    return function() {
        return e.apply(this, arguments)
    }
}(), Vd = ()=>{
    try {
        var e = pd.create("canvas");
        return G.WebGLRenderingContext && ["webgl", "experimental-webgl", "moz-webgl", "webkit-3d"].some((t=>e.getContext(t)))
    } catch (e) {
        return !1
    }
}
, Wd = ()=>{
    try {
        var e = pd.create("canvas");
        return !(!G.WebGL2RenderingContext || !e.getContext("webgl2"))
    } catch (e) {
        return !1
    }
}
, jd = ()=>{
    if (Y)
        return !1;
    return Gd("data:image/avif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAIAAACQd1PeAAAACXBIWXMAAC4jAAAuIwF4pT92AAAADElEQVQI12Pg4eEBAABMACV5R6hLAAAAAElFTkSuQmCC")
}
, Xd = ()=>{
    var e = pd.create("audio");
    return {
        A_MP3: e.canPlayType("audio/mpeg"),
        A_OGG: e.canPlayType("audio/ogg"),
        A_MP4: e.canPlayType("audio/mp4")
    }
}
, qd = function() {
    var e = i((function*() {
        var [e,n,i,r,s,a] = yield Promise.all([Hd(), Gd("data:image/webp;base64,UklGRiQAAABXRUJQVlA4IBgAAAAwAQCdASoBAAEAAUAmJaQAA3AA/vzA8AA="), jd(), Vd(), Wd(), Xd()]);
        return t({
            XR: e,
            WEBP: n,
            AVIF: i,
            WEBGL: r,
            WEBGL2: s
        }, a)
    }
    ));
    return function() {
        return e.apply(this, arguments)
    }
}();
class Yd extends yh {
    constructor(e) {
        super(e),
        this.dracoLoader = null,
        this.ktx2Loader = null,
        this.meshoptDecoder = null,
        this.pluginCallbacks = [],
        this.register((function(e) {
            return new ep(e)
        }
        )),
        this.register((function(e) {
            return new op(e)
        }
        )),
        this.register((function(e) {
            return new lp(e)
        }
        )),
        this.register((function(e) {
            return new np(e)
        }
        )),
        this.register((function(e) {
            return new ip(e)
        }
        )),
        this.register((function(e) {
            return new rp(e)
        }
        )),
        this.register((function(e) {
            return new sp(e)
        }
        )),
        this.register((function(e) {
            return new $d(e)
        }
        )),
        this.register((function(e) {
            return new ap(e)
        }
        )),
        this.register((function(e) {
            return new tp(e)
        }
        )),
        this.register((function(e) {
            return new Kd(e)
        }
        )),
        this.register((function(e) {
            return new cp(e)
        }
        ))
    }
    load(e, t, n, i) {
        const r = this;
        let s;
        s = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : jh.extractUrlBase(e),
        this.manager.itemStart(e);
        const a = function(t) {
            i ? i(t) : console.error(t),
            r.manager.itemError(e),
            r.manager.itemEnd(e)
        }
          , o = new Mh(this.manager);
        o.setPath(this.path),
        o.setResponseType("arraybuffer"),
        o.setRequestHeader(this.requestHeader),
        o.setWithCredentials(this.withCredentials),
        o.load(e, (function(n) {
            try {
                r.parse(n, s, (function(n) {
                    t(n),
                    r.manager.itemEnd(e)
                }
                ), a)
            } catch (e) {
                a(e)
            }
        }
        ), n, a)
    }
    setDRACOLoader(e) {
        return this.dracoLoader = e,
        this
    }
    setDDSLoader() {
        throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
    }
    setKTX2Loader(e) {
        return this.ktx2Loader = e,
        this
    }
    setMeshoptDecoder(e) {
        return this.meshoptDecoder = e,
        this
    }
    register(e) {
        return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e),
        this
    }
    unregister(e) {
        return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
        this
    }
    parse(e, t, n, i) {
        let r;
        const s = {}
          , a = {};
        if ("string" == typeof e)
            r = e;
        else {
            if (jh.decodeText(new Uint8Array(e,0,4)) === hp) {
                try {
                    s[Jd.KHR_BINARY_GLTF] = new pp(e)
                } catch (e) {
                    return void (i && i(e))
                }
                r = s[Jd.KHR_BINARY_GLTF].content
            } else
                r = jh.decodeText(new Uint8Array(e))
        }
        const o = JSON.parse(r);
        if (void 0 === o.asset || o.asset.version[0] < 2)
            return void (i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
        const l = new jp(o,{
            path: t || this.resourcePath || "",
            crossOrigin: this.crossOrigin,
            requestHeader: this.requestHeader,
            manager: this.manager,
            ktx2Loader: this.ktx2Loader,
            meshoptDecoder: this.meshoptDecoder
        });
        l.fileLoader.setRequestHeader(this.requestHeader);
        for (let e = 0; e < this.pluginCallbacks.length; e++) {
            const t = this.pluginCallbacks[e](l);
            a[t.name] = t,
            s[t.name] = !0
        }
        if (o.extensionsUsed)
            for (let e = 0; e < o.extensionsUsed.length; ++e) {
                const t = o.extensionsUsed[e]
                  , n = o.extensionsRequired || [];
                switch (t) {
                case Jd.KHR_MATERIALS_UNLIT:
                    s[t] = new Qd;
                    break;
                case Jd.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                    s[t] = new vp;
                    break;
                case Jd.KHR_DRACO_MESH_COMPRESSION:
                    s[t] = new mp(o,this.dracoLoader);
                    break;
                case Jd.KHR_TEXTURE_TRANSFORM:
                    s[t] = new fp;
                    break;
                case Jd.KHR_MESH_QUANTIZATION:
                    s[t] = new xp;
                    break;
                default:
                    n.indexOf(t) >= 0 && void 0 === a[t] && console.warn('THREE.GLTFLoader: Unknown extension "' + t + '".')
                }
            }
        l.setExtensions(s),
        l.setPlugins(a),
        l.parse(n, i)
    }
    parseAsync(e, t) {
        const n = this;
        return new Promise((function(i, r) {
            n.parse(e, t, i, r)
        }
        ))
    }
}
function Zd() {
    let e = {};
    return {
        get: function(t) {
            return e[t]
        },
        add: function(t, n) {
            e[t] = n
        },
        remove: function(t) {
            delete e[t]
        },
        removeAll: function() {
            e = {}
        }
    }
}
const Jd = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_IOR: "KHR_materials_ior",
    KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
    KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
    KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
    KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_MATERIALS_VOLUME: "KHR_materials_volume",
    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
    EXT_TEXTURE_WEBP: "EXT_texture_webp",
    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
};
class Kd {
    constructor(e) {
        this.parser = e,
        this.name = Jd.KHR_LIGHTS_PUNCTUAL,
        this.cache = {
            refs: {},
            uses: {}
        }
    }
    _markDefs() {
        const e = this.parser
          , t = this.parser.json.nodes || [];
        for (let n = 0, i = t.length; n < i; n++) {
            const i = t[n];
            i.extensions && i.extensions[this.name] && void 0 !== i.extensions[this.name].light && e._addNodeRef(this.cache, i.extensions[this.name].light)
        }
    }
    _loadLight(e) {
        const t = this.parser
          , n = "light:" + e;
        let i = t.cache.get(n);
        if (i)
            return i;
        const r = t.json
          , s = ((r.extensions && r.extensions[this.name] || {}).lights || [])[e];
        let a;
        const o = new en(16777215);
        void 0 !== s.color && o.fromArray(s.color);
        const l = void 0 !== s.range ? s.range : 0;
        switch (s.type) {
        case "directional":
            a = new Bh(o),
            a.target.position.set(0, 0, -1),
            a.add(a.target);
            break;
        case "point":
            a = new Uh(o),
            a.distance = l;
            break;
        case "spot":
            a = new Ih(o),
            a.distance = l,
            s.spot = s.spot || {},
            s.spot.innerConeAngle = void 0 !== s.spot.innerConeAngle ? s.spot.innerConeAngle : 0,
            s.spot.outerConeAngle = void 0 !== s.spot.outerConeAngle ? s.spot.outerConeAngle : Math.PI / 4,
            a.angle = s.spot.outerConeAngle,
            a.penumbra = 1 - s.spot.innerConeAngle / s.spot.outerConeAngle,
            a.target.position.set(0, 0, -1),
            a.add(a.target);
            break;
        default:
            throw new Error("THREE.GLTFLoader: Unexpected light type: " + s.type)
        }
        return a.position.set(0, 0, 0),
        a.decay = 2,
        void 0 !== s.intensity && (a.intensity = s.intensity),
        a.name = t.createUniqueName(s.name || "light_" + e),
        i = Promise.resolve(a),
        t.cache.add(n, i),
        i
    }
    createNodeAttachment(e) {
        const t = this
          , n = this.parser
          , i = n.json.nodes[e]
          , r = (i.extensions && i.extensions[this.name] || {}).light;
        return void 0 === r ? null : this._loadLight(r).then((function(e) {
            return n._getNodeRef(t.cache, r, e)
        }
        ))
    }
}
class Qd {
    constructor() {
        this.name = Jd.KHR_MATERIALS_UNLIT
    }
    getMaterialType() {
        return Li
    }
    extendParams(e, t, n) {
        const i = [];
        e.color = new en(1,1,1),
        e.opacity = 1;
        const r = t.pbrMetallicRoughness;
        if (r) {
            if (Array.isArray(r.baseColorFactor)) {
                const t = r.baseColorFactor;
                e.color.fromArray(t),
                e.opacity = t[3]
            }
            void 0 !== r.baseColorTexture && i.push(n.assignTexture(e, "map", r.baseColorTexture, gt))
        }
        return Promise.all(i)
    }
}
class $d {
    constructor(e) {
        this.parser = e,
        this.name = Jd.KHR_MATERIALS_EMISSIVE_STRENGTH
    }
    extendMaterialParams(e, t) {
        const n = this.parser.json.materials[e];
        if (!n.extensions || !n.extensions[this.name])
            return Promise.resolve();
        const i = n.extensions[this.name].emissiveStrength;
        return void 0 !== i && (t.emissiveIntensity = i),
        Promise.resolve()
    }
}
class ep {
    constructor(e) {
        this.parser = e,
        this.name = Jd.KHR_MATERIALS_CLEARCOAT
    }
    getMaterialType(e) {
        const t = this.parser.json.materials[e];
        return t.extensions && t.extensions[this.name] ? Hc : null
    }
    extendMaterialParams(e, t) {
        const n = this.parser
          , i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const r = []
          , s = i.extensions[this.name];
        if (void 0 !== s.clearcoatFactor && (t.clearcoat = s.clearcoatFactor),
        void 0 !== s.clearcoatTexture && r.push(n.assignTexture(t, "clearcoatMap", s.clearcoatTexture)),
        void 0 !== s.clearcoatRoughnessFactor && (t.clearcoatRoughness = s.clearcoatRoughnessFactor),
        void 0 !== s.clearcoatRoughnessTexture && r.push(n.assignTexture(t, "clearcoatRoughnessMap", s.clearcoatRoughnessTexture)),
        void 0 !== s.clearcoatNormalTexture && (r.push(n.assignTexture(t, "clearcoatNormalMap", s.clearcoatNormalTexture)),
        void 0 !== s.clearcoatNormalTexture.scale)) {
            const e = s.clearcoatNormalTexture.scale;
            t.clearcoatNormalScale = new Ft(e,e)
        }
        return Promise.all(r)
    }
}
class tp {
    constructor(e) {
        this.parser = e,
        this.name = Jd.KHR_MATERIALS_IRIDESCENCE
    }
    getMaterialType(e) {
        const t = this.parser.json.materials[e];
        return t.extensions && t.extensions[this.name] ? Hc : null
    }
    extendMaterialParams(e, t) {
        const n = this.parser
          , i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const r = []
          , s = i.extensions[this.name];
        return void 0 !== s.iridescenceFactor && (t.iridescence = s.iridescenceFactor),
        void 0 !== s.iridescenceTexture && r.push(n.assignTexture(t, "iridescenceMap", s.iridescenceTexture)),
        void 0 !== s.iridescenceIor && (t.iridescenceIOR = s.iridescenceIor),
        void 0 === t.iridescenceThicknessRange && (t.iridescenceThicknessRange = [100, 400]),
        void 0 !== s.iridescenceThicknessMinimum && (t.iridescenceThicknessRange[0] = s.iridescenceThicknessMinimum),
        void 0 !== s.iridescenceThicknessMaximum && (t.iridescenceThicknessRange[1] = s.iridescenceThicknessMaximum),
        void 0 !== s.iridescenceThicknessTexture && r.push(n.assignTexture(t, "iridescenceThicknessMap", s.iridescenceThicknessTexture)),
        Promise.all(r)
    }
}
class np {
    constructor(e) {
        this.parser = e,
        this.name = Jd.KHR_MATERIALS_SHEEN
    }
    getMaterialType(e) {
        const t = this.parser.json.materials[e];
        return t.extensions && t.extensions[this.name] ? Hc : null
    }
    extendMaterialParams(e, t) {
        const n = this.parser
          , i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const r = [];
        t.sheenColor = new en(0,0,0),
        t.sheenRoughness = 0,
        t.sheen = 1;
        const s = i.extensions[this.name];
        return void 0 !== s.sheenColorFactor && t.sheenColor.fromArray(s.sheenColorFactor),
        void 0 !== s.sheenRoughnessFactor && (t.sheenRoughness = s.sheenRoughnessFactor),
        void 0 !== s.sheenColorTexture && r.push(n.assignTexture(t, "sheenColorMap", s.sheenColorTexture, gt)),
        void 0 !== s.sheenRoughnessTexture && r.push(n.assignTexture(t, "sheenRoughnessMap", s.sheenRoughnessTexture)),
        Promise.all(r)
    }
}
class ip {
    constructor(e) {
        this.parser = e,
        this.name = Jd.KHR_MATERIALS_TRANSMISSION
    }
    getMaterialType(e) {
        const t = this.parser.json.materials[e];
        return t.extensions && t.extensions[this.name] ? Hc : null
    }
    extendMaterialParams(e, t) {
        const n = this.parser
          , i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const r = []
          , s = i.extensions[this.name];
        return void 0 !== s.transmissionFactor && (t.transmission = s.transmissionFactor),
        void 0 !== s.transmissionTexture && r.push(n.assignTexture(t, "transmissionMap", s.transmissionTexture)),
        Promise.all(r)
    }
}
class rp {
    constructor(e) {
        this.parser = e,
        this.name = Jd.KHR_MATERIALS_VOLUME
    }
    getMaterialType(e) {
        const t = this.parser.json.materials[e];
        return t.extensions && t.extensions[this.name] ? Hc : null
    }
    extendMaterialParams(e, t) {
        const n = this.parser
          , i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const r = []
          , s = i.extensions[this.name];
        t.thickness = void 0 !== s.thicknessFactor ? s.thicknessFactor : 0,
        void 0 !== s.thicknessTexture && r.push(n.assignTexture(t, "thicknessMap", s.thicknessTexture)),
        t.attenuationDistance = s.attenuationDistance || 0;
        const a = s.attenuationColor || [1, 1, 1];
        return t.attenuationColor = new en(a[0],a[1],a[2]),
        Promise.all(r)
    }
}
class sp {
    constructor(e) {
        this.parser = e,
        this.name = Jd.KHR_MATERIALS_IOR
    }
    getMaterialType(e) {
        const t = this.parser.json.materials[e];
        return t.extensions && t.extensions[this.name] ? Hc : null
    }
    extendMaterialParams(e, t) {
        const n = this.parser.json.materials[e];
        if (!n.extensions || !n.extensions[this.name])
            return Promise.resolve();
        const i = n.extensions[this.name];
        return t.ior = void 0 !== i.ior ? i.ior : 1.5,
        Promise.resolve()
    }
}
class ap {
    constructor(e) {
        this.parser = e,
        this.name = Jd.KHR_MATERIALS_SPECULAR
    }
    getMaterialType(e) {
        const t = this.parser.json.materials[e];
        return t.extensions && t.extensions[this.name] ? Hc : null
    }
    extendMaterialParams(e, t) {
        const n = this.parser
          , i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const r = []
          , s = i.extensions[this.name];
        t.specularIntensity = void 0 !== s.specularFactor ? s.specularFactor : 1,
        void 0 !== s.specularTexture && r.push(n.assignTexture(t, "specularIntensityMap", s.specularTexture));
        const a = s.specularColorFactor || [1, 1, 1];
        return t.specularColor = new en(a[0],a[1],a[2]),
        void 0 !== s.specularColorTexture && r.push(n.assignTexture(t, "specularColorMap", s.specularColorTexture, gt)),
        Promise.all(r)
    }
}
class op {
    constructor(e) {
        this.parser = e,
        this.name = Jd.KHR_TEXTURE_BASISU
    }
    loadTexture(e) {
        const t = this.parser
          , n = t.json
          , i = n.textures[e];
        if (!i.extensions || !i.extensions[this.name])
            return null;
        const r = i.extensions[this.name]
          , s = t.options.ktx2Loader;
        if (!s) {
            if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
                throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
            return null
        }
        return t.loadTextureImage(e, r.source, s)
    }
}
class lp {
    constructor(e) {
        this.parser = e,
        this.name = Jd.EXT_TEXTURE_WEBP,
        this.isSupported = null
    }
    loadTexture(e) {
        const t = this.name
          , n = this.parser
          , i = n.json
          , r = i.textures[e];
        if (!r.extensions || !r.extensions[t])
            return null;
        const s = r.extensions[t]
          , a = i.images[s.source];
        let o = n.textureLoader;
        if (a.uri) {
            const e = n.options.manager.getHandler(a.uri);
            null !== e && (o = e)
        }
        return this.detectSupport().then((function(r) {
            if (r)
                return n.loadTextureImage(e, s.source, o);
            if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
                throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
            return n.loadTexture(e)
        }
        ))
    }
    detectSupport() {
        return this.isSupported || (this.isSupported = new Promise((function(e) {
            const t = new Image;
            t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",
            t.onload = t.onerror = function() {
                e(1 === t.height)
            }
        }
        ))),
        this.isSupported
    }
}
class cp {
    constructor(e) {
        this.name = Jd.EXT_MESHOPT_COMPRESSION,
        this.parser = e
    }
    loadBufferView(e) {
        const t = this.parser.json
          , n = t.bufferViews[e];
        if (n.extensions && n.extensions[this.name]) {
            const e = n.extensions[this.name]
              , i = this.parser.getDependency("buffer", e.buffer)
              , r = this.parser.options.meshoptDecoder;
            if (!r || !r.supported) {
                if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
                    throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                return null
            }
            return i.then((function(t) {
                const n = e.byteOffset || 0
                  , i = e.byteLength || 0
                  , s = e.count
                  , a = e.byteStride
                  , o = new Uint8Array(t,n,i);
                return r.decodeGltfBufferAsync ? r.decodeGltfBufferAsync(s, a, o, e.mode, e.filter).then((function(e) {
                    return e.buffer
                }
                )) : r.ready.then((function() {
                    const t = new ArrayBuffer(s * a);
                    return r.decodeGltfBuffer(new Uint8Array(t), s, a, o, e.mode, e.filter),
                    t
                }
                ))
            }
            ))
        }
        return null
    }
}
const hp = "glTF"
  , up = 1313821514
  , dp = 5130562;
class pp {
    constructor(e) {
        this.name = Jd.KHR_BINARY_GLTF,
        this.content = null,
        this.body = null;
        const t = new DataView(e,0,12);
        if (this.header = {
            magic: jh.decodeText(new Uint8Array(e.slice(0, 4))),
            version: t.getUint32(4, !0),
            length: t.getUint32(8, !0)
        },
        this.header.magic !== hp)
            throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
        if (this.header.version < 2)
            throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
        const n = this.header.length - 12
          , i = new DataView(e,12);
        let r = 0;
        for (; r < n; ) {
            const t = i.getUint32(r, !0);
            r += 4;
            const n = i.getUint32(r, !0);
            if (r += 4,
            n === up) {
                const n = new Uint8Array(e,12 + r,t);
                this.content = jh.decodeText(n)
            } else if (n === dp) {
                const n = 12 + r;
                this.body = e.slice(n, n + t)
            }
            r += t
        }
        if (null === this.content)
            throw new Error("THREE.GLTFLoader: JSON content not found.")
    }
}
class mp {
    constructor(e, t) {
        if (!t)
            throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
        this.name = Jd.KHR_DRACO_MESH_COMPRESSION,
        this.json = e,
        this.dracoLoader = t,
        this.dracoLoader.preload()
    }
    decodePrimitive(e, t) {
        const n = this.json
          , i = this.dracoLoader
          , r = e.extensions[this.name].bufferView
          , s = e.extensions[this.name].attributes
          , a = {}
          , o = {}
          , l = {};
        for (const e in s) {
            const t = Dp[e] || e.toLowerCase();
            a[t] = s[e]
        }
        for (const t in e.attributes) {
            const i = Dp[t] || t.toLowerCase();
            if (void 0 !== s[t]) {
                const r = n.accessors[e.attributes[t]]
                  , s = Lp[r.componentType];
                l[i] = s.name,
                o[i] = !0 === r.normalized
            }
        }
        return t.getDependency("bufferView", r).then((function(e) {
            return new Promise((function(t) {
                i.decodeDracoFile(e, (function(e) {
                    for (const t in e.attributes) {
                        const n = e.attributes[t]
                          , i = o[t];
                        void 0 !== i && (n.normalized = i)
                    }
                    t(e)
                }
                ), a, l)
            }
            ))
        }
        ))
    }
}
class fp {
    constructor() {
        this.name = Jd.KHR_TEXTURE_TRANSFORM
    }
    extendTexture(e, t) {
        return void 0 !== t.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'),
        void 0 === t.offset && void 0 === t.rotation && void 0 === t.scale || (e = e.clone(),
        void 0 !== t.offset && e.offset.fromArray(t.offset),
        void 0 !== t.rotation && (e.rotation = t.rotation),
        void 0 !== t.scale && e.repeat.fromArray(t.scale),
        e.needsUpdate = !0),
        e
    }
}
class gp extends Gc {
    constructor(e) {
        super(),
        this.isGLTFSpecularGlossinessMaterial = !0;
        const t = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n")
          , n = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n")
          , i = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n")
          , r = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n")
          , s = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.roughness += geometryRoughness;", "material.roughness = min( material.roughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n")
          , a = {
            specular: {
                value: (new en).setHex(16777215)
            },
            glossiness: {
                value: 1
            },
            specularMap: {
                value: null
            },
            glossinessMap: {
                value: null
            }
        };
        this._extraUniforms = a,
        this.onBeforeCompile = function(e) {
            for (const t in a)
                e.uniforms[t] = a[t];
            e.fragmentShader = e.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", t).replace("#include <metalnessmap_pars_fragment>", n).replace("#include <roughnessmap_fragment>", i).replace("#include <metalnessmap_fragment>", r).replace("#include <lights_physical_fragment>", s)
        }
        ,
        Object.defineProperties(this, {
            specular: {
                get: function() {
                    return a.specular.value
                },
                set: function(e) {
                    a.specular.value = e
                }
            },
            specularMap: {
                get: function() {
                    return a.specularMap.value
                },
                set: function(e) {
                    a.specularMap.value = e,
                    e ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP
                }
            },
            glossiness: {
                get: function() {
                    return a.glossiness.value
                },
                set: function(e) {
                    a.glossiness.value = e
                }
            },
            glossinessMap: {
                get: function() {
                    return a.glossinessMap.value
                },
                set: function(e) {
                    a.glossinessMap.value = e,
                    e ? (this.defines.USE_GLOSSINESSMAP = "",
                    this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP,
                    delete this.defines.USE_UV)
                }
            }
        }),
        delete this.metalness,
        delete this.roughness,
        delete this.metalnessMap,
        delete this.roughnessMap,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.specularMap = e.specularMap,
        this.specular.copy(e.specular),
        this.glossinessMap = e.glossinessMap,
        this.glossiness = e.glossiness,
        delete this.metalness,
        delete this.roughness,
        delete this.metalnessMap,
        delete this.roughnessMap,
        this
    }
}
class vp {
    constructor() {
        this.name = Jd.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,
        this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity"]
    }
    getMaterialType() {
        return gp
    }
    extendParams(e, t, n) {
        const i = t.extensions[this.name];
        e.color = new en(1,1,1),
        e.opacity = 1;
        const r = [];
        if (Array.isArray(i.diffuseFactor)) {
            const t = i.diffuseFactor;
            e.color.fromArray(t),
            e.opacity = t[3]
        }
        if (void 0 !== i.diffuseTexture && r.push(n.assignTexture(e, "map", i.diffuseTexture, gt)),
        e.emissive = new en(0,0,0),
        e.glossiness = void 0 !== i.glossinessFactor ? i.glossinessFactor : 1,
        e.specular = new en(1,1,1),
        Array.isArray(i.specularFactor) && e.specular.fromArray(i.specularFactor),
        void 0 !== i.specularGlossinessTexture) {
            const t = i.specularGlossinessTexture;
            r.push(n.assignTexture(e, "glossinessMap", t)),
            r.push(n.assignTexture(e, "specularMap", t, gt))
        }
        return Promise.all(r)
    }
    createMaterial(e) {
        const t = new gp(e);
        return t.fog = !0,
        t.color = e.color,
        t.map = void 0 === e.map ? null : e.map,
        t.lightMap = null,
        t.lightMapIntensity = 1,
        t.aoMap = void 0 === e.aoMap ? null : e.aoMap,
        t.aoMapIntensity = 1,
        t.emissive = e.emissive,
        t.emissiveIntensity = void 0 === e.emissiveIntensity ? 1 : e.emissiveIntensity,
        t.emissiveMap = void 0 === e.emissiveMap ? null : e.emissiveMap,
        t.bumpMap = void 0 === e.bumpMap ? null : e.bumpMap,
        t.bumpScale = 1,
        t.normalMap = void 0 === e.normalMap ? null : e.normalMap,
        t.normalMapType = 0,
        e.normalScale && (t.normalScale = e.normalScale),
        t.displacementMap = null,
        t.displacementScale = 1,
        t.displacementBias = 0,
        t.specularMap = void 0 === e.specularMap ? null : e.specularMap,
        t.specular = e.specular,
        t.glossinessMap = void 0 === e.glossinessMap ? null : e.glossinessMap,
        t.glossiness = e.glossiness,
        t.alphaMap = null,
        t.envMap = void 0 === e.envMap ? null : e.envMap,
        t.envMapIntensity = 1,
        t
    }
}
class xp {
    constructor() {
        this.name = Jd.KHR_MESH_QUANTIZATION
    }
}
class yp extends nh {
    constructor(e, t, n, i) {
        super(e, t, n, i)
    }
    copySampleValue_(e) {
        const t = this.resultBuffer
          , n = this.sampleValues
          , i = this.valueSize
          , r = e * i * 3 + i;
        for (let e = 0; e !== i; e++)
            t[e] = n[r + e];
        return t
    }
    interpolate_(e, t, n, i) {
        const r = this.resultBuffer
          , s = this.sampleValues
          , a = this.valueSize
          , o = 2 * a
          , l = 3 * a
          , c = i - t
          , h = (n - t) / c
          , u = h * h
          , d = u * h
          , p = e * l
          , m = p - l
          , f = -2 * d + 3 * u
          , g = d - u
          , v = 1 - f
          , x = g - u + h;
        for (let e = 0; e !== a; e++) {
            const t = s[m + e + a]
              , n = s[m + e + o] * c
              , i = s[p + e + a]
              , l = s[p + e] * c;
            r[e] = v * t + x * n + f * i + g * l
        }
        return r
    }
}
const _p = new dn;
class bp extends yp {
    interpolate_(e, t, n, i) {
        const r = super.interpolate_(e, t, n, i);
        return _p.fromArray(r).normalize().toArray(r),
        r
    }
}
const Mp = 0
  , wp = 1
  , Sp = 2
  , Tp = 3
  , Ap = 4
  , Ep = 5
  , Cp = 6
  , Lp = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
}
  , Rp = {
    9728: _e,
    9729: we,
    9984: be,
    9985: Se,
    9986: Me,
    9987: Te
}
  , Pp = {
    33071: xe,
    33648: ye,
    10497: ve
}
  , Ip = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
}
  , Dp = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv2",
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex"
}
  , Op = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences"
}
  , Np = {
    CUBICSPLINE: void 0,
    LINEAR: lt,
    STEP: ot
}
  , zp = "OPAQUE"
  , Up = "MASK"
  , Fp = "BLEND";
function Bp(e, t, n) {
    for (const i in n.extensions)
        void 0 === e[i] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {},
        t.userData.gltfExtensions[i] = n.extensions[i])
}
function kp(e, t) {
    void 0 !== t.extras && ("object" == typeof t.extras ? Object.assign(e.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras))
}
function Gp(e, t) {
    if (e.updateMorphTargets(),
    void 0 !== t.weights)
        for (let n = 0, i = t.weights.length; n < i; n++)
            e.morphTargetInfluences[n] = t.weights[n];
    if (t.extras && Array.isArray(t.extras.targetNames)) {
        const n = t.extras.targetNames;
        if (e.morphTargetInfluences.length === n.length) {
            e.morphTargetDictionary = {};
            for (let t = 0, i = n.length; t < i; t++)
                e.morphTargetDictionary[n[t]] = t
        } else
            console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
    }
}
function Hp(e) {
    const t = e.extensions && e.extensions[Jd.KHR_DRACO_MESH_COMPRESSION];
    let n;
    return n = t ? "draco:" + t.bufferView + ":" + t.indices + ":" + Vp(t.attributes) : e.indices + ":" + Vp(e.attributes) + ":" + e.mode,
    n
}
function Vp(e) {
    let t = "";
    const n = Object.keys(e).sort();
    for (let i = 0, r = n.length; i < r; i++)
        t += n[i] + ":" + e[n[i]] + ";";
    return t
}
function Wp(e) {
    switch (e) {
    case Int8Array:
        return 1 / 127;
    case Uint8Array:
        return 1 / 255;
    case Int16Array:
        return 1 / 32767;
    case Uint16Array:
        return 1 / 65535;
    default:
        throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
    }
}
class jp {
    constructor(e={}, t={}) {
        this.json = e,
        this.extensions = {},
        this.plugins = {},
        this.options = t,
        this.cache = new Zd,
        this.associations = new Map,
        this.primitiveCache = {},
        this.meshCache = {
            refs: {},
            uses: {}
        },
        this.cameraCache = {
            refs: {},
            uses: {}
        },
        this.lightCache = {
            refs: {},
            uses: {}
        },
        this.sourceCache = {},
        this.textureCache = {},
        this.nodeNamesUsed = {};
        const n = !0 === /^((?!chrome|android).)*safari/i.test(navigator.userAgent)
          , i = navigator.userAgent.indexOf("Firefox") > -1
          , r = i ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1;
        "undefined" == typeof createImageBitmap || n || i && r < 98 ? this.textureLoader = new Sh(this.options.manager) : this.textureLoader = new Kh(this.options.manager),
        this.textureLoader.setCrossOrigin(this.options.crossOrigin),
        this.textureLoader.setRequestHeader(this.options.requestHeader),
        this.fileLoader = new Mh(this.options.manager),
        this.fileLoader.setResponseType("arraybuffer"),
        "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
    }
    setExtensions(e) {
        this.extensions = e
    }
    setPlugins(e) {
        this.plugins = e
    }
    parse(e, t) {
        const n = this
          , i = this.json
          , r = this.extensions;
        this.cache.removeAll(),
        this._invokeAll((function(e) {
            return e._markDefs && e._markDefs()
        }
        )),
        Promise.all(this._invokeAll((function(e) {
            return e.beforeRoot && e.beforeRoot()
        }
        ))).then((function() {
            return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
        }
        )).then((function(t) {
            const s = {
                scene: t[0][i.scene || 0],
                scenes: t[0],
                animations: t[1],
                cameras: t[2],
                asset: i.asset,
                parser: n,
                userData: {}
            };
            Bp(r, s, i),
            kp(s, i),
            Promise.all(n._invokeAll((function(e) {
                return e.afterRoot && e.afterRoot(s)
            }
            ))).then((function() {
                e(s)
            }
            ))
        }
        )).catch(t)
    }
    _markDefs() {
        const e = this.json.nodes || []
          , t = this.json.skins || []
          , n = this.json.meshes || [];
        for (let n = 0, i = t.length; n < i; n++) {
            const i = t[n].joints;
            for (let t = 0, n = i.length; t < n; t++)
                e[i[t]].isBone = !0
        }
        for (let t = 0, i = e.length; t < i; t++) {
            const i = e[t];
            void 0 !== i.mesh && (this._addNodeRef(this.meshCache, i.mesh),
            void 0 !== i.skin && (n[i.mesh].isSkinnedMesh = !0)),
            void 0 !== i.camera && this._addNodeRef(this.cameraCache, i.camera)
        }
    }
    _addNodeRef(e, t) {
        void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0),
        e.refs[t]++)
    }
    _getNodeRef(e, t, n) {
        if (e.refs[t] <= 1)
            return n;
        const i = n.clone()
          , r = (e,t)=>{
            const n = this.associations.get(e);
            null != n && this.associations.set(t, n);
            for (const [n,i] of e.children.entries())
                r(i, t.children[n])
        }
        ;
        return r(n, i),
        i.name += "_instance_" + e.uses[t]++,
        i
    }
    _invokeOne(e) {
        const t = Object.values(this.plugins);
        t.push(this);
        for (let n = 0; n < t.length; n++) {
            const i = e(t[n]);
            if (i)
                return i
        }
        return null
    }
    _invokeAll(e) {
        const t = Object.values(this.plugins);
        t.unshift(this);
        const n = [];
        for (let i = 0; i < t.length; i++) {
            const r = e(t[i]);
            r && n.push(r)
        }
        return n
    }
    getDependency(e, t) {
        const n = e + ":" + t;
        let i = this.cache.get(n);
        if (!i) {
            switch (e) {
            case "scene":
                i = this.loadScene(t);
                break;
            case "node":
                i = this.loadNode(t);
                break;
            case "mesh":
                i = this._invokeOne((function(e) {
                    return e.loadMesh && e.loadMesh(t)
                }
                ));
                break;
            case "accessor":
                i = this.loadAccessor(t);
                break;
            case "bufferView":
                i = this._invokeOne((function(e) {
                    return e.loadBufferView && e.loadBufferView(t)
                }
                ));
                break;
            case "buffer":
                i = this.loadBuffer(t);
                break;
            case "material":
                i = this._invokeOne((function(e) {
                    return e.loadMaterial && e.loadMaterial(t)
                }
                ));
                break;
            case "texture":
                i = this._invokeOne((function(e) {
                    return e.loadTexture && e.loadTexture(t)
                }
                ));
                break;
            case "skin":
                i = this.loadSkin(t);
                break;
            case "animation":
                i = this._invokeOne((function(e) {
                    return e.loadAnimation && e.loadAnimation(t)
                }
                ));
                break;
            case "camera":
                i = this.loadCamera(t);
                break;
            default:
                throw new Error("Unknown type: " + e)
            }
            this.cache.add(n, i)
        }
        return i
    }
    getDependencies(e) {
        let t = this.cache.get(e);
        if (!t) {
            const n = this
              , i = this.json[e + ("mesh" === e ? "es" : "s")] || [];
            t = Promise.all(i.map((function(t, i) {
                return n.getDependency(e, i)
            }
            ))),
            this.cache.add(e, t)
        }
        return t
    }
    loadBuffer(e) {
        const t = this.json.buffers[e]
          , n = this.fileLoader;
        if (t.type && "arraybuffer" !== t.type)
            throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
        if (void 0 === t.uri && 0 === e)
            return Promise.resolve(this.extensions[Jd.KHR_BINARY_GLTF].body);
        const i = this.options;
        return new Promise((function(e, r) {
            n.load(jh.resolveURL(t.uri, i.path), e, void 0, (function() {
                r(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
            }
            ))
        }
        ))
    }
    loadBufferView(e) {
        const t = this.json.bufferViews[e];
        return this.getDependency("buffer", t.buffer).then((function(e) {
            const n = t.byteLength || 0
              , i = t.byteOffset || 0;
            return e.slice(i, i + n)
        }
        ))
    }
    loadAccessor(e) {
        const t = this
          , n = this.json
          , i = this.json.accessors[e];
        if (void 0 === i.bufferView && void 0 === i.sparse)
            return Promise.resolve(null);
        const r = [];
        return void 0 !== i.bufferView ? r.push(this.getDependency("bufferView", i.bufferView)) : r.push(null),
        void 0 !== i.sparse && (r.push(this.getDependency("bufferView", i.sparse.indices.bufferView)),
        r.push(this.getDependency("bufferView", i.sparse.values.bufferView))),
        Promise.all(r).then((function(e) {
            const r = e[0]
              , s = Ip[i.type]
              , a = Lp[i.componentType]
              , o = a.BYTES_PER_ELEMENT
              , l = o * s
              , c = i.byteOffset || 0
              , h = void 0 !== i.bufferView ? n.bufferViews[i.bufferView].byteStride : void 0
              , u = !0 === i.normalized;
            let d, p;
            if (h && h !== l) {
                const e = Math.floor(c / h)
                  , n = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + e + ":" + i.count;
                let l = t.cache.get(n);
                l || (d = new a(r,e * h,i.count * h / o),
                l = new co(d,h / o),
                t.cache.add(n, l)),
                p = new uo(l,s,c % h / o,u)
            } else
                d = null === r ? new a(i.count * s) : new a(r,c,i.count * s),
                p = new Ii(d,s,u);
            if (void 0 !== i.sparse) {
                const t = Ip.SCALAR
                  , n = Lp[i.sparse.indices.componentType]
                  , o = i.sparse.indices.byteOffset || 0
                  , l = i.sparse.values.byteOffset || 0
                  , c = new n(e[1],o,i.sparse.count * t)
                  , h = new a(e[2],l,i.sparse.count * s);
                null !== r && (p = new Ii(p.array.slice(),p.itemSize,p.normalized));
                for (let e = 0, t = c.length; e < t; e++) {
                    const t = c[e];
                    if (p.setX(t, h[e * s]),
                    s >= 2 && p.setY(t, h[e * s + 1]),
                    s >= 3 && p.setZ(t, h[e * s + 2]),
                    s >= 4 && p.setW(t, h[e * s + 3]),
                    s >= 5)
                        throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                }
            }
            return p
        }
        ))
    }
    loadTexture(e) {
        const t = this.json
          , n = this.options
          , i = t.textures[e].source
          , r = t.images[i];
        let s = this.textureLoader;
        if (r.uri) {
            const e = n.manager.getHandler(r.uri);
            null !== e && (s = e)
        }
        return this.loadTextureImage(e, i, s)
    }
    loadTextureImage(e, t, n) {
        const i = this
          , r = this.json
          , s = r.textures[e]
          , a = r.images[t]
          , o = (a.uri || a.bufferView) + ":" + s.sampler;
        if (this.textureCache[o])
            return this.textureCache[o];
        const l = this.loadImageSource(t, n).then((function(t) {
            t.flipY = !1,
            s.name && (t.name = s.name);
            const n = (r.samplers || {})[s.sampler] || {};
            return t.magFilter = Rp[n.magFilter] || we,
            t.minFilter = Rp[n.minFilter] || Te,
            t.wrapS = Pp[n.wrapS] || ve,
            t.wrapT = Pp[n.wrapT] || ve,
            i.associations.set(t, {
                textures: e
            }),
            t
        }
        )).catch((function() {
            return null
        }
        ));
        return this.textureCache[o] = l,
        l
    }
    loadImageSource(e, t) {
        const n = this
          , i = this.json
          , r = this.options;
        if (void 0 !== this.sourceCache[e])
            return this.sourceCache[e].then((e=>e.clone()));
        const s = i.images[e]
          , a = self.URL || self.webkitURL;
        let o = s.uri || ""
          , l = !1;
        if (void 0 !== s.bufferView)
            o = n.getDependency("bufferView", s.bufferView).then((function(e) {
                l = !0;
                const t = new Blob([e],{
                    type: s.mimeType
                });
                return o = a.createObjectURL(t),
                o
            }
            ));
        else if (void 0 === s.uri)
            throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
        const c = Promise.resolve(o).then((function(e) {
            return new Promise((function(n, i) {
                let s = n;
                !0 === t.isImageBitmapLoader && (s = function(e) {
                    const t = new on(e);
                    t.needsUpdate = !0,
                    n(t)
                }
                ),
                t.load(jh.resolveURL(e, r.path), s, void 0, i)
            }
            ))
        }
        )).then((function(e) {
            var t;
            return !0 === l && a.revokeObjectURL(o),
            e.userData.mimeType = s.mimeType || ((t = s.uri).search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/) ? "image/jpeg" : t.search(/\.webp($|\?)/i) > 0 || 0 === t.search(/^data\:image\/webp/) ? "image/webp" : "image/png"),
            e
        }
        )).catch((function(e) {
            throw console.error("THREE.GLTFLoader: Couldn't load texture", o),
            e
        }
        ));
        return this.sourceCache[e] = c,
        c
    }
    assignTexture(e, t, n, i) {
        const r = this;
        return this.getDependency("texture", n.index).then((function(s) {
            if (void 0 === n.texCoord || 0 == n.texCoord || "aoMap" === t && 1 == n.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + n.texCoord + " for texture " + t + " not yet supported."),
            r.extensions[Jd.KHR_TEXTURE_TRANSFORM]) {
                const e = void 0 !== n.extensions ? n.extensions[Jd.KHR_TEXTURE_TRANSFORM] : void 0;
                if (e) {
                    const t = r.associations.get(s);
                    s = r.extensions[Jd.KHR_TEXTURE_TRANSFORM].extendTexture(s, e),
                    r.associations.set(s, t)
                }
            }
            return void 0 !== i && (s.encoding = i),
            e[t] = s,
            s
        }
        ))
    }
    assignFinalMaterial(e) {
        const t = e.geometry;
        let n = e.material;
        const i = void 0 === t.attributes.tangent
          , r = void 0 !== t.attributes.color
          , s = void 0 === t.attributes.normal;
        if (e.isPoints) {
            const e = "PointsMaterial:" + n.uuid;
            let t = this.cache.get(e);
            t || (t = new al,
            Ci.prototype.copy.call(t, n),
            t.color.copy(n.color),
            t.map = n.map,
            t.sizeAttenuation = !1,
            this.cache.add(e, t)),
            n = t
        } else if (e.isLine) {
            const e = "LineBasicMaterial:" + n.uuid;
            let t = this.cache.get(e);
            t || (t = new Zo,
            Ci.prototype.copy.call(t, n),
            t.color.copy(n.color),
            this.cache.add(e, t)),
            n = t
        }
        if (i || r || s) {
            let e = "ClonedMaterial:" + n.uuid + ":";
            n.isGLTFSpecularGlossinessMaterial && (e += "specular-glossiness:"),
            i && (e += "derivative-tangents:"),
            r && (e += "vertex-colors:"),
            s && (e += "flat-shading:");
            let t = this.cache.get(e);
            t || (t = n.clone(),
            r && (t.vertexColors = !0),
            s && (t.flatShading = !0),
            i && (t.normalScale && (t.normalScale.y *= -1),
            t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)),
            this.cache.add(e, t),
            this.associations.set(t, this.associations.get(n))),
            n = t
        }
        n.aoMap && void 0 === t.attributes.uv2 && void 0 !== t.attributes.uv && t.setAttribute("uv2", t.attributes.uv),
        e.material = n
    }
    getMaterialType() {
        return Gc
    }
    loadMaterial(e) {
        const t = this
          , n = this.json
          , i = this.extensions
          , r = n.materials[e];
        let s;
        const a = {}
          , o = r.extensions || {}
          , l = [];
        if (o[Jd.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
            const e = i[Jd.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
            s = e.getMaterialType(),
            l.push(e.extendParams(a, r, t))
        } else if (o[Jd.KHR_MATERIALS_UNLIT]) {
            const e = i[Jd.KHR_MATERIALS_UNLIT];
            s = e.getMaterialType(),
            l.push(e.extendParams(a, r, t))
        } else {
            const n = r.pbrMetallicRoughness || {};
            if (a.color = new en(1,1,1),
            a.opacity = 1,
            Array.isArray(n.baseColorFactor)) {
                const e = n.baseColorFactor;
                a.color.fromArray(e),
                a.opacity = e[3]
            }
            void 0 !== n.baseColorTexture && l.push(t.assignTexture(a, "map", n.baseColorTexture, gt)),
            a.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1,
            a.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1,
            void 0 !== n.metallicRoughnessTexture && (l.push(t.assignTexture(a, "metalnessMap", n.metallicRoughnessTexture)),
            l.push(t.assignTexture(a, "roughnessMap", n.metallicRoughnessTexture))),
            s = this._invokeOne((function(t) {
                return t.getMaterialType && t.getMaterialType(e)
            }
            )),
            l.push(Promise.all(this._invokeAll((function(t) {
                return t.extendMaterialParams && t.extendMaterialParams(e, a)
            }
            ))))
        }
        !0 === r.doubleSided && (a.side = ae);
        const c = r.alphaMode || zp;
        if (c === Fp ? (a.transparent = !0,
        a.depthWrite = !1) : (a.transparent = !1,
        c === Up && (a.alphaTest = void 0 !== r.alphaCutoff ? r.alphaCutoff : .5)),
        void 0 !== r.normalTexture && s !== Li && (l.push(t.assignTexture(a, "normalMap", r.normalTexture)),
        a.normalScale = new Ft(1,1),
        void 0 !== r.normalTexture.scale)) {
            const e = r.normalTexture.scale;
            a.normalScale.set(e, e)
        }
        return void 0 !== r.occlusionTexture && s !== Li && (l.push(t.assignTexture(a, "aoMap", r.occlusionTexture)),
        void 0 !== r.occlusionTexture.strength && (a.aoMapIntensity = r.occlusionTexture.strength)),
        void 0 !== r.emissiveFactor && s !== Li && (a.emissive = (new en).fromArray(r.emissiveFactor)),
        void 0 !== r.emissiveTexture && s !== Li && l.push(t.assignTexture(a, "emissiveMap", r.emissiveTexture, gt)),
        Promise.all(l).then((function() {
            let n;
            return n = s === gp ? i[Jd.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a) : new s(a),
            r.name && (n.name = r.name),
            kp(n, r),
            t.associations.set(n, {
                materials: e
            }),
            r.extensions && Bp(i, n, r),
            n
        }
        ))
    }
    createUniqueName(e) {
        const t = wu.sanitizeNodeName(e || "");
        let n = t;
        for (let e = 1; this.nodeNamesUsed[n]; ++e)
            n = t + "_" + e;
        return this.nodeNamesUsed[n] = !0,
        n
    }
    loadGeometries(e) {
        const t = this
          , n = this.extensions
          , i = this.primitiveCache;
        function r(e) {
            return n[Jd.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then((function(n) {
                return qp(n, e, t)
            }
            ))
        }
        const s = [];
        for (let n = 0, a = e.length; n < a; n++) {
            const a = e[n]
              , o = Hp(a)
              , l = i[o];
            if (l)
                s.push(l.promise);
            else {
                let e;
                e = a.extensions && a.extensions[Jd.KHR_DRACO_MESH_COMPRESSION] ? r(a) : qp(new Vi, a, t),
                i[o] = {
                    primitive: a,
                    promise: e
                },
                s.push(e)
            }
        }
        return Promise.all(s)
    }
    loadMesh(e) {
        const t = this
          , n = this.json
          , i = this.extensions
          , r = n.meshes[e]
          , s = r.primitives
          , a = [];
        for (let e = 0, t = s.length; e < t; e++) {
            const t = void 0 === s[e].material ? (void 0 === (o = this.cache).DefaultMaterial && (o.DefaultMaterial = new Gc({
                color: 16777215,
                emissive: 0,
                metalness: 1,
                roughness: 1,
                transparent: !1,
                depthTest: !0,
                side: 0
            })),
            o.DefaultMaterial) : this.getDependency("material", s[e].material);
            a.push(t)
        }
        var o;
        return a.push(t.loadGeometries(s)),
        Promise.all(a).then((function(n) {
            const a = n.slice(0, n.length - 1)
              , o = n[n.length - 1]
              , l = [];
            for (let n = 0, c = o.length; n < c; n++) {
                const c = o[n]
                  , h = s[n];
                let u;
                const d = a[n];
                if (h.mode === Ap || h.mode === Ep || h.mode === Cp || void 0 === h.mode)
                    u = !0 === r.isSkinnedMesh ? new Uo(c,d) : new or(c,d),
                    !0 !== u.isSkinnedMesh || u.geometry.attributes.skinWeight.normalized || u.normalizeSkinWeights(),
                    h.mode === Ep ? u.geometry = Yp(u.geometry, 1) : h.mode === Cp && (u.geometry = Yp(u.geometry, 2));
                else if (h.mode === wp)
                    u = new rl(c,d);
                else if (h.mode === Tp)
                    u = new tl(c,d);
                else if (h.mode === Sp)
                    u = new sl(c,d);
                else {
                    if (h.mode !== Mp)
                        throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + h.mode);
                    u = new ul(c,d)
                }
                Object.keys(u.geometry.morphAttributes).length > 0 && Gp(u, r),
                u.name = t.createUniqueName(r.name || "mesh_" + e),
                kp(u, r),
                h.extensions && Bp(i, u, h),
                t.assignFinalMaterial(u),
                l.push(u)
            }
            for (let n = 0, i = l.length; n < i; n++)
                t.associations.set(l[n], {
                    meshes: e,
                    primitives: n
                });
            if (1 === l.length)
                return l[0];
            const c = new Ka;
            t.associations.set(c, {
                meshes: e
            });
            for (let e = 0, t = l.length; e < t; e++)
                c.add(l[e]);
            return c
        }
        ))
    }
    loadCamera(e) {
        let t;
        const n = this.json.cameras[e]
          , i = n[n.type];
        if (i)
            return "perspective" === n.type ? t = new fr(Ut.radToDeg(i.yfov),i.aspectRatio || 1,i.znear || 1,i.zfar || 2e6) : "orthographic" === n.type && (t = new Br(-i.xmag,i.xmag,i.ymag,-i.ymag,i.znear,i.zfar)),
            n.name && (t.name = this.createUniqueName(n.name)),
            kp(t, n),
            Promise.resolve(t);
        console.warn("THREE.GLTFLoader: Missing camera parameters.")
    }
    loadSkin(e) {
        const t = this.json.skins[e]
          , n = {
            joints: t.joints
        };
        return void 0 === t.inverseBindMatrices ? Promise.resolve(n) : this.getDependency("accessor", t.inverseBindMatrices).then((function(e) {
            return n.inverseBindMatrices = e,
            n
        }
        ))
    }
    loadAnimation(e) {
        const t = this.json.animations[e]
          , n = []
          , i = []
          , r = []
          , s = []
          , a = [];
        for (let e = 0, o = t.channels.length; e < o; e++) {
            const o = t.channels[e]
              , l = t.samplers[o.sampler]
              , c = o.target
              , h = c.node
              , u = void 0 !== t.parameters ? t.parameters[l.input] : l.input
              , d = void 0 !== t.parameters ? t.parameters[l.output] : l.output;
            n.push(this.getDependency("node", h)),
            i.push(this.getDependency("accessor", u)),
            r.push(this.getDependency("accessor", d)),
            s.push(l),
            a.push(c)
        }
        return Promise.all([Promise.all(n), Promise.all(i), Promise.all(r), Promise.all(s), Promise.all(a)]).then((function(n) {
            const i = n[0]
              , r = n[1]
              , s = n[2]
              , a = n[3]
              , o = n[4]
              , l = [];
            for (let e = 0, t = i.length; e < t; e++) {
                const t = i[e]
                  , n = r[e]
                  , c = s[e]
                  , h = a[e]
                  , u = o[e];
                if (void 0 === t)
                    continue;
                let d;
                switch (t.updateMatrix(),
                Op[u.path]) {
                case Op.weights:
                    d = ch;
                    break;
                case Op.rotation:
                    d = uh;
                    break;
                default:
                    d = ph
                }
                const p = t.name ? t.name : t.uuid
                  , m = void 0 !== h.interpolation ? Np[h.interpolation] : lt
                  , f = [];
                Op[u.path] === Op.weights ? t.traverse((function(e) {
                    e.morphTargetInfluences && f.push(e.name ? e.name : e.uuid)
                }
                )) : f.push(p);
                let g = c.array;
                if (c.normalized) {
                    const e = Wp(g.constructor)
                      , t = new Float32Array(g.length);
                    for (let n = 0, i = g.length; n < i; n++)
                        t[n] = g[n] * e;
                    g = t
                }
                for (let e = 0, t = f.length; e < t; e++) {
                    const t = new d(f[e] + "." + Op[u.path],n.array,g,m);
                    "CUBICSPLINE" === h.interpolation && (t.createInterpolant = function(e) {
                        return new (this instanceof uh ? bp : yp)(this.times,this.values,this.getValueSize() / 3,e)
                    }
                    ,
                    t.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0),
                    l.push(t)
                }
            }
            const c = t.name ? t.name : "animation_" + e;
            return new mh(c,void 0,l)
        }
        ))
    }
    createNodeMesh(e) {
        const t = this.json
          , n = this
          , i = t.nodes[e];
        return void 0 === i.mesh ? null : n.getDependency("mesh", i.mesh).then((function(e) {
            const t = n._getNodeRef(n.meshCache, i.mesh, e);
            return void 0 !== i.weights && t.traverse((function(e) {
                if (e.isMesh)
                    for (let t = 0, n = i.weights.length; t < n; t++)
                        e.morphTargetInfluences[t] = i.weights[t]
            }
            )),
            t
        }
        ))
    }
    loadNode(e) {
        const t = this.json
          , n = this.extensions
          , i = this
          , r = t.nodes[e]
          , s = r.name ? i.createUniqueName(r.name) : "";
        return function() {
            const t = []
              , n = i._invokeOne((function(t) {
                return t.createNodeMesh && t.createNodeMesh(e)
            }
            ));
            return n && t.push(n),
            void 0 !== r.camera && t.push(i.getDependency("camera", r.camera).then((function(e) {
                return i._getNodeRef(i.cameraCache, r.camera, e)
            }
            ))),
            i._invokeAll((function(t) {
                return t.createNodeAttachment && t.createNodeAttachment(e)
            }
            )).forEach((function(e) {
                t.push(e)
            }
            )),
            Promise.all(t)
        }().then((function(t) {
            let a;
            if (a = !0 === r.isBone ? new Fo : t.length > 1 ? new Ka : 1 === t.length ? t[0] : new fi,
            a !== t[0])
                for (let e = 0, n = t.length; e < n; e++)
                    a.add(t[e]);
            if (r.name && (a.userData.name = r.name,
            a.name = s),
            kp(a, r),
            r.extensions && Bp(n, a, r),
            void 0 !== r.matrix) {
                const e = new Wn;
                e.fromArray(r.matrix),
                a.applyMatrix4(e)
            } else
                void 0 !== r.translation && a.position.fromArray(r.translation),
                void 0 !== r.rotation && a.quaternion.fromArray(r.rotation),
                void 0 !== r.scale && a.scale.fromArray(r.scale);
            return i.associations.has(a) || i.associations.set(a, {}),
            i.associations.get(a).nodes = e,
            a
        }
        ))
    }
    loadScene(e) {
        const t = this.json
          , n = this.extensions
          , i = this.json.scenes[e]
          , r = this
          , s = new Ka;
        i.name && (s.name = r.createUniqueName(i.name)),
        kp(s, i),
        i.extensions && Bp(n, s, i);
        const a = i.nodes || []
          , o = [];
        for (let e = 0, n = a.length; e < n; e++)
            o.push(Xp(a[e], s, t, r));
        return Promise.all(o).then((function() {
            return r.associations = (e=>{
                const t = new Map;
                for (const [e,n] of r.associations)
                    (e instanceof Ci || e instanceof on) && t.set(e, n);
                return e.traverse((e=>{
                    const n = r.associations.get(e);
                    null != n && t.set(e, n)
                }
                )),
                t
            }
            )(s),
            s
        }
        ))
    }
}
function Xp(e, t, n, i) {
    const r = n.nodes[e];
    return i.getDependency("node", e).then((function(e) {
        if (void 0 === r.skin)
            return e;
        let t;
        return i.getDependency("skin", r.skin).then((function(e) {
            t = e;
            const n = [];
            for (let e = 0, r = t.joints.length; e < r; e++)
                n.push(i.getDependency("node", t.joints[e]));
            return Promise.all(n)
        }
        )).then((function(n) {
            return e.traverse((function(e) {
                if (!e.isMesh)
                    return;
                const i = []
                  , r = [];
                for (let e = 0, s = n.length; e < s; e++) {
                    const s = n[e];
                    if (s) {
                        i.push(s);
                        const n = new Wn;
                        void 0 !== t.inverseBindMatrices && n.fromArray(t.inverseBindMatrices.array, 16 * e),
                        r.push(n)
                    } else
                        console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[e])
                }
                e.bind(new Ho(i,r), e.matrixWorld)
            }
            )),
            e
        }
        ))
    }
    )).then((function(e) {
        t.add(e);
        const s = [];
        if (r.children) {
            const t = r.children;
            for (let r = 0, a = t.length; r < a; r++) {
                const a = t[r];
                s.push(Xp(a, e, n, i))
            }
        }
        return Promise.all(s)
    }
    ))
}
function qp(e, t, n) {
    const i = t.attributes
      , r = [];
    function s(t, i) {
        return n.getDependency("accessor", t).then((function(t) {
            e.setAttribute(i, t)
        }
        ))
    }
    for (const t in i) {
        const n = Dp[t] || t.toLowerCase();
        n in e.attributes || r.push(s(i[t], n))
    }
    if (void 0 !== t.indices && !e.index) {
        const i = n.getDependency("accessor", t.indices).then((function(t) {
            e.setIndex(t)
        }
        ));
        r.push(i)
    }
    return kp(e, t),
    function(e, t, n) {
        const i = t.attributes
          , r = new gn;
        if (void 0 === i.POSITION)
            return;
        {
            const e = n.json.accessors[i.POSITION]
              , t = e.min
              , s = e.max;
            if (void 0 === t || void 0 === s)
                return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
            if (r.set(new pn(t[0],t[1],t[2]), new pn(s[0],s[1],s[2])),
            e.normalized) {
                const t = Wp(Lp[e.componentType]);
                r.min.multiplyScalar(t),
                r.max.multiplyScalar(t)
            }
        }
        const s = t.targets;
        if (void 0 !== s) {
            const e = new pn
              , t = new pn;
            for (let i = 0, r = s.length; i < r; i++) {
                const r = s[i];
                if (void 0 !== r.POSITION) {
                    const i = n.json.accessors[r.POSITION]
                      , s = i.min
                      , a = i.max;
                    if (void 0 !== s && void 0 !== a) {
                        if (t.setX(Math.max(Math.abs(s[0]), Math.abs(a[0]))),
                        t.setY(Math.max(Math.abs(s[1]), Math.abs(a[1]))),
                        t.setZ(Math.max(Math.abs(s[2]), Math.abs(a[2]))),
                        i.normalized) {
                            const e = Wp(Lp[i.componentType]);
                            t.multiplyScalar(e)
                        }
                        e.max(t)
                    } else
                        console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                }
            }
            r.expandByVector(e)
        }
        e.boundingBox = r;
        const a = new Nn;
        r.getCenter(a.center),
        a.radius = r.min.distanceTo(r.max) / 2,
        e.boundingSphere = a
    }(e, t, n),
    Promise.all(r).then((function() {
        return void 0 !== t.targets ? function(e, t, n) {
            let i = !1
              , r = !1
              , s = !1;
            for (let e = 0, n = t.length; e < n; e++) {
                const n = t[e];
                if (void 0 !== n.POSITION && (i = !0),
                void 0 !== n.NORMAL && (r = !0),
                void 0 !== n.COLOR_0 && (s = !0),
                i && r && s)
                    break
            }
            if (!i && !r && !s)
                return Promise.resolve(e);
            const a = []
              , o = []
              , l = [];
            for (let c = 0, h = t.length; c < h; c++) {
                const h = t[c];
                if (i) {
                    const t = void 0 !== h.POSITION ? n.getDependency("accessor", h.POSITION) : e.attributes.position;
                    a.push(t)
                }
                if (r) {
                    const t = void 0 !== h.NORMAL ? n.getDependency("accessor", h.NORMAL) : e.attributes.normal;
                    o.push(t)
                }
                if (s) {
                    const t = void 0 !== h.COLOR_0 ? n.getDependency("accessor", h.COLOR_0) : e.attributes.color;
                    l.push(t)
                }
            }
            return Promise.all([Promise.all(a), Promise.all(o), Promise.all(l)]).then((function(t) {
                const n = t[0]
                  , a = t[1]
                  , o = t[2];
                return i && (e.morphAttributes.position = n),
                r && (e.morphAttributes.normal = a),
                s && (e.morphAttributes.color = o),
                e.morphTargetsRelative = !0,
                e
            }
            ))
        }(e, t.targets, n) : e
    }
    ))
}
function Yp(e, t) {
    let n = e.getIndex();
    if (null === n) {
        const t = []
          , i = e.getAttribute("position");
        if (void 0 === i)
            return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),
            e;
        for (let e = 0; e < i.count; e++)
            t.push(e);
        e.setIndex(t),
        n = e.getIndex()
    }
    const i = n.count - 2
      , r = [];
    if (2 === t)
        for (let e = 1; e <= i; e++)
            r.push(n.getX(0)),
            r.push(n.getX(e)),
            r.push(n.getX(e + 1));
    else
        for (let e = 0; e < i; e++)
            e % 2 == 0 ? (r.push(n.getX(e)),
            r.push(n.getX(e + 1)),
            r.push(n.getX(e + 2))) : (r.push(n.getX(e + 2)),
            r.push(n.getX(e + 1)),
            r.push(n.getX(e)));
    r.length / 3 !== i && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    const s = e.clone();
    return s.setIndex(r),
    s
}
const Zp = new en;
class Jp extends yh {
    constructor(e) {
        super(e),
        this.propertyNameMapping = {}
    }
    load(e, t, n, i) {
        const r = this
          , s = new Mh(this.manager);
        s.setPath(this.path),
        s.setResponseType("arraybuffer"),
        s.setRequestHeader(this.requestHeader),
        s.setWithCredentials(this.withCredentials),
        s.load(e, (function(n) {
            try {
                t(r.parse(n))
            } catch (t) {
                i ? i(t) : console.error(t),
                r.manager.itemError(e)
            }
        }
        ), n, i)
    }
    setPropertyNameMapping(e) {
        this.propertyNameMapping = e
    }
    parse(e) {
        function t(e) {
            let t = ""
              , n = 0;
            const i = /^ply([\s\S]*)end_header(\r\n|\r|\n)/.exec(e);
            null !== i && (t = i[1],
            n = new Blob([i[0]]).size);
            const r = {
                comments: [],
                elements: [],
                headerLength: n,
                objInfo: ""
            }
              , s = t.split(/\r\n|\r|\n/);
            let a;
            function o(e, t) {
                const n = {
                    type: e[0]
                };
                return "list" === n.type ? (n.name = e[3],
                n.countType = e[1],
                n.itemType = e[2]) : n.name = e[1],
                n.name in t && (n.name = t[n.name]),
                n
            }
            for (let e = 0; e < s.length; e++) {
                let t = s[e];
                if (t = t.trim(),
                "" === t)
                    continue;
                const n = t.split(/\s+/)
                  , i = n.shift();
                switch (t = n.join(" "),
                i) {
                case "format":
                    r.format = n[0],
                    r.version = n[1];
                    break;
                case "comment":
                    r.comments.push(t);
                    break;
                case "element":
                    void 0 !== a && r.elements.push(a),
                    a = {},
                    a.name = n[0],
                    a.count = parseInt(n[1]),
                    a.properties = [];
                    break;
                case "property":
                    a.properties.push(o(n, h.propertyNameMapping));
                    break;
                case "obj_info":
                    r.objInfo = t;
                    break;
                default:
                    console.log("unhandled", i, n)
                }
            }
            return void 0 !== a && r.elements.push(a),
            r
        }
        function n(e, t) {
            switch (t) {
            case "char":
            case "uchar":
            case "short":
            case "ushort":
            case "int":
            case "uint":
            case "int8":
            case "uint8":
            case "int16":
            case "uint16":
            case "int32":
            case "uint32":
                return parseInt(e);
            case "float":
            case "double":
            case "float32":
            case "float64":
                return parseFloat(e)
            }
        }
        function i(e, t) {
            const i = t.split(/\s+/)
              , r = {};
            for (let t = 0; t < e.length; t++)
                if ("list" === e[t].type) {
                    const s = []
                      , a = n(i.shift(), e[t].countType);
                    for (let r = 0; r < a; r++)
                        s.push(n(i.shift(), e[t].itemType));
                    r[e[t].name] = s
                } else
                    r[e[t].name] = n(i.shift(), e[t].type);
            return r
        }
        function r(e, t) {
            const n = {
                indices: [],
                vertices: [],
                normals: [],
                uvs: [],
                faceVertexUvs: [],
                colors: []
            };
            let r;
            let o = "";
            null !== (r = /end_header\s([\s\S]*)$/.exec(e)) && (o = r[1]);
            const l = o.split(/\r\n|\r|\n/);
            let c = 0
              , h = 0;
            for (let e = 0; e < l.length; e++) {
                let r = l[e];
                if (r = r.trim(),
                "" === r)
                    continue;
                h >= t.elements[c].count && (c++,
                h = 0);
                const s = i(t.elements[c].properties, r);
                a(n, t.elements[c].name, s),
                h++
            }
            return s(n)
        }
        function s(e) {
            let t = new Vi;
            return e.indices.length > 0 && t.setIndex(e.indices),
            t.setAttribute("position", new Ni(e.vertices,3)),
            e.normals.length > 0 && t.setAttribute("normal", new Ni(e.normals,3)),
            e.uvs.length > 0 && t.setAttribute("uv", new Ni(e.uvs,2)),
            e.colors.length > 0 && t.setAttribute("color", new Ni(e.colors,3)),
            e.faceVertexUvs.length > 0 && (t = t.toNonIndexed(),
            t.setAttribute("uv", new Ni(e.faceVertexUvs,2))),
            t.computeBoundingSphere(),
            t
        }
        function a(e, t, n) {
            function i(e) {
                for (let t = 0, i = e.length; t < i; t++) {
                    const i = e[t];
                    if (i in n)
                        return i
                }
                return null
            }
            const r = i(["x", "px", "posx"]) || "x"
              , s = i(["y", "py", "posy"]) || "y"
              , a = i(["z", "pz", "posz"]) || "z"
              , o = i(["nx", "normalx"])
              , l = i(["ny", "normaly"])
              , c = i(["nz", "normalz"])
              , h = i(["s", "u", "texture_u", "tx"])
              , u = i(["t", "v", "texture_v", "ty"])
              , d = i(["red", "diffuse_red", "r", "diffuse_r"])
              , p = i(["green", "diffuse_green", "g", "diffuse_g"])
              , m = i(["blue", "diffuse_blue", "b", "diffuse_b"]);
            if ("vertex" === t)
                e.vertices.push(n[r], n[s], n[a]),
                null !== o && null !== l && null !== c && e.normals.push(n[o], n[l], n[c]),
                null !== h && null !== u && e.uvs.push(n[h], n[u]),
                null !== d && null !== p && null !== m && (Zp.setRGB(n[d] / 255, n[p] / 255, n[m] / 255).convertSRGBToLinear(),
                e.colors.push(Zp.r, Zp.g, Zp.b));
            else if ("face" === t) {
                const t = n.vertex_indices || n.vertex_index
                  , i = n.texcoord;
                3 === t.length ? (e.indices.push(t[0], t[1], t[2]),
                i && 6 === i.length && (e.faceVertexUvs.push(i[0], i[1]),
                e.faceVertexUvs.push(i[2], i[3]),
                e.faceVertexUvs.push(i[4], i[5]))) : 4 === t.length && (e.indices.push(t[0], t[1], t[3]),
                e.indices.push(t[1], t[2], t[3]))
            }
        }
        function o(e, t, n, i) {
            switch (n) {
            case "int8":
            case "char":
                return [e.getInt8(t), 1];
            case "uint8":
            case "uchar":
                return [e.getUint8(t), 1];
            case "int16":
            case "short":
                return [e.getInt16(t, i), 2];
            case "uint16":
            case "ushort":
                return [e.getUint16(t, i), 2];
            case "int32":
            case "int":
                return [e.getInt32(t, i), 4];
            case "uint32":
            case "uint":
                return [e.getUint32(t, i), 4];
            case "float32":
            case "float":
                return [e.getFloat32(t, i), 4];
            case "float64":
            case "double":
                return [e.getFloat64(t, i), 8]
            }
        }
        function l(e, t, n, i) {
            const r = {};
            let s, a = 0;
            for (let l = 0; l < n.length; l++)
                if ("list" === n[l].type) {
                    const c = [];
                    s = o(e, t + a, n[l].countType, i);
                    const h = s[0];
                    a += s[1];
                    for (let r = 0; r < h; r++)
                        s = o(e, t + a, n[l].itemType, i),
                        c.push(s[0]),
                        a += s[1];
                    r[n[l].name] = c
                } else
                    s = o(e, t + a, n[l].type, i),
                    r[n[l].name] = s[0],
                    a += s[1];
            return [r, a]
        }
        let c;
        const h = this;
        if (e instanceof ArrayBuffer) {
            const n = jh.decodeText(new Uint8Array(e))
              , i = t(n);
            c = "ascii" === i.format ? r(n, i) : function(e, t) {
                const n = {
                    indices: [],
                    vertices: [],
                    normals: [],
                    uvs: [],
                    faceVertexUvs: [],
                    colors: []
                }
                  , i = "binary_little_endian" === t.format
                  , r = new DataView(e,t.headerLength);
                let o, c = 0;
                for (let e = 0; e < t.elements.length; e++)
                    for (let s = 0; s < t.elements[e].count; s++) {
                        o = l(r, c, t.elements[e].properties, i),
                        c += o[1];
                        const s = o[0];
                        a(n, t.elements[e].name, s)
                    }
                return s(n)
            }(e, i)
        } else
            c = r(e, t(e));
        return c
    }
}
class Kp extends yh {
    constructor(e) {
        super(e)
    }
    load(e, t, n, i) {
        const r = this
          , s = new Mh(this.manager);
        s.setPath(this.path),
        s.setRequestHeader(this.requestHeader),
        s.setWithCredentials(this.withCredentials),
        s.load(e, (function(e) {
            const n = r.parse(JSON.parse(e));
            t && t(n)
        }
        ), n, i)
    }
    parse(e) {
        return new Qp(e)
    }
}
class Qp {
    constructor(e) {
        this.isFont = !0,
        this.type = "Font",
        this.data = e
    }
    generateShapes(e, t=100) {
        const n = []
          , i = function(e, t, n) {
            const i = Array.from(e)
              , r = t / n.resolution
              , s = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * r
              , a = [];
            let o = 0
              , l = 0;
            for (let e = 0; e < i.length; e++) {
                const t = i[e];
                if ("\n" === t)
                    o = 0,
                    l -= s;
                else {
                    const e = $p(t, r, o, l, n);
                    o += e.offsetX,
                    a.push(e.path)
                }
            }
            return a
        }(e, t, this.data);
        for (let e = 0, t = i.length; e < t; e++)
            n.push(...i[e].toShapes());
        return n
    }
}
function $p(e, t, n, i, r) {
    const s = r.glyphs[e] || r.glyphs["?"];
    if (!s)
        return void console.error('THREE.Font: character "' + e + '" does not exists in font family ' + r.familyName + ".");
    const a = new td;
    let o, l, c, h, u, d, p, m;
    if (s.o) {
        const e = s._cachedOutline || (s._cachedOutline = s.o.split(" "));
        for (let r = 0, s = e.length; r < s; ) {
            switch (e[r++]) {
            case "m":
                o = e[r++] * t + n,
                l = e[r++] * t + i,
                a.moveTo(o, l);
                break;
            case "l":
                o = e[r++] * t + n,
                l = e[r++] * t + i,
                a.lineTo(o, l);
                break;
            case "q":
                c = e[r++] * t + n,
                h = e[r++] * t + i,
                u = e[r++] * t + n,
                d = e[r++] * t + i,
                a.quadraticCurveTo(u, d, c, h);
                break;
            case "b":
                c = e[r++] * t + n,
                h = e[r++] * t + i,
                u = e[r++] * t + n,
                d = e[r++] * t + i,
                p = e[r++] * t + n,
                m = e[r++] * t + i,
                a.bezierCurveTo(u, d, p, m, c, h)
            }
        }
    }
    return {
        offsetX: s.ha * t,
        path: a
    }
}
var em = function(e) {
    for (var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Infinity, r = e.getIndex() || e.getAttribute("position"), s = r.count / 3, a = [], o = n; o < s && o <= i; o++) {
        var l = o % 2 == 0
          , c = t ? 1 : 0;
        l ? a.push(0, 0, 1, 0, 1, 0, 1, 0, c) : a.push(0, 1, 0, 0, 0, 1, 1, 0, c)
    }
    var h = new Float32Array(a)
      , u = new Ii(h,3);
    e.setAttribute("barycentric", u)
}
  , tm = (e,t)=>e.r !== t.r || e.g !== t.g || e.b !== t.b
  , nm = {
    different: tm,
    same: (e,t)=>!tm(e, t)
}
  , im = function() {
    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    e && e.dispose && k.fn(e.dispose) && e.dispose()
}
  , rm = function e() {
    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    if (k.arr(t) && t.forEach((t=>e(t))),
    "Audio" === t.type && t.isPlaying && t.stop(),
    im(t.geometry),
    t.material) {
        var n = k.arr(t.material) ? t.material : [t.material];
        n.forEach((e=>{
            Object.values(e).forEach(im),
            im(e)
        }
        ))
    }
    t.children.length && t.children.forEach(e),
    !t.isScene && t.dispose && k.fn(t.dispose) && t.dispose(),
    t.parent && t.parent.remove(t)
}
  , sm = e=>{
    var t = APP_DB.SCENE_TYPES;
    return !e || e === t.Float || e === t.Hit
}
  , am = Math
  , om = function() {
    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
      , {max: t=1, min: n=0} = e;
    if (n === t)
        return t;
    var i = t - n
      , r = am.random() * i + n;
    return r
}
  , lm = function e() {
    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
      , n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    return t ? k.arr(t) && k.arr(n) ? t.length ? t : n : Object.fromEntries(Object.entries(n).map((n=>{
        var [i,r] = n;
        return k.arr(r) ? k.arr(t[i]) ? [i, t[i]] : [i, r] : k.obj(r) || k.obj(t[i]) ? [i, e(t[i], r)] : [i, t.hasOwnProperty(i) ? t[i] : r]
    }
    ))) : n
}
  , cm = function() {
    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : ""
      , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "no";
    return e.toLowerCase().includes(t.toLowerCase())
}
  , hm = e=>{
    var {search: t, node: n} = e
      , i = !1
      , r = !1
      , s = !1;
    return t.startsWith("*") && (t = t.slice(1),
    i = !0,
    r = !0),
    t.endsWith("*") && (t = t.slice(0, -1),
    i = !0,
    s = !0),
    i ? r && s ? cm(n.name, t) : r ? n.name.endsWith(t) : s ? n.name.startsWith(t) : void 0 : n.name === t
}
  , um = e=>{
    var {node: t, search: n} = e;
    return !(!n || !n.length) && (k.arr(n) ? n.some((e=>hm({
        search: e,
        node: t
    }))) : hm({
        search: n,
        node: t
    }))
}
  , dm = e=>(parseFloat(e).toFixed(2) / 1).toFixed(1).toString()
  , pm = e=>k.num(e) ? {
    max: e,
    min: 0
} : k.obj(e) ? (e.hasOwnProperty("min") || (e.min = 0),
e.hasOwnProperty("max") || (e.max = e.min),
e) : {
    max: 0,
    min: 0
};
const mm = {
    type: "change"
}
  , fm = {
    type: "start"
}
  , gm = {
    type: "end"
};
class vm extends wt {
    constructor(e, t) {
        super(),
        this.object = e,
        this.domElement = t,
        this.domElement.style.touchAction = "none",
        this.enabled = !0,
        this.target = new pn,
        this.minDistance = 0,
        this.maxDistance = Infinity,
        this.minZoom = 0,
        this.maxZoom = Infinity,
        this.minPolarAngle = 0,
        this.maxPolarAngle = Math.PI,
        this.minAzimuthAngle = -Infinity,
        this.maxAzimuthAngle = Infinity,
        this.enableDamping = !1,
        this.dampingFactor = .05,
        this.enableZoom = !0,
        this.zoomSpeed = 1,
        this.enableRotate = !0,
        this.rotateSpeed = 1,
        this.enablePan = !0,
        this.panSpeed = 1,
        this.screenSpacePanning = !0,
        this.keyPanSpeed = 7,
        this.autoRotate = !1,
        this.autoRotateSpeed = 2,
        this.keys = {
            LEFT: "ArrowLeft",
            UP: "ArrowUp",
            RIGHT: "ArrowRight",
            BOTTOM: "ArrowDown"
        },
        this.mouseButtons = {
            LEFT: te.ROTATE,
            MIDDLE: te.DOLLY,
            RIGHT: te.PAN
        },
        this.touches = {
            ONE: ne.ROTATE,
            TWO: ne.DOLLY_PAN
        },
        this.target0 = this.target.clone(),
        this.position0 = this.object.position.clone(),
        this.zoom0 = this.object.zoom,
        this._domElementKeyEvents = null,
        this.getPolarAngle = function() {
            return a.phi
        }
        ,
        this.getAzimuthalAngle = function() {
            return a.theta
        }
        ,
        this.getDistance = function() {
            return this.object.position.distanceTo(this.target)
        }
        ,
        this.listenToKeyEvents = function(e) {
            e.addEventListener("keydown", V),
            this._domElementKeyEvents = e
        }
        ,
        this.saveState = function() {
            n.target0.copy(n.target),
            n.position0.copy(n.object.position),
            n.zoom0 = n.object.zoom
        }
        ,
        this.reset = function() {
            n.target.copy(n.target0),
            n.object.position.copy(n.position0),
            n.object.zoom = n.zoom0,
            n.object.updateProjectionMatrix(),
            n.dispatchEvent(mm),
            n.update(),
            r = i.NONE
        }
        ,
        this.update = function() {
            const t = new pn
              , u = (new dn).setFromUnitVectors(e.up, new pn(0,1,0))
              , d = u.clone().invert()
              , p = new pn
              , m = new dn
              , f = 2 * Math.PI;
            return function() {
                const e = n.object.position;
                t.copy(e).sub(n.target),
                t.applyQuaternion(u),
                a.setFromVector3(t),
                n.autoRotate && r === i.NONE && w(2 * Math.PI / 60 / 60 * n.autoRotateSpeed),
                n.enableDamping ? (a.theta += o.theta * n.dampingFactor,
                a.phi += o.phi * n.dampingFactor) : (a.theta += o.theta,
                a.phi += o.phi);
                let g = n.minAzimuthAngle
                  , v = n.maxAzimuthAngle;
                return isFinite(g) && isFinite(v) && (g < -Math.PI ? g += f : g > Math.PI && (g -= f),
                v < -Math.PI ? v += f : v > Math.PI && (v -= f),
                a.theta = g <= v ? Math.max(g, Math.min(v, a.theta)) : a.theta > (g + v) / 2 ? Math.max(g, a.theta) : Math.min(v, a.theta)),
                a.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, a.phi)),
                a.makeSafe(),
                a.radius *= l,
                a.radius = Math.max(n.minDistance, Math.min(n.maxDistance, a.radius)),
                !0 === n.enableDamping ? n.target.addScaledVector(c, n.dampingFactor) : n.target.add(c),
                t.setFromSpherical(a),
                t.applyQuaternion(d),
                e.copy(n.target).add(t),
                n.object.lookAt(n.target),
                !0 === n.enableDamping ? (o.theta *= 1 - n.dampingFactor,
                o.phi *= 1 - n.dampingFactor,
                c.multiplyScalar(1 - n.dampingFactor)) : (o.set(0, 0, 0),
                c.set(0, 0, 0)),
                l = 1,
                !!(h || p.distanceToSquared(n.object.position) > s || 8 * (1 - m.dot(n.object.quaternion)) > s) && (n.dispatchEvent(mm),
                p.copy(n.object.position),
                m.copy(n.object.quaternion),
                h = !1,
                !0)
            }
        }(),
        this.dispose = function() {
            n.domElement.removeEventListener("contextmenu", W),
            n.domElement.removeEventListener("pointerdown", F),
            n.domElement.removeEventListener("pointercancel", G),
            n.domElement.removeEventListener("wheel", H),
            n.domElement.removeEventListener("pointermove", B),
            n.domElement.removeEventListener("pointerup", k),
            null !== n._domElementKeyEvents && n._domElementKeyEvents.removeEventListener("keydown", V)
        }
        ;
        const n = this
          , i = {
            NONE: -1,
            ROTATE: 0,
            DOLLY: 1,
            PAN: 2,
            TOUCH_ROTATE: 3,
            TOUCH_PAN: 4,
            TOUCH_DOLLY_PAN: 5,
            TOUCH_DOLLY_ROTATE: 6
        };
        let r = i.NONE;
        const s = 1e-6
          , a = new Iu
          , o = new Iu;
        let l = 1;
        const c = new pn;
        let h = !1;
        const u = new Ft
          , d = new Ft
          , p = new Ft
          , m = new Ft
          , f = new Ft
          , g = new Ft
          , v = new Ft
          , x = new Ft
          , y = new Ft
          , _ = []
          , b = {};
        function M() {
            return Math.pow(.95, n.zoomSpeed)
        }
        function w(e) {
            o.theta -= e
        }
        function S(e) {
            o.phi -= e
        }
        const T = function() {
            const e = new pn;
            return function(t, n) {
                e.setFromMatrixColumn(n, 0),
                e.multiplyScalar(-t),
                c.add(e)
            }
        }()
          , A = function() {
            const e = new pn;
            return function(t, i) {
                !0 === n.screenSpacePanning ? e.setFromMatrixColumn(i, 1) : (e.setFromMatrixColumn(i, 0),
                e.crossVectors(n.object.up, e)),
                e.multiplyScalar(t),
                c.add(e)
            }
        }()
          , E = function() {
            const e = new pn;
            return function(t, i) {
                const r = n.domElement;
                if (n.object.isPerspectiveCamera) {
                    const s = n.object.position;
                    e.copy(s).sub(n.target);
                    let a = e.length();
                    a *= Math.tan(n.object.fov / 2 * Math.PI / 180),
                    T(2 * t * a / r.clientHeight, n.object.matrix),
                    A(2 * i * a / r.clientHeight, n.object.matrix)
                } else
                    n.object.isOrthographicCamera ? (T(t * (n.object.right - n.object.left) / n.object.zoom / r.clientWidth, n.object.matrix),
                    A(i * (n.object.top - n.object.bottom) / n.object.zoom / r.clientHeight, n.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),
                    n.enablePan = !1)
            }
        }();
        function C(e) {
            n.object.isPerspectiveCamera ? l /= e : n.object.isOrthographicCamera ? (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom * e)),
            n.object.updateProjectionMatrix(),
            h = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
            n.enableZoom = !1)
        }
        function L(e) {
            n.object.isPerspectiveCamera ? l *= e : n.object.isOrthographicCamera ? (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / e)),
            n.object.updateProjectionMatrix(),
            h = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
            n.enableZoom = !1)
        }
        function R(e) {
            u.set(e.clientX, e.clientY)
        }
        function P(e) {
            m.set(e.clientX, e.clientY)
        }
        function I() {
            if (1 === _.length)
                u.set(_[0].pageX, _[0].pageY);
            else {
                const e = .5 * (_[0].pageX + _[1].pageX)
                  , t = .5 * (_[0].pageY + _[1].pageY);
                u.set(e, t)
            }
        }
        function D() {
            if (1 === _.length)
                m.set(_[0].pageX, _[0].pageY);
            else {
                const e = .5 * (_[0].pageX + _[1].pageX)
                  , t = .5 * (_[0].pageY + _[1].pageY);
                m.set(e, t)
            }
        }
        function O() {
            const e = _[0].pageX - _[1].pageX
              , t = _[0].pageY - _[1].pageY
              , n = Math.sqrt(e * e + t * t);
            v.set(0, n)
        }
        function N(e) {
            if (1 == _.length)
                d.set(e.pageX, e.pageY);
            else {
                const t = q(e)
                  , n = .5 * (e.pageX + t.x)
                  , i = .5 * (e.pageY + t.y);
                d.set(n, i)
            }
            p.subVectors(d, u).multiplyScalar(n.rotateSpeed);
            const t = n.domElement;
            w(2 * Math.PI * p.x / t.clientHeight),
            S(2 * Math.PI * p.y / t.clientHeight),
            u.copy(d)
        }
        function z(e) {
            if (1 === _.length)
                f.set(e.pageX, e.pageY);
            else {
                const t = q(e)
                  , n = .5 * (e.pageX + t.x)
                  , i = .5 * (e.pageY + t.y);
                f.set(n, i)
            }
            g.subVectors(f, m).multiplyScalar(n.panSpeed),
            E(g.x, g.y),
            m.copy(f)
        }
        function U(e) {
            const t = q(e)
              , i = e.pageX - t.x
              , r = e.pageY - t.y
              , s = Math.sqrt(i * i + r * r);
            x.set(0, s),
            y.set(0, Math.pow(x.y / v.y, n.zoomSpeed)),
            C(y.y),
            v.copy(x)
        }
        function F(e) {
            !1 !== n.enabled && (0 === _.length && (n.domElement.setPointerCapture(e.pointerId),
            n.domElement.addEventListener("pointermove", B),
            n.domElement.addEventListener("pointerup", k)),
            function(e) {
                _.push(e)
            }(e),
            "touch" === e.pointerType ? function(e) {
                switch (X(e),
                _.length) {
                case 1:
                    switch (n.touches.ONE) {
                    case ne.ROTATE:
                        if (!1 === n.enableRotate)
                            return;
                        I(),
                        r = i.TOUCH_ROTATE;
                        break;
                    case ne.PAN:
                        if (!1 === n.enablePan)
                            return;
                        D(),
                        r = i.TOUCH_PAN;
                        break;
                    default:
                        r = i.NONE
                    }
                    break;
                case 2:
                    switch (n.touches.TWO) {
                    case ne.DOLLY_PAN:
                        if (!1 === n.enableZoom && !1 === n.enablePan)
                            return;
                        n.enableZoom && O(),
                        n.enablePan && D(),
                        r = i.TOUCH_DOLLY_PAN;
                        break;
                    case ne.DOLLY_ROTATE:
                        if (!1 === n.enableZoom && !1 === n.enableRotate)
                            return;
                        n.enableZoom && O(),
                        n.enableRotate && I(),
                        r = i.TOUCH_DOLLY_ROTATE;
                        break;
                    default:
                        r = i.NONE
                    }
                    break;
                default:
                    r = i.NONE
                }
                r !== i.NONE && n.dispatchEvent(fm)
            }(e) : function(e) {
                let t;
                switch (e.button) {
                case 0:
                    t = n.mouseButtons.LEFT;
                    break;
                case 1:
                    t = n.mouseButtons.MIDDLE;
                    break;
                case 2:
                    t = n.mouseButtons.RIGHT;
                    break;
                default:
                    t = -1
                }
                switch (t) {
                case te.DOLLY:
                    if (!1 === n.enableZoom)
                        return;
                    !function(e) {
                        v.set(e.clientX, e.clientY)
                    }(e),
                    r = i.DOLLY;
                    break;
                case te.ROTATE:
                    if (e.ctrlKey || e.metaKey || e.shiftKey) {
                        if (!1 === n.enablePan)
                            return;
                        P(e),
                        r = i.PAN
                    } else {
                        if (!1 === n.enableRotate)
                            return;
                        R(e),
                        r = i.ROTATE
                    }
                    break;
                case te.PAN:
                    if (e.ctrlKey || e.metaKey || e.shiftKey) {
                        if (!1 === n.enableRotate)
                            return;
                        R(e),
                        r = i.ROTATE
                    } else {
                        if (!1 === n.enablePan)
                            return;
                        P(e),
                        r = i.PAN
                    }
                    break;
                default:
                    r = i.NONE
                }
                r !== i.NONE && n.dispatchEvent(fm)
            }(e))
        }
        function B(e) {
            !1 !== n.enabled && ("touch" === e.pointerType ? function(e) {
                switch (X(e),
                r) {
                case i.TOUCH_ROTATE:
                    if (!1 === n.enableRotate)
                        return;
                    N(e),
                    n.update();
                    break;
                case i.TOUCH_PAN:
                    if (!1 === n.enablePan)
                        return;
                    z(e),
                    n.update();
                    break;
                case i.TOUCH_DOLLY_PAN:
                    if (!1 === n.enableZoom && !1 === n.enablePan)
                        return;
                    !function(e) {
                        n.enableZoom && U(e),
                        n.enablePan && z(e)
                    }(e),
                    n.update();
                    break;
                case i.TOUCH_DOLLY_ROTATE:
                    if (!1 === n.enableZoom && !1 === n.enableRotate)
                        return;
                    !function(e) {
                        n.enableZoom && U(e),
                        n.enableRotate && N(e)
                    }(e),
                    n.update();
                    break;
                default:
                    r = i.NONE
                }
            }(e) : function(e) {
                switch (r) {
                case i.ROTATE:
                    if (!1 === n.enableRotate)
                        return;
                    !function(e) {
                        d.set(e.clientX, e.clientY),
                        p.subVectors(d, u).multiplyScalar(n.rotateSpeed);
                        const t = n.domElement;
                        w(2 * Math.PI * p.x / t.clientHeight),
                        S(2 * Math.PI * p.y / t.clientHeight),
                        u.copy(d),
                        n.update()
                    }(e);
                    break;
                case i.DOLLY:
                    if (!1 === n.enableZoom)
                        return;
                    !function(e) {
                        x.set(e.clientX, e.clientY),
                        y.subVectors(x, v),
                        y.y > 0 ? C(M()) : y.y < 0 && L(M()),
                        v.copy(x),
                        n.update()
                    }(e);
                    break;
                case i.PAN:
                    if (!1 === n.enablePan)
                        return;
                    !function(e) {
                        f.set(e.clientX, e.clientY),
                        g.subVectors(f, m).multiplyScalar(n.panSpeed),
                        E(g.x, g.y),
                        m.copy(f),
                        n.update()
                    }(e)
                }
            }(e))
        }
        function k(e) {
            j(e),
            0 === _.length && (n.domElement.releasePointerCapture(e.pointerId),
            n.domElement.removeEventListener("pointermove", B),
            n.domElement.removeEventListener("pointerup", k)),
            n.dispatchEvent(gm),
            r = i.NONE
        }
        function G(e) {
            j(e)
        }
        function H(e) {
            !1 !== n.enabled && !1 !== n.enableZoom && r === i.NONE && (e.preventDefault(),
            n.dispatchEvent(fm),
            function(e) {
                e.deltaY < 0 ? L(M()) : e.deltaY > 0 && C(M()),
                n.update()
            }(e),
            n.dispatchEvent(gm))
        }
        function V(e) {
            !1 !== n.enabled && !1 !== n.enablePan && function(e) {
                let t = !1;
                switch (e.code) {
                case n.keys.UP:
                    E(0, n.keyPanSpeed),
                    t = !0;
                    break;
                case n.keys.BOTTOM:
                    E(0, -n.keyPanSpeed),
                    t = !0;
                    break;
                case n.keys.LEFT:
                    E(n.keyPanSpeed, 0),
                    t = !0;
                    break;
                case n.keys.RIGHT:
                    E(-n.keyPanSpeed, 0),
                    t = !0
                }
                t && (e.preventDefault(),
                n.update())
            }(e)
        }
        function W(e) {
            !1 !== n.enabled && e.preventDefault()
        }
        function j(e) {
            delete b[e.pointerId];
            for (let t = 0; t < _.length; t++)
                if (_[t].pointerId == e.pointerId)
                    return void _.splice(t, 1)
        }
        function X(e) {
            let t = b[e.pointerId];
            void 0 === t && (t = new Ft,
            b[e.pointerId] = t),
            t.set(e.pageX, e.pageY)
        }
        function q(e) {
            const t = e.pointerId === _[0].pointerId ? _[1] : _[0];
            return b[t.pointerId]
        }
        n.domElement.addEventListener("contextmenu", W),
        n.domElement.addEventListener("pointerdown", F),
        n.domElement.addEventListener("pointercancel", G),
        n.domElement.addEventListener("wheel", H, {
            passive: !1
        }),
        this.update()
    }
}
var xm = (e,t,n)=>{
    var i = t.clone().sub(e).normalize().multiplyScalar(n);
    return e.clone().add(i)
}
;
xm.percent = (e,t,n)=>{
    var i = t.clone().sub(e)
      , r = i.length()
      , s = i.normalize().multiplyScalar(r * n);
    return e.clone().add(s)
}
;
class ym {
    constructor(e) {
        var {artifact: t, engine: n, preload: i, videoElement: r} = e;
        this.engine = n,
        this.preload = i,
        r || (r = i.assets.videoElement),
        this.videoElement = r,
        this.name = "Record3D";
        var {filterSize: s="1", minDepth: a="0.1", maxDepth: o="5.0", depthThresholdFilter: l="0.9", scale: c="2.0", ptSize: h=1, depthScale: u="1.0", pixelDepth: d="1.0", permanentSeconds: p=[], useBone: m=!1, parentName: f="parent", playbackRate: g=1, loopVideo: v=!0, continueVideoSound: x=!1, useFog: y=!1, addFog: _=1e-4, fogColor: b=16448250, rotation: M={}, videoAlpha: w=1, permanentAlpha: S=.1, hideModelsOnVideoEnded: T=[], addReflector: A=!1} = t;
        this.shaderConfig = {
            filterSize: s,
            minDepth: a,
            maxDepth: o,
            depthThresholdFilter: l,
            scale: c,
            depthScale: u,
            ptSize: (h * window.devicePixelRatio).toFixed(1).toString(),
            pixelDepth: d
        },
        this.permanentSeconds = p,
        this.currentSecondId = 0,
        this.useBone = m,
        this.parentName = f,
        this.useFog = y,
        this.addFog = _,
        this.fogColor = b,
        this.loopVideo = v,
        this.continueVideoSound = x,
        this.hideModelsOnVideoEnded = T,
        this.addReflector = A,
        this.videoAlpha = w,
        this.permanentAlpha = S,
        this.rotation = M,
        this.playbackRate = g,
        this.hideCharacter = this.hideCharacter.bind(this);
        var {videoWidth: E, videoHeight: C} = r;
        if (r) {
            r.playbackRate = this.playbackRate,
            this.modelsToHide = [],
            (this.hideModelsOnVideoEnded.length || !1 === this.loopVideo) && (pd.on(r, "seeked", this.hideCharacter),
            this.hideModelsOnVideoEnded.forEach((e=>{
                var t = i.assets.gltf.scene.getObjectByName(e);
                t.material.transparent = !0,
                this.modelsToHide.push(t)
            }
            )));
            var L = new pl(r,{
                minFilter: we
            });
            this.videoTexture = L,
            this.pointCopies = [],
            this.canvases = [],
            this.permanentSeconds.forEach(((e,t)=>{
                var i = pd.create("canvas", {
                    height: C,
                    width: E,
                    style: {
                        position: "fixed",
                        left: "100vw"
                    },
                    parent: G.B
                });
                this.canvases.push(i);
                var r = new fl(i,{
                    minFilter: we
                })
                  , s = this.createPoints(r, this.permanentAlpha);
                s.visible = !1,
                this.pointCopies.push(s),
                n.scene.add(s)
            }
            ));
            var R = this.createPoints(L, this.videoAlpha)
              , P = this.rotation;
            P.x && R.rotateX(P.x),
            P.y && R.rotateY(P.y),
            P.z && R.rotateZ(P.z),
            this.useBone ? this.child = R : this.model = R,
            this.useFog && (this.fog = new ao(this.fogColor,.005),
            this.engine.scene.fog = this.fog)
        } else
            console.error("videoElement not defined", {
                engine: n,
                preload: i,
                videoElement: r
            })
    }
    hideCharacter() {
        this.hasTriggeredOnce ? this.fadeOutModel = !0 : this.hasTriggeredOnce = !0
    }
    createPoints(e) {
        for (var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "1.0", {artifact: n={}} = this.engine, {videoElement: i} = this, {videoWidth: r, videoHeight: s} = i, a = new Ka, {ifx: o=.00125, ify: l=.00125, itx: c=-.4, ity: h=-.6} = n, {filterSize: u, minDepth: d, maxDepth: p, depthScale: m, depthThresholdFilter: f, scale: g, ptSize: v, pixelDepth: x} = this.shaderConfig, y = new pr({
            uniforms: {
                texImg: {
                    type: "t",
                    value: e
                },
                texSize: {
                    type: "i2",
                    value: [r, s]
                },
                iK: {
                    type: "f4",
                    value: [o, l, c, h]
                },
                alpha: {
                    type: "f",
                    value: t
                },
                filterSize: {
                    type: "f",
                    value: u
                },
                minDepth: {
                    type: "f",
                    value: d
                },
                maxDepth: {
                    type: "f",
                    value: p
                },
                depthThresholdFilter: {
                    type: "f",
                    value: f
                },
                scale: {
                    type: "f",
                    value: g
                },
                ptSize: {
                    type: "f",
                    value: v
                },
                pixelDepth: {
                    type: "f",
                    value: x
                },
                depthScale: {
                    type: "f",
                    value: m
                }
            },
            side: ae,
            transparent: !0,
            vertexShader: "#define GLSLIFY 1\nattribute float vertexIdx;varying float vVertexIdx;varying vec2 vPtPos;uniform ivec2 texSize;uniform sampler2D texImg;uniform vec4 iK;uniform float scale;uniform float minDepth;uniform float maxDepth;uniform float pixelDepth;uniform int filterSize;uniform float ptSize;uniform float depthThresholdFilter;uniform float depthScale;float rgb2hue(vec3 c){vec4 K=vec4(0.0,-1.0/3.0,2.0/3.0,-1.0);vec4 p=mix(vec4(c.bg,K.wz),vec4(c.gb,K.xy),step(c.b,c.g));vec4 q=mix(vec4(p.xyw,c.r),vec4(c.r,p.yzx),step(p.x,c.r));float d=q.x-min(q.w,q.y);float e=1.0e-10;return abs(q.z+(q.w-q.y)/(6.0*d+e));}float getPixelDepth(ivec2 pixel){vec2 lookupPt=(vec2(pixel)+vec2(0.5))/vec2(texSize);float hue=rgb2hue(texture2D(texImg,lookupPt).rgb);float pxDepth=pixelDepth*hue;return pxDepth;}bool shouldDiscard(ivec2 currPixel){float centerPixelDepth=getPixelDepth(currPixel);for(int i=-filterSize;i<=filterSize;i++){for(int j=-filterSize;j<=filterSize;j++){if(i==0&&j==0){continue;}float currDepth=getPixelDepth(currPixel+ivec2(j,i));if(currDepth<minDepth||currDepth>=maxDepth||abs(centerPixelDepth-currDepth)>depthThresholdFilter){return true;}}}return false;}void main(){ivec2 frameSize=ivec2(texSize.x/2,texSize.y);int vertIdx=int(vertexIdx);int actualNumPts=frameSize.x*frameSize.y;if(vertIdx>=actualNumPts){gl_Position=vec4(0.0);return;}int ptY=vertIdx/int(frameSize.x);int ptX=vertIdx-ptY*int(frameSize.x);ivec2 pt=ivec2(ptX,ptY);if(shouldDiscard(pt)){gl_Position=vec4(0.0);return;}float currDepth=getPixelDepth(pt);vec3 ptPos=scale*vec3((iK.x*float(ptX)+iK.z)*currDepth,(iK.y*float(ptY)+iK.w)*currDepth,-currDepth*depthScale);vec4 mvPos=modelViewMatrix*vec4(ptPos,1.0);gl_Position=projectionMatrix*mvPos;vPtPos=vec2(float(ptX),float(ptY));vVertexIdx=vertexIdx;gl_PointSize=ptSize;}",
            fragmentShader: "#define GLSLIFY 1\nvarying float vVertexIdx;varying vec2 vPtPos;uniform ivec2 texSize;uniform sampler2D texImg;uniform float alpha;void main(){vec2 frameSizeF=vec2(texSize.x/2,texSize.y);ivec2 frameSize=ivec2(frameSizeF);int vertIdx=int(vVertexIdx);int actualNumPts=frameSize.x*frameSize.y;if(vertIdx>=actualNumPts){discard;}vec2 lookupPt=(vec2(vPtPos.x+frameSizeF.x,vPtPos.y)+vec2(0.5))/vec2(texSize);vec3 currColor=texture2D(texImg,lookupPt).rgb;gl_FragColor=vec4(currColor,alpha);}"
        }), _ = r / 2 * s, b = new Uint32Array(_), M = new Float32Array(_), w = 0; w < _; w++)
            b[w] = w,
            M[w] = w;
        var S = new Vi;
        S.setAttribute("vertexIdx", new Ni(M,1)),
        S.setIndex(new Oi(new Uint32Array(b),1));
        var T = new ul(S,y);
        return T.frustumCulled = !1,
        a.add(T),
        a
    }
    exit() {
        pd.remove(this.canvasImgs)
    }
    renderCopies() {
        new Promise((e=>{
            var {videoElement: t} = this
              , {videoHeight: n, videoWidth: i} = t;
            if (this.waitForSecond) {
                if (t.currentTime > this.waitForSecond) {
                    this.canvases[this.currentSecondId].getContext("2d").drawImage(t, 0, 0, i, n);
                    var r = this.pointCopies[this.currentSecondId];
                    r.visible = !0,
                    this.child.matrixWorld.decompose(r.position, r.rotation, r.scale),
                    this.currentSecondId++,
                    this.waitForSecond = this.permanentSeconds[this.currentSecondId]
                }
            } else
                this.waitForSecond = this.permanentSeconds[this.currentSecondId];
            e()
        }
        ))
    }
    tick(e) {
        var {engine: t} = e;
        if (this.currentSecondId < this.permanentSeconds.length && this.renderCopies(t),
        this.fog && this.addFog && (this.fog.density += this.addFog),
        this.fadeOutModel && !this.hasFaded) {
            this.modelsToHide.forEach((e=>{
                e.material.opacity > 0 ? e.material.opacity -= .05 : e.visible && (e.visible = !1)
            }
            ));
            var n = this.model || this.child;
            if (n && n.visible) {
                var i, r, s, a = null == n ? void 0 : n.children[0];
                (null == a || null === (i = a.material) || void 0 === i || null === (r = i.uniforms) || void 0 === r || null === (s = r.alpha) || void 0 === s ? void 0 : s.value) > 0 ? a.material.uniforms.alpha.value -= .05 : n.visible && (n.visible = !1,
                this.continuePlayingNonLoopedVideo && this.videoElement.pause())
            }
        }
    }
}
class _m extends pr {
    constructor() {
        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
          , n = t({
            uBaseTexture: {
                type: "t",
                value: null
            },
            uBaseSpeed: {
                type: "f",
                value: .5
            },
            uNoiseTexture: {
                type: "t",
                value: null
            },
            uNoiseScale: {
                type: "f",
                value: .2
            },
            uAlpha: {
                type: "f",
                value: .5
            },
            uTime: {
                type: "f",
                value: 1
            },
            uRepeat: {
                type: "f",
                value: 10
            }
        }, e.uniforms)
          , {side: i=ae, transparent: r=!0, textureId: s=1} = e;
        super(t({
            uniforms: n,
            side: i,
            transparent: r,
            vertexShader: "\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n",
            fragmentShader: "\nuniform sampler2D uBaseTexture;\nuniform float uBaseSpeed;\nuniform sampler2D uNoiseTexture;\nuniform float uNoiseScale;\nuniform float uAlpha;\nuniform float uTime;\nuniform float uRepeat;\n\nvarying vec2 vUv;\n\nvoid main()  {\n  vec2 newUv = vUv * uRepeat;\n\tvec2 uvTimeShift = newUv + vec2(-0.7, 1.5) * uTime * uBaseSpeed;\n\tvec4 noiseGeneratorTimeShift = texture2D(uNoiseTexture, uvTimeShift);\n\tvec2 uvNoiseTimeShift = newUv + uNoiseScale * vec2(noiseGeneratorTimeShift.r, noiseGeneratorTimeShift.b);\n\tvec4 baseColor = texture2D(uBaseTexture, uvNoiseTimeShift);\n\n\tbaseColor.a = uAlpha;\n\tgl_FragColor = baseColor;\n}\n"
        }, e)),
        this.textureId = s
    }
    preload(e) {
        var t = this;
        return i((function*() {
            var {textureId: n} = t
              , [i,r] = yield Promise.all([e.promisifiedLoad({
                loader: e.textureLoader,
                file: "".concat(G.STATIC_URL, "/textures/waterplane/water_").concat(n, ".jpg")
            }), e.promisifiedLoad({
                loader: e.textureLoader,
                file: "".concat(G.STATIC_URL, "/textures/waterplane/cloud_").concat(n, ".png")
            })]);
            i.wrapT = i.wrapS = ve,
            r.wrapT = r.wrapS = ve,
            t.uniforms.uBaseTexture.value = i,
            t.uniforms.uNoiseTexture.value = r
        }
        ))()
    }
    tick(e) {
        this.uniforms.uTime.value += e
    }
}
var bm = Object.freeze({
    __proto__: null,
    CirclingLights: class {
        constructor(e) {
            e.artifact.circlingLights.forEach((t=>{
                var {color: n=16711680, intensity: i=1, dim: r=0, decay: s=2, shadows: a=!1, show: o=!1} = t
                  , l = new Uh(n,i,r,s);
                if (a && (l.castShadow = !0,
                l.shadow.camera.near = .1,
                l.shadow.camera.far = 5),
                o) {
                    var c = new Pc(.05,6,6)
                      , h = new Li({
                        color: n
                    })
                      , u = new or(c,h);
                    l.add(u)
                }
                if (e.circlingLights.push({
                    light: l,
                    config: t
                }),
                e.model.add(l),
                o) {
                    var d = new Gu(l,.1,n);
                    e.model.add(d)
                }
            }
            ))
        }
        render(e) {
            var {engine: t, timestamp: n} = e
              , i = 5e-4 * n;
            t.circlingLights.forEach((e=>{
                var {light: t, config: n} = e
                  , {lightDistance: r=1, timeOffset: s=20, offset: {x: a=0, y: o=0, z: l=0}={}} = n;
                i += 1e3 * s;
                var c = Math.sin(i) * r + a
                  , h = Math.sin(1.1 * i) * r + o
                  , u = Math.sin(1.2 * i) * r + l;
                t.position.set(c, h, u)
            }
            ))
        }
    }
})
  , Mm = Object.freeze({
    __proto__: null,
    addCustomMaterials: e=>{
        var {preload: t} = e
          , {customMaterials: n=[]} = t.assets;
        n.forEach((t=>{
            var {config: n, material: i} = t
              , r = e.model.getObjectByName(n.target);
            r && (r.material = i,
            k.fn(i.init) && i.init({
                engine: e
            }),
            e.customMaterials.push({
                config: n,
                material: i
            }))
        }
        ))
    }
    ,
    renderCustomMaterials: e=>{
        var {delta: t, engine: n} = e;
        n.customMaterials.forEach((n=>{
            var {config: i, material: r} = n;
            if (r.uniforms.uTime) {
                var {speed: s=1} = i;
                r.uniforms.uTime.value += t * s
            }
            k.fn(r.tick) && r.tick(e)
        }
        ))
    }
})
  , wm = Object.freeze({
    __proto__: null,
    addVideoTrigger: e=>{
        e.model.traverse((t=>{
            e.videoTrigger || ["videotarget", "videotrigger"].some((e=>cm(t.name, e))) && (e.videoTrigger = t,
            e.videoTrigger.visible = !1)
        }
        ))
    }
    ,
    renderVideoTrigger: e=>{
        if (e.modelSpawned && e.artifact.triggerVideo && e.videoTrigger) {
            var {audioElement: t, camera: n, videoElement: i, videoTrigger: r} = e
              , {triggerAudio: s, triggerVideo: a=!0, triggerVideoDistance: o=1.1} = e.artifact
              , l = o * o
              , c = r.position.clone();
            c.add(r.parent.position),
            n.position.distanceToSquared(c) <= l ? (a && i && i.paused && (i.play(),
            r.visible = !0),
            s && t && t.paused && t.play()) : (!i.paused && a && (i.pause(),
            r.visible = !1),
            s && t && !t.paused && t.pause())
        }
    }
});
class Sm extends or {
    constructor(e, t={}) {
        super(e),
        this.isWater = !0;
        const n = this
          , i = void 0 !== t.textureWidth ? t.textureWidth : 512
          , r = void 0 !== t.textureHeight ? t.textureHeight : 512
          , s = void 0 !== t.clipBias ? t.clipBias : 0
          , a = void 0 !== t.alpha ? t.alpha : 1
          , o = void 0 !== t.time ? t.time : 0
          , l = void 0 !== t.waterNormals ? t.waterNormals : null
          , c = void 0 !== t.sunDirection ? t.sunDirection : new pn(.70707,.70707,0)
          , h = new en(void 0 !== t.sunColor ? t.sunColor : 16777215)
          , u = new en(void 0 !== t.waterColor ? t.waterColor : 8355711)
          , d = void 0 !== t.eye ? t.eye : new pn(0,0,0)
          , p = void 0 !== t.distortionScale ? t.distortionScale : 20
          , m = void 0 !== t.side ? t.side : 0
          , f = void 0 !== t.fog && t.fog
          , g = new wr
          , v = new pn
          , x = new pn
          , y = new pn
          , _ = new Wn
          , b = new pn(0,0,-1)
          , M = new ln
          , w = new pn
          , S = new pn
          , T = new ln
          , A = new Wn
          , E = new fr
          , C = new cn(i,r)
          , L = {
            uniforms: dr.merge([Pr.fog, Pr.lights, {
                normalSampler: {
                    value: null
                },
                mirrorSampler: {
                    value: null
                },
                alpha: {
                    value: 1
                },
                time: {
                    value: 0
                },
                size: {
                    value: 1
                },
                distortionScale: {
                    value: 20
                },
                textureMatrix: {
                    value: new Wn
                },
                sunColor: {
                    value: new en(8355711)
                },
                sunDirection: {
                    value: new pn(.70707,.70707,0)
                },
                eye: {
                    value: new pn
                },
                waterColor: {
                    value: new en(5592405)
                }
            }]),
            vertexShader: "\n\t\t\t\tuniform mat4 textureMatrix;\n\t\t\t\tuniform float time;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <shadowmap_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tmirrorCoord = modelMatrix * vec4( position, 1.0 );\n\t\t\t\t\tworldPosition = mirrorCoord.xyzw;\n\t\t\t\t\tmirrorCoord = textureMatrix * mirrorCoord;\n\t\t\t\t\tvec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t#include <beginnormal_vertex>\n\t\t\t\t#include <defaultnormal_vertex>\n\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t#include <fog_vertex>\n\t\t\t\t#include <shadowmap_vertex>\n\t\t\t}",
            fragmentShader: "\n\t\t\t\tuniform sampler2D mirrorSampler;\n\t\t\t\tuniform float alpha;\n\t\t\t\tuniform float time;\n\t\t\t\tuniform float size;\n\t\t\t\tuniform float distortionScale;\n\t\t\t\tuniform sampler2D normalSampler;\n\t\t\t\tuniform vec3 sunColor;\n\t\t\t\tuniform vec3 sunDirection;\n\t\t\t\tuniform vec3 eye;\n\t\t\t\tuniform vec3 waterColor;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\tvec4 getNoise( vec2 uv ) {\n\t\t\t\t\tvec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);\n\t\t\t\t\tvec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );\n\t\t\t\t\tvec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );\n\t\t\t\t\tvec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );\n\t\t\t\t\tvec4 noise = texture2D( normalSampler, uv0 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv1 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv2 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv3 );\n\t\t\t\t\treturn noise * 0.5 - 1.0;\n\t\t\t\t}\n\n\t\t\t\tvoid sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {\n\t\t\t\t\tvec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );\n\t\t\t\t\tfloat direction = max( 0.0, dot( eyeDirection, reflection ) );\n\t\t\t\t\tspecularColor += pow( direction, shiny ) * sunColor * spec;\n\t\t\t\t\tdiffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;\n\t\t\t\t}\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <packing>\n\t\t\t\t#include <bsdfs>\n\t\t\t\t#include <fog_pars_fragment>\n\t\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t\t#include <lights_pars_begin>\n\t\t\t\t#include <shadowmap_pars_fragment>\n\t\t\t\t#include <shadowmask_pars_fragment>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <logdepthbuf_fragment>\n\t\t\t\t\tvec4 noise = getNoise( worldPosition.xz * size );\n\t\t\t\t\tvec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );\n\n\t\t\t\t\tvec3 diffuseLight = vec3(0.0);\n\t\t\t\t\tvec3 specularLight = vec3(0.0);\n\n\t\t\t\t\tvec3 worldToEye = eye-worldPosition.xyz;\n\t\t\t\t\tvec3 eyeDirection = normalize( worldToEye );\n\t\t\t\t\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\n\n\t\t\t\t\tfloat distance = length(worldToEye);\n\n\t\t\t\t\tvec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;\n\t\t\t\t\tvec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );\n\n\t\t\t\t\tfloat theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );\n\t\t\t\t\tfloat rf0 = 0.3;\n\t\t\t\t\tfloat reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );\n\t\t\t\t\tvec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;\n\t\t\t\t\tvec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);\n\t\t\t\t\tvec3 outgoingLight = albedo;\n\t\t\t\t\tgl_FragColor = vec4( outgoingLight, alpha );\n\n\t\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t\t#include <fog_fragment>\n\t\t\t\t}"
        }
          , R = new pr({
            fragmentShader: L.fragmentShader,
            vertexShader: L.vertexShader,
            uniforms: dr.clone(L.uniforms),
            lights: !0,
            side: m,
            fog: f
        });
        R.uniforms.mirrorSampler.value = C.texture,
        R.uniforms.textureMatrix.value = A,
        R.uniforms.alpha.value = a,
        R.uniforms.time.value = o,
        R.uniforms.normalSampler.value = l,
        R.uniforms.sunColor.value = h,
        R.uniforms.waterColor.value = u,
        R.uniforms.sunDirection.value = c,
        R.uniforms.distortionScale.value = p,
        R.uniforms.eye.value = d,
        n.material = R,
        n.onBeforeRender = function(e, t, i) {
            if (x.setFromMatrixPosition(n.matrixWorld),
            y.setFromMatrixPosition(i.matrixWorld),
            _.extractRotation(n.matrixWorld),
            v.set(0, 0, 1),
            v.applyMatrix4(_),
            w.subVectors(x, y),
            w.dot(v) > 0)
                return;
            w.reflect(v).negate(),
            w.add(x),
            _.extractRotation(i.matrixWorld),
            b.set(0, 0, -1),
            b.applyMatrix4(_),
            b.add(y),
            S.subVectors(x, b),
            S.reflect(v).negate(),
            S.add(x),
            E.position.copy(w),
            E.up.set(0, 1, 0),
            E.up.applyMatrix4(_),
            E.up.reflect(v),
            E.lookAt(S),
            E.far = i.far,
            E.updateMatrixWorld(),
            E.projectionMatrix.copy(i.projectionMatrix),
            A.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
            A.multiply(E.projectionMatrix),
            A.multiply(E.matrixWorldInverse),
            g.setFromNormalAndCoplanarPoint(v, x),
            g.applyMatrix4(E.matrixWorldInverse),
            M.set(g.normal.x, g.normal.y, g.normal.z, g.constant);
            const r = E.projectionMatrix;
            T.x = (Math.sign(M.x) + r.elements[8]) / r.elements[0],
            T.y = (Math.sign(M.y) + r.elements[9]) / r.elements[5],
            T.z = -1,
            T.w = (1 + r.elements[10]) / r.elements[14],
            M.multiplyScalar(2 / M.dot(T)),
            r.elements[2] = M.x,
            r.elements[6] = M.y,
            r.elements[10] = M.z + 1 - s,
            r.elements[14] = M.w,
            d.setFromMatrixPosition(i.matrixWorld);
            const a = e.getRenderTarget()
              , o = e.xr.enabled
              , l = e.shadowMap.autoUpdate;
            n.visible = !1,
            e.xr.enabled = !1,
            e.shadowMap.autoUpdate = !1,
            e.setRenderTarget(C),
            e.state.buffers.depth.setMask(!0),
            !1 === e.autoClear && e.clear(),
            e.render(t, E),
            n.visible = !0,
            e.xr.enabled = o,
            e.shadowMap.autoUpdate = l,
            e.setRenderTarget(a);
            const c = i.viewport;
            void 0 !== c && e.state.viewport(c)
        }
    }
}
var Tm = Object.freeze({
    __proto__: null,
    OceanPlane: class {
        init(e) {
            return i((function*() {
                var {preload: t, model: n, artifact: i} = e
                  , {name: r="ocean", normals: s="oceannormals1"} = i.ocean
                  , a = n.getObjectByName(r)
                  , o = yield t.promisifiedLoad({
                    loader: t.textureLoader,
                    file: "https://static.artificialmuseum.com/textures/ocean/".concat(s, ".jpg")
                });
                o.wrapS = o.wrapT = ve,
                e.ocean = new Sm(a.geometry,{
                    textureWidth: 512,
                    textureHeight: 512,
                    waterNormals: o,
                    sunDirection: new pn,
                    sunColor: 16777215,
                    waterColor: 1048575,
                    distortionScale: 3.7,
                    fog: !1
                }),
                e.ocean.position.copy(a.position),
                e.ocean.rotation.copy(a.rotation),
                e.model.add(e.ocean),
                a.visible = !1
            }
            ))()
        }
        render(e) {
            var {delta: t, engine: n} = e
              , {animationSpeed: i=1} = n.artifact.ocean;
            n.ocean.material.uniforms.time.value += t * i * .1
        }
    }
});
var Am = Object.freeze({
    __proto__: null,
    Particles: class {
        constructor(e) {
            var {artifact: t, model: n, preload: i} = e;
            this.preload = i,
            this.model = n,
            this.defaultBox = {
                x: 10,
                y: 10,
                z: 10
            },
            this.particles = lm(t.particles, [{
                name: "snowflake",
                size: .1,
                box: this.defaultBox
            }]),
            this.materials = []
        }
        init() {
            var e = this;
            return i((function*() {
                var t = e.preload.textureLoader
                  , n = new Ka;
                yield Promise.all(e.particles.map(function() {
                    var r = i((function*(i) {
                        var {box: r=e.defaultBox, color: s=16777215, count: a=1e3, name: o, size: l, imgType: c="png", opacity: h=1} = i
                          , u = o;
                        u.endsWith(".".concat(c)) && (u = u.replace(".".concat(c), "")),
                        qd.WEBP ? u += ".webp" : u += ".".concat(c);
                        for (var d = yield e.preload.promisifiedLoad({
                            loader: t,
                            file: "https://static.artificialmuseum.com/textures/matcap/".concat(u)
                        }), p = new al({
                            size: l,
                            map: d,
                            color: s,
                            blending: 1,
                            depthTest: !1,
                            transparent: !0,
                            opacity: h
                        }), m = new Vi, f = [], g = 0; g < a; g++) {
                            var v = void 0;
                            if (0 === r.xMin)
                                v = Math.random() * r.x;
                            else
                                v = (Math.random() > .5 ? -1 : 1) * Math.random() * (2 * r.x) - r.x;
                            var x = Math.random() * r.y
                              , y = void 0;
                            if (0 === r.zMin)
                                y = Math.random() * r.z;
                            else
                                y = (Math.random() > .5 ? -1 : 1) * Math.random() * (2 * r.z) - r.z;
                            f.push(v, x, y)
                        }
                        m.setAttribute("position", new Ni(f,3));
                        var _ = new ul(m,p);
                        n.add(_)
                    }
                    ));
                    return function(e) {
                        return r.apply(this, arguments)
                    }
                }())),
                e.model.add(n),
                e.particles = n
            }
            ))()
        }
        update(e) {
            var {delta: t} = e;
            this.particles.rotation.y += .01 * t
        }
    }
});
var Em = Object.freeze({
    __proto__: null,
    UnderwaterPlane: class {
        preload(e) {
            var t = this;
            return i((function*() {
                var {camera: n, preload: i} = e
                  , r = new _m;
                yield r.preload(i),
                t.material = r;
                var s = new Lr(2,2)
                  , a = new or(s,r);
                n.add(a),
                a.position.z -= .1
            }
            ))()
        }
        tick(e) {
            this.material.tick(e)
        }
    }
})
  , Cm = Object.freeze({
    __proto__: null,
    addPly: e=>{
        var n, {artifact: i, preload: r} = e, s = lm(i.ply, {
            vertexColors: !0,
            size: "0.001",
            sizeAttenuation: 0,
            opacity: "1.0"
        });
        e.morphTargetInfluenceConfig = lm(i.ply, {
            animated: !1,
            delay: 1e3,
            speed: 1
        });
        var a = new al(t(t({}, s), {}, {
            transparent: "1.0" !== s.opacity
        }))
          , o = new Ka;
        if (k.arr(r.assets.ply) && null !== (n = r.assets.ply) && void 0 !== n && n.length)
            if (e.morphTargetInfluenceConfig.animated) {
                var [l] = r.assets.ply;
                l.morphAttributes = {
                    position: [],
                    color: []
                },
                r.assets.ply.forEach((e=>{
                    l.morphAttributes.position.push(e.attributes.position),
                    l.morphAttributes.color.push(e.attributes.color)
                }
                ));
                var {size: c, sizeAttenuation: h, vertexColors: u} = lm(i.plyanim, {
                    vertexColors: !0,
                    size: .03,
                    sizeAttenuation: 1e-4
                })
                  , d = new al({
                    size: c,
                    sizeAttenuation: h,
                    vertexColors: u
                })
                  , p = new ul(l,d);
                p.morphTargetInfluences[0] = 1,
                e.animatedPoints = p,
                e.morphTargetTargetIndex = 1,
                o.add(p)
            } else
                r.assets.ply.forEach((e=>{
                    o.add(new ul(e,a))
                }
                ));
        else
            o.add(new ul(r.assets.ply,a));
        e.model ? e.model.add(o) : e.model = o
    }
})
  , Lm = ["audio", "action", "actions", "idleActions", "enterActions", "exitActions", "loopActions", "buffer", "target", "distanceTarget"]
  , Rm = (e,t,n)=>{
    var i = t.min / t.max
      , r = 1 - e / t.max + i;
    return Math.max(n.min, Math.min(n.max, r))
}
;
var Pm = Object.freeze({
    __proto__: null,
    calcScaleByDistance: Rm,
    SpatialObjects: class {
        constructor(e) {
            this.finished = !1,
            this.opening = !1,
            this.looping = !1,
            this.closing = !0;
            var n = !1;
            if (e.spatials.forEach((i=>{
                var {audio: r, action: o, actions: l, idleActions: c=[], enterActions: h=[], exitActions: u=[], loopActions: d=[], buffer: p, target: m, distanceTarget: f} = i
                  , g = s(i, Lm);
                e.model.traverse((i=>{
                    if (um({
                        node: i,
                        search: m
                    })) {
                        var s = t(t({}, g), {}, {
                            node: i
                        });
                        if (f && (s.distanceTarget = e.model.getObjectByName(f)),
                        p)
                            s.audio = p;
                        else if (r) {
                            var v;
                            null !== (v = e.preload.assets.audioElements) && void 0 !== v && v.length && (s.audio = e.preload.assets.audioElements.find((e=>e.dataset.name === r)))
                        }
                        var x = [];
                        if (k.arr(l) && l.length && (e.actions.filter((e=>l.includes(e._clip.name))),
                        a("finalActions"),
                        s.off || x.forEach((e=>e.paused = !0))),
                        o) {
                            var y = AnimationClip.findByName(e.animations, o);
                            y && x.push(y),
                            s.off || (y.paused = !0)
                        }
                        x.length && (s.actions = x,
                        n = !0);
                        var _ = e.actions.filter((e=>c.includes(e._clip.name)))
                          , b = e.actions.filter((e=>h.includes(e._clip.name)))
                          , M = e.actions.filter((e=>d.includes(e._clip.name)))
                          , w = e.actions.filter((e=>u.includes(e._clip.name)));
                        s.off || (b.forEach((e=>{
                            e.loop = at,
                            e.paused = !0,
                            e.weight = 0,
                            e.time = 0
                        }
                        )),
                        w.forEach((e=>{
                            e.loop = at,
                            e.paused = !0,
                            e.weight = 0,
                            e.time = 0
                        }
                        )),
                        M.forEach((e=>{
                            e.paused = !0,
                            e.weight = 0,
                            e.time = 0
                        }
                        ))),
                        s.enter = b,
                        s.loop = M,
                        s.exit = w,
                        s.idle = _,
                        n = !0,
                        e.spatialObjects.push(s)
                    }
                }
                ))
            }
            )),
            n) {
                var i = [e.mixer, "finished", e=>{
                    var {name: t} = e.action._clip;
                    t.includes("enter") && !this.looping ? this.looping = !0 : t.includes("exit") && !this.finished && (this.finished = !0,
                    this.closing = !1)
                }
                ];
                pd.on(...i),
                e.eventsToRemove.push(i)
            }
        }
        render(e) {
            var {engine: t} = e;
            t.modelSpawned && t.spatialObjects.forEach((e=>{
                var {node: n, distanceTarget: i, exclusive: r=!1, restart: s, actions: o, idle: l=[], enter: c=[], loop: h=[], exit: u=[], audio: d, scale: p, off: m, fn: f, yDistanceTest: g=!0} = e
                  , {distance: v={
                    max: 2,
                    min: 0
                }} = e
                  , x = i || n
                  , y = new pn;
                x.getWorldPosition(y);
                var _ = g ? y.y : t.camera.position.y
                  , b = new pn(y.x,_,y.z)
                  , M = t.camera.position.distanceTo(b);
                if (k.num(v) ? v = {
                    min: 0,
                    max: v
                } : v.hasOwnProperty("min") || (v.min = 0),
                p) {
                    k.num(p) ? a("scale") : p.hasOwnProperty("min") || (p.min = 0);
                    var w = Rm(M, v, p);
                    n.scale.set(w, w, w)
                }
                if (d) {
                    var S = k.fn(d.getVolume) ? d.getVolume() : d.volume
                      , T = Math.max(0, Math.min(1, 1 - M / v.max + v.min / v.max));
                    Math.abs(S - T) > .02 && (T > 0 && d.paused && d.play(),
                    k.fn(d.setVolume) ? d.setVolume(T) : d.volume = T),
                    s && (M > v.max || M < v.min) && (d.currentTime = 0,
                    d.pause())
                }
                M <= v.max && M >= v.min ? this.opening ? this.looping && (this.looping = !1,
                u.forEach((e=>{
                    e.weight = 0,
                    e.paused = !0
                }
                )),
                l.forEach((e=>{
                    e.weight = 0,
                    e.paused = !0
                }
                )),
                c.forEach((e=>{
                    e.weight = 0,
                    e.paused = !0
                }
                )),
                h.forEach((e=>{
                    e.time = 0,
                    e.weight = 1,
                    e.paused = !1
                }
                )),
                this.closing = !1) : (u.forEach((e=>{
                    e.weight = 0,
                    e.paused = !0
                }
                )),
                l.forEach((e=>{
                    e.weight = 0,
                    e.paused = !0
                }
                )),
                h.forEach((e=>{
                    e.weight = 0,
                    e.paused = !0
                }
                )),
                c.forEach((e=>{
                    e.time = 0,
                    e.weight = 1,
                    e.paused = !1
                }
                )),
                this.opening = !0,
                this.closing = !1) : this.closing ? this.finished && (console.log("start idling"),
                u.forEach((e=>{
                    e.weight = 0,
                    e.paused = !0
                }
                )),
                h.forEach((e=>{
                    e.weight = 0,
                    e.paused = !0
                }
                )),
                c.forEach((e=>{
                    e.weight = 0,
                    e.paused = !0
                }
                )),
                l.forEach((e=>{
                    e.time = 0,
                    e.weight = 1,
                    e.paused = !1
                }
                )),
                this.looping = !1,
                this.finished = !1) : (h.forEach((e=>{
                    e.weight = 0,
                    e.paused = !0
                }
                )),
                l.forEach((e=>{
                    e.weight = 0,
                    e.paused = !0
                }
                )),
                c.forEach((e=>{
                    e.weight = 0,
                    e.paused = !0
                }
                )),
                u.forEach((e=>{
                    e.time = 0,
                    e.weight = 1,
                    e.paused = !1
                }
                )),
                this.opening = !1,
                this.looping = !1,
                this.closing = !0),
                o && o.length && o.forEach((e=>{
                    M <= v.max && M >= v.min ? m ? e.paused || (e.paused = !0) : e.paused && (r ? t.actions.forEach((t=>{
                        t !== e ? t.paused || (t.paused = !0) : t.paused && (t.paused = !1)
                    }
                    )) : e.paused = !1) : m ? e.paused && (e.paused = !1) : e.paused || (e.paused = !0)
                }
                )),
                f && k.fn(t.sceneInstance[f]) && t.sceneInstance[f]({
                    node: n,
                    config: {
                        distance: v
                    },
                    distance: M
                })
            }
            ))
        }
    }
});
var Im = Object.freeze({
    __proto__: null,
    LookAtCamera: class {
        constructor(e) {
            this.lookAtPosition = new pn,
            this.camPos = new pn,
            this.objPos = new pn;
            var {artifact: t, model: n} = e;
            n.traverse((n=>{
                var i = t.lookAtCameraObjects.find((e=>um({
                    node: n,
                    search: k.str(e) ? e : e.name
                })));
                if (i) {
                    var {speed: r, lookAtY: s=!0} = i;
                    r = k.num(r) ? r : t.lookAtSpeed,
                    s = k.bool(t.lookAtY) ? t.lookAtY : s,
                    e.lookAtCameraObjects.push({
                        speed: r,
                        lookAtY: s,
                        node: n,
                        alpha: 0
                    })
                }
            }
            ))
        }
        render(e) {
            var {engine: t, delta: n} = e
              , {camera: i, lookAtCameraObjects: r=[], lookAtY: s} = t;
            r.forEach((e=>{
                var {lookAtY: t=!0, node: r, speed: a} = e;
                if (!1 !== t && 0 != s) {
                    var o, l, c, h;
                    if (e.alpha += n * a,
                    this.lookAtPosition.x = 0,
                    this.lookAtPosition.y = 0,
                    this.lookAtPosition.z = r.position.distanceTo(i.position),
                    !1 !== t && !1 !== s || (this.lookAtPosition.y = 0 === r.position.y ? .01 : r.position.y),
                    this.lookAtPosition.distanceToSquared(this.camPos) > .1) {
                        var {x: u, y: d, z: p} = i.position;
                        this.camPos.set(u, d, p),
                        this.lookAtPosition.lerp(this.camPos, Math.min(1, e.alpha)),
                        r.lookAt(this.lookAtPosition)
                    } else
                        e.alpha = 0
                } else {
                    var m = i.position;
                    this.camPos.set(m.x, m.y, m.z),
                    this.lookAtPosition.set(r.position.x, r.position.y, r.position.z);
                    var f = (o = this.camPos.x,
                    l = this.lookAtPosition.x,
                    c = this.camPos.z,
                    h = this.lookAtPosition.z,
                    Math.atan2(o - l, c - h));
                    r.rotation.y = f
                }
            }
            ))
        }
    }
});
class Dm extends or {
    constructor(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}
          , n = arguments.length > 2 ? arguments[2] : void 0;
        super(e),
        this.type = "Reflector",
        this.XR = n.XR,
        this.skybox = n.skybox,
        this.shadowPlane = n.shadowPlane;
        var i = this
          , {textureHeight: r=512, textureWidth: s=512, clipBias: a=0, fragmentShader: o=Nm, vertexShader: l=Om} = t
          , c = void 0 !== t.color ? new en(t.color) : new en(8355711)
          , h = new wr
          , u = new pn
          , d = new pn
          , p = new pn
          , m = new Wn
          , f = new pn(0,0,-1)
          , g = new ln
          , v = new pn
          , x = new pn
          , y = new ln
          , _ = new Wn
          , b = new fr
          , M = new cn(s,r,{
            minFilter: we,
            magFilter: we,
            format: Ie
        });
        Ut.isPowerOfTwo(s) && Ut.isPowerOfTwo(r) || (M.texture.generateMipmaps = !1);
        var w = {
            tDiffuse: {
                value: M.texture
            },
            color: {
                value: c
            },
            textureMatrix: {
                value: _
            }
        }
          , S = new pr({
            uniforms: w,
            fragmentShader: o,
            vertexShader: l
        });
        this.material = S,
        this.onBeforeRender = (e,t,n)=>{
            var r;
            if (d.setFromMatrixPosition(i.matrixWorld),
            p.setFromMatrixPosition(n.matrixWorld),
            m.extractRotation(i.matrixWorld),
            u.set(0, 0, 1),
            u.applyMatrix4(m),
            v.subVectors(d, p),
            !(v.dot(u) > 0)) {
                v.reflect(u).negate(),
                v.add(d),
                m.extractRotation(n.matrixWorld),
                f.set(0, 0, -1),
                f.applyMatrix4(m),
                f.add(p),
                x.subVectors(d, f),
                x.reflect(u).negate(),
                x.add(d),
                b.position.copy(v),
                b.up.set(0, 1, 0),
                b.up.applyMatrix4(m),
                b.up.reflect(u),
                b.lookAt(x),
                b.far = n.far,
                b.updateMatrixWorld(),
                b.projectionMatrix.copy(n.projectionMatrix),
                _.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
                _.multiply(b.projectionMatrix),
                _.multiply(b.matrixWorldInverse),
                _.multiply(i.matrixWorld),
                h.setFromNormalAndCoplanarPoint(u, d),
                h.applyMatrix4(b.matrixWorldInverse),
                g.set(h.normal.x, h.normal.y, h.normal.z, h.constant);
                var s = b.projectionMatrix;
                y.x = (Math.sign(g.x) + s.elements[8]) / s.elements[0],
                y.y = (Math.sign(g.y) + s.elements[9]) / s.elements[5],
                y.z = -1,
                y.w = (1 + s.elements[10]) / s.elements[14],
                g.multiplyScalar(2 / g.dot(y)),
                s.elements[2] = g.x,
                s.elements[6] = g.y,
                s.elements[10] = g.z + 1 - a,
                s.elements[14] = g.w,
                M.texture.encoding = e.outputEncoding,
                i.visible = !1;
                var o = e.getRenderTarget()
                  , l = e.xr.enabled
                  , c = e.shadowMap.autoUpdate;
                e.xr.enabled = !1,
                e.shadowMap.autoUpdate = !1,
                e.setRenderTarget(M),
                e.state.buffers.depth.setMask(!0),
                !1 === e.autoClear && e.clear(),
                this.XR && this.skybox && (this.skybox.visible = !0);
                var w = !1;
                null !== (r = this.shadowPlane) && void 0 !== r && r.visible && (this.shadowPlane.visible = !1,
                w = !0),
                e.render(t, b),
                e.xr.enabled = l,
                e.shadowMap.autoUpdate = c,
                e.setRenderTarget(o),
                this.XR && this.skybox && (this.skybox.visible = !1),
                w && (this.shadowPlane.visible = !0);
                var S = n.viewport;
                void 0 !== S && e.state.viewport(S),
                i.visible = !0
            }
        }
        ,
        this.getRenderTarget = ()=>M
    }
}
Dm.prototype.isReflector = !0;
var Om = "\nuniform mat4 textureMatrix;\nvarying vec4 vUv;\n\n#include <common>\n#include <logdepthbuf_pars_vertex>\n\nvoid main() {\n  vUv = textureMatrix * vec4( position, 1.0 );\n\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n  #include <logdepthbuf_vertex>\n}"
  , Nm = "\nuniform vec3 color;\nuniform sampler2D tDiffuse;\nvarying vec4 vUv;\n\n#include <logdepthbuf_pars_fragment>\n\nfloat blendOverlay( float base, float blend ) {\n  return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n}\n\nvec3 blendOverlay( vec3 base, vec3 blend ) {\n  return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n}\n\nvoid main() {\n  #include <logdepthbuf_fragment>\n\n  vec4 base = texture2DProj( tDiffuse, vUv );\n  gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n}\n"
  , zm = Object.freeze({
    __proto__: null,
    mirror: e=>{
        var {mirrors: t} = e.artifact
          , n = G.devicePixelRatio
          , i = G.innerWidth * n
          , r = G.innerHeight * n;
        e.mirrors = t.map((t=>{
            var n, {clipBias: s=.003, color: a=7829367, type: o, params: l=[4, 32], rotation: c={}, position: h={}} = t, u = G.APP_DB.MESH_TYPES;
            o === u.CIRCLE ? n = new kl(...l) : o === u.PLANE ? n = new Lr(...l) : o === u.RING ? (console.warn("W_MIRROR_WITH_VOLUME", "Mirror is using a RingGeometry. Mirrors with volume will sometimes create rendering issues."),
            n = new Lc(...l)) : o === u.BOX ? (console.warn("W_MIRROR_WITH_VOLUME", "Mirror is using a BoxGeometry. Mirrors with volume will sometimes create rendering issues."),
            n = new BoxGeometry(...l)) : o === u.SPHERE ? (console.warn("W_MIRROR_WITH_VOLUME", "Mirror is using a SphereGeometry. Mirrors with volume will sometimes create rendering issues."),
            n = new Pc(...l)) : n = new Lr(...l);
            var d = new Dm(n,{
                clipBias: s,
                textureWidth: i,
                textureHeight: r,
                color: a
            },e)
              , {x: p, y: m, z: f} = c;
            if (p) {
                var g = Ut.degToRad(p);
                d.rotateX(g)
            }
            if (m) {
                var v = Ut.degToRad(m);
                d.rotateY(v)
            }
            if (f) {
                var x = Ut.degToRad(f);
                d.rotateZ(x)
            }
            var {x: y, y: _, z: b} = h;
            return y && d.position.setX(y),
            _ && d.position.setY(_),
            b && d.position.setZ(b),
            e.model.add(d),
            d
        }
        ))
    }
});
var Um = Object.freeze({
    __proto__: null,
    AnalyseAudio: class {
        constructor(e) {
            var t, {audioElement: n, audioElements: i=[]} = e.preload.assets;
            n || null != i && i.length ? ([n, ...i].filter((e=>e)).forEach((t=>{
                var n = new AudioContext
                  , i = n.createMediaElementSource(t)
                  , r = n.createAnalyser();
                r.fftSize = e.artifact.fftSize || 32,
                i.connect(r),
                i.connect(n.destination);
                var s = new Uint8Array(r.frequencyBinCount);
                r.getByteFrequencyData(s),
                e.audioAnalysers.push({
                    name: t.id,
                    analyser: r,
                    array: s
                })
            }
            )),
            null === (t = e.artifact.audioAnalyserEmission) || void 0 === t || t.forEach((t=>{
                var n = lm(t, {
                    intensity: .004,
                    minIntensity: 0,
                    color: [],
                    target: ""
                })
                  , i = [];
                e.model.traverse((e=>{
                    var t;
                    um({
                        node: e,
                        search: n.target
                    }) && (e.material ? i.includes(e.material) || i.push(e.material) : null !== (t = e.children) && void 0 !== t && t.length && e.children.forEach((e=>{
                        e.material && i.push(e.material)
                    }
                    )))
                }
                )),
                n.targets = i,
                n.targets.length || console.warn("W_AUDIO_ANALYSER_EMISSION_CONFIGS", "Audio analyser emission config does not find a target", n, e.model),
                e.audioAnalyserEmissionConfigs.push(n)
            }
            ))) : console.warn("W_AUDIO_ANALYSER", "artifact.audioAnalyser was set but no audioElements have been registered.")
        }
        render(e) {
            var {delta: t, engine: n, frame: i, timestamp: r} = e
              , {actions: s, ambientLight: a, artifact: o, audioAnalysers: l, audioAnalyserEmissionConfigs: c, audioRamps: h={}, sceneInstance: u} = n
              , {audioAnalyserAnimation: d, audioAnalyserAnimations: p=[], audioAnalyserLights: m} = o
              , f = 0
              , g = l.map((e=>{
                var {name: t, analyser: n, array: i} = e;
                n.getByteFrequencyData(i);
                var r = i.reduce(((e,t)=>e + t)) / i.length;
                return h[t] = {
                    array: i,
                    average: f
                },
                f += r,
                i
            }
            ))
              , v = f / 255;
            if (k.fn(null == u ? void 0 : u.renderAudioAnalyser) && u.renderAudioAnalyser({
                average: f,
                values: g,
                delta: t,
                timestamp: r,
                frame: i,
                engine: n
            }),
            d || p.length) {
                var x = lm(o, {
                    audioAnalyserIntensity: 1
                })
                  , y = Math.min(1, f * x.audioAnalyserIntensity / 220);
                if (d) {
                    var _ = s.find((e=>e._clip.name === d));
                    _.weight = y,
                    _.time = null == _ ? void 0 : _._clip.duration
                }
                p.length && s.forEach((e=>{
                    var t = e._clip.name
                      , n = p.find((e=>e === t || e.action === t));
                    if (n) {
                        if (k.obj(n)) {
                            var {useAverage: i=!0} = n;
                            if (i)
                                e.weight = y;
                            else {
                                var {index: r=6, divisor: s=220} = n
                                  , a = g.map((e=>e[r])).reduce(((e,t)=>e + t))
                                  , o = Math.min(1, a / s);
                                e.weight = o
                            }
                        } else
                            e.weight = y;
                        e.time = e._clip.duration
                    }
                }
                ))
            }
            if (m) {
                var b = lm(o, {
                    lightIntensity: 1,
                    levelMultiplier: 2
                })
                  , M = b.lightIntensity * (v * b.levelMultiplier);
                a.intensity = M
            }
            null != c && c.length && c.forEach((e=>{
                var t = e.intensity * v;
                e.targets.forEach((n=>{
                    var i;
                    t > e.minIntensity ? n.emissiveIntensity = t : n.emissiveIntensity = 0,
                    null !== (i = e.color) && void 0 !== i && i.length && (n.emissive = new en(...e.color))
                }
                ))
            }
            ))
        }
    }
});
function Fm(e) {
    const t = new Map
      , n = new Map
      , i = e.clone();
    return Bm(e, i, (function(e, i) {
        t.set(i, e),
        n.set(e, i)
    }
    )),
    i.traverse((function(e) {
        if (!e.isSkinnedMesh)
            return;
        const i = e
          , r = t.get(e)
          , s = r.skeleton.bones;
        i.skeleton = r.skeleton.clone(),
        i.bindMatrix.copy(r.bindMatrix),
        i.skeleton.bones = s.map((function(e) {
            return n.get(e)
        }
        )),
        i.bind(i.skeleton, i.bindMatrix)
    }
    )),
    i
}
function Bm(e, t, n) {
    n(e, t);
    for (let i = 0; i < e.children.length; i++)
        Bm(e.children[i], t.children[i], n)
}
var km = Object.freeze({
    __proto__: null,
    Clones: class {
        constructor(e) {
            var t = this;
            this.spawnableClones = [],
            this.cloneMixers = [],
            this.waitingForSpawn = [],
            this.camPos = new pn;
            var n = e.artifact.clones
              , {delay: i, radius: r, scale: s, positions: a=[], x: o, y: l, z: c} = n;
            a.length && (this.freePositions = a),
            n.delay = pm(i),
            n.scale = pm(s),
            n.x = pm(o),
            n.y = pm(l),
            n.z = pm(c),
            n.radius = pm(r);
            var h = e.model;
            n.target && (h = e.model.getObjectByName(n.target));
            for (var u = e.actions.filter((e=>k.arr(n.action) ? n.action.includes(e._clip.name) : e._clip.name === n.action)), d = function() {
                var n = Fm(h)
                  , i = new Au(n);
                n.userData.actions = [],
                u.forEach((e=>{
                    var t = i.clipAction(e._clip);
                    n.userData.actions.push(t)
                }
                )),
                n.userData.mixer = i,
                t.spawnableClones.push(n),
                t.cloneMixers.push(i),
                n.position.set(2e3, 2e3, 2e3),
                e.scene.add(n);
                var r = [i, "loop", ()=>{
                    n.userData.waiting = !1
                }
                ];
                pd.on(...r),
                e.eventsToRemove.push(r)
            }, p = 0; p < n.number; p++)
                d()
        }
        render(e) {
            var t, {delta: n, engine: i, timestamp: r} = e, {delay: s, rotate: a=!0, scale: o, timeScale: l, positions: c=[], lookAtCamera: h, lookAtY: u=!0, y: d, radius: p, spawnArea: m="circle"} = i.artifact.clones;
            this.cloneMixers.forEach(((e,t)=>{
                e.update(n)
            }
            )),
            this.spawnableClones.forEach(((e,t)=>{
                this.waitingForSpawn.includes(e) || e.userData.waiting || (this.waitingForSpawn.push(e),
                e.userData.waiting = !0,
                e.userData.wait || (e.userData.wait = r + om(s)),
                e.userData.actions.forEach(((e,t)=>{
                    e.paused = !0,
                    e.time = 0
                }
                )),
                l && (e.userData.mixer.timeScale = om(l)),
                a && e.rotation.set(0, 359.9 * Math.random(), 0),
                e.position.set(2e3, 2e3, 2e3))
            }
            )),
            null !== (t = this.freePositions) && void 0 !== t && t.length && (e=>{
                for (var t = e.length - 1; t > 0; t--) {
                    var n = Math.floor(Math.random() * (t + 1));
                    [e[t],e[n]] = [e[n], e[t]]
                }
            }
            )(this.freePositions),
            this.waitingForSpawn.forEach((e=>{
                if (e.userData.wait <= r) {
                    var t;
                    if (o) {
                        var n = om(o);
                        e.scale.set(n, n, n)
                    }
                    var a, l, h = i.camera.position, u = 359.999 * Math.random(), d = om(p), f = i.scene.position.y;
                    if (null !== (t = this.freePositions) && void 0 !== t && t.length) {
                        var [g,v,x] = this.freePositions.pop();
                        a = g,
                        f = v,
                        l = x,
                        this.freePositions.length < c.length / 2 && (this.freePositions = [...c])
                    } else
                        "circle" === m ? (a = (h.x + d) * M.cos(u),
                        l = (h.z + d) * M.sin(u)) : (a = (h.x + d) * M.cos(u),
                        l = (h.z + d) * M.sin(u) * -1);
                    e.position.set(a, f - 2, l),
                    e.userData.actions.forEach(((e,t)=>{
                        e.paused = !1,
                        e.play()
                    }
                    ));
                    var y = this.waitingForSpawn.indexOf(e);
                    this.waitingForSpawn.splice(y, 1),
                    e.userData.wait = r + om(s)
                }
            }
            ))
        }
    }
});
var Gm = Object.freeze({
    __proto__: null,
    TextGeometry: class extends Tc {
        constructor(e, t={}) {
            const n = t.font;
            if (void 0 === n)
                super();
            else {
                const i = n.generateShapes(e, t.size);
                t.depth = void 0 !== t.height ? t.height : 50,
                void 0 === t.bevelThickness && (t.bevelThickness = 10),
                void 0 === t.bevelSize && (t.bevelSize = 8),
                void 0 === t.bevelEnabled && (t.bevelEnabled = !1),
                super(i, t)
            }
            this.type = "TextGeometry"
        }
    }
});
export {pd as $, lm as A, x as B, ru as C, ro as D, O as E, gt as F, ie as G, N as H, Bh as I, _ as J, kh as K, Lr as L, Bc as M, b as N, or as O, fr as P, Li as Q, Lc as R, lo as S, ad as T, cm as U, ae as V, G as W, le as X, um as Y, nm as Z, t as _, k as a, ym as a$, en as a0, Pc as a1, Yr as a2, se as a3, Ut as a4, hu as a5, T as a6, vm as a7, y as a8, pn as a9, ul as aA, fi as aB, Gc as aC, sd as aD, Uh as aE, we as aF, fl as aG, ao as aH, Ka as aI, Ni as aJ, Oi as aK, he as aL, ft as aM, cr as aN, qc as aO, Sl as aP, Nc as aQ, em as aR, Zo as aS, rl as aT, xm as aU, al as aV, dm as aW, Vc as aX, Lu as aY, oe as aZ, zc as a_, Au as aa, at as ab, mh as ac, uu as ad, rm as ae, D as af, re as ag, S as ah, A as ai, pl as aj, Sh as ak, Yd as al, Jp as am, eu as an, Kp as ao, sm as ap, C as aq, o as ar, j as as, w as at, P as au, I as av, _e as aw, Vi as ax, Ii as ay, pr as az, Nd as b, dn as b0, Hl as b1, Dc as b2, Wn as b3, _m as b4, bm as b5, Mm as b6, wm as b7, Tm as b8, Am as b9, Em as ba, Cm as bb, Pm as bc, Im as bd, zm as be, Um as bf, km as bg, Gm as bh, i as c, L as d, l as e, h as f, u as g, hd as h, g as i, F as j, zd as k, c as l, cd as m, Ud as n, E as o, Fd as p, kd as q, $ as r, qd as s, v as t, z as u, U as v, Q as w, Td as x, Ad as y, R as z};
